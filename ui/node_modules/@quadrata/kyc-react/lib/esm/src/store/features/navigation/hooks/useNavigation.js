import { useCallback, useMemo } from 'react';
import { useAppDispatch, useAppSelector } from '../../../store';
import { Page, PageError, setPage, reset } from '../navigation.slice';
import { updateVeriffSession } from '../../veriff/veriff-session.slice';
import { setEthereumContract } from '../../ethereum/ethereum-contract.slice';
import { useSettings } from '../../settings/hooks/useSettings';
export var useNavigation = function () {
    var dispatch = useAppDispatch();
    var page = useAppSelector(function (state) { return state.navigation; }).page;
    var debug = useSettings().debug;
    var navigate = useCallback(function (page) {
        debug && console.log('Navigating to page: ', page);
        dispatch(setPage(page));
    }, [dispatch]);
    var navigateByStatus = useCallback(function (_a) {
        var veriffSession = _a.veriffSession, contractParameters = _a.contractParameters, error = _a.error;
        debug && console.log('Navigating by status: ', veriffSession, contractParameters, error);
        if (error) {
            debug && console.log('Navigation by status error: ', error);
            dispatch(setPage(PageError.KYC_ERROR));
        }
        else if (veriffSession) {
            dispatch(updateVeriffSession({
                id: veriffSession.id,
                url: veriffSession.url,
                vendorData: veriffSession.vendorData,
                host: veriffSession.host,
                status: veriffSession.status,
                sessionToken: veriffSession.sessionToken,
            }));
            dispatch(setPage(Page.VERIFF));
        }
        else if (contractParameters) {
            dispatch(setEthereumContract({
                governanceAddress: contractParameters.governanceAddress,
                contractAddress: contractParameters.address,
                country: contractParameters.country,
                aml: contractParameters.aml,
                did: contractParameters.did,
                signature: contractParameters.signature,
                issuedAt: contractParameters.issuedAt,
                tokenId: contractParameters.tokenId,
                isBusiness: contractParameters.isBusiness,
            }));
            dispatch(setPage(Page.MINT_NFT));
        }
    }, [dispatch]);
    var resetNavigation = useCallback(function () {
        dispatch(reset());
    }, [dispatch]);
    return useMemo(function () {
        return {
            page: page,
            navigate: navigate,
            resetNavigation: resetNavigation,
            navigateByStatus: navigateByStatus,
        };
    }, [page, navigate, resetNavigation, navigateByStatus]);
};
