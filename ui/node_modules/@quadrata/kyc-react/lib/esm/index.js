import React, { useContext, useDebugValue, useLayoutEffect, useEffect, useMemo, useCallback, useState, createContext, PureComponent, createRef, useRef, Fragment as Fragment$1 } from 'react';
import { unstable_batchedUpdates } from 'react-dom';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends$1(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter$g(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_production_min;

function requireReactJsxRuntime_production_min () {
	if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
	hasRequiredReactJsxRuntime_production_min = 1;
var f=React,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
	function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;
	return reactJsxRuntime_production_min;
}

var reactJsxRuntime_development = {};

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_development;

function requireReactJsxRuntime_development () {
	if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
	hasRequiredReactJsxRuntime_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	var React$1 = React;

	// -----------------------------------------------------------------------------

	var enableScopeAPI = false; // Experimental Create Event Handle API.
	var enableCacheElement = false;
	var enableTransitionTracing = false; // No known bugs, but needs performance testing

	var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
	// stuff. Intended to enable React core members to more easily debug scheduling
	// issues in DEV builds.

	var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

	// ATTENTION

	var REACT_ELEMENT_TYPE =  Symbol.for('react.element');
	var REACT_PORTAL_TYPE =  Symbol.for('react.portal');
	var REACT_FRAGMENT_TYPE =  Symbol.for('react.fragment');
	var REACT_STRICT_MODE_TYPE =  Symbol.for('react.strict_mode');
	var REACT_PROFILER_TYPE =  Symbol.for('react.profiler');
	var REACT_PROVIDER_TYPE =  Symbol.for('react.provider');
	var REACT_CONTEXT_TYPE =  Symbol.for('react.context');
	var REACT_FORWARD_REF_TYPE =  Symbol.for('react.forward_ref');
	var REACT_SUSPENSE_TYPE =  Symbol.for('react.suspense');
	var REACT_SUSPENSE_LIST_TYPE =  Symbol.for('react.suspense_list');
	var REACT_MEMO_TYPE =  Symbol.for('react.memo');
	var REACT_LAZY_TYPE =  Symbol.for('react.lazy');
	var REACT_OFFSCREEN_TYPE =  Symbol.for('react.offscreen');
	var MAYBE_ITERATOR_SYMBOL =  Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator';
	function getIteratorFn(maybeIterable) {
	  if (maybeIterable === null || typeof maybeIterable !== 'object') {
	    return null;
	  }

	  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

	  if (typeof maybeIterator === 'function') {
	    return maybeIterator;
	  }

	  return null;
	}

	var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

	function error(format) {
	  {
	    {
	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      printWarning('error', format, args);
	    }
	  }
	}

	function printWarning(level, format, args) {
	  // When changing this logic, you might want to also
	  // update consoleWithStackDev.www.js as well.
	  {
	    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	    var stack = ReactDebugCurrentFrame.getStackAddendum();

	    if (stack !== '') {
	      format += '%s';
	      args = args.concat([stack]);
	    } // eslint-disable-next-line react-internal/safe-string-coercion


	    var argsWithFormat = args.map(function (item) {
	      return String(item);
	    }); // Careful: RN currently depends on this prefix

	    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
	    // breaks IE9: https://github.com/facebook/react/issues/13610
	    // eslint-disable-next-line react-internal/no-production-logging

	    Function.prototype.apply.call(console[level], console, argsWithFormat);
	  }
	}

	var REACT_MODULE_REFERENCE;

	{
	  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
	}

	function isValidElementType(type) {
	  if (typeof type === 'string' || typeof type === 'function') {
	    return true;
	  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


	  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
	    return true;
	  }

	  if (typeof type === 'object' && type !== null) {
	    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
	    // types supported by any Flight configuration anywhere since
	    // we don't know which Flight build this will end up being used
	    // with.
	    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
	      return true;
	    }
	  }

	  return false;
	}

	function getWrappedName(outerType, innerType, wrapperName) {
	  var displayName = outerType.displayName;

	  if (displayName) {
	    return displayName;
	  }

	  var functionName = innerType.displayName || innerType.name || '';
	  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
	} // Keep in sync with react-reconciler/getComponentNameFromFiber


	function getContextName(type) {
	  return type.displayName || 'Context';
	} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


	function getComponentNameFromType(type) {
	  if (type == null) {
	    // Host root, text node or just invalid type.
	    return null;
	  }

	  {
	    if (typeof type.tag === 'number') {
	      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
	    }
	  }

	  if (typeof type === 'function') {
	    return type.displayName || type.name || null;
	  }

	  if (typeof type === 'string') {
	    return type;
	  }

	  switch (type) {
	    case REACT_FRAGMENT_TYPE:
	      return 'Fragment';

	    case REACT_PORTAL_TYPE:
	      return 'Portal';

	    case REACT_PROFILER_TYPE:
	      return 'Profiler';

	    case REACT_STRICT_MODE_TYPE:
	      return 'StrictMode';

	    case REACT_SUSPENSE_TYPE:
	      return 'Suspense';

	    case REACT_SUSPENSE_LIST_TYPE:
	      return 'SuspenseList';

	  }

	  if (typeof type === 'object') {
	    switch (type.$$typeof) {
	      case REACT_CONTEXT_TYPE:
	        var context = type;
	        return getContextName(context) + '.Consumer';

	      case REACT_PROVIDER_TYPE:
	        var provider = type;
	        return getContextName(provider._context) + '.Provider';

	      case REACT_FORWARD_REF_TYPE:
	        return getWrappedName(type, type.render, 'ForwardRef');

	      case REACT_MEMO_TYPE:
	        var outerName = type.displayName || null;

	        if (outerName !== null) {
	          return outerName;
	        }

	        return getComponentNameFromType(type.type) || 'Memo';

	      case REACT_LAZY_TYPE:
	        {
	          var lazyComponent = type;
	          var payload = lazyComponent._payload;
	          var init = lazyComponent._init;

	          try {
	            return getComponentNameFromType(init(payload));
	          } catch (x) {
	            return null;
	          }
	        }

	      // eslint-disable-next-line no-fallthrough
	    }
	  }

	  return null;
	}

	var assign = Object.assign;

	// Helpers to patch console.logs to avoid logging during side-effect free
	// replaying on render function. This currently only patches the object
	// lazily which won't cover if the log function was extracted eagerly.
	// We could also eagerly patch the method.
	var disabledDepth = 0;
	var prevLog;
	var prevInfo;
	var prevWarn;
	var prevError;
	var prevGroup;
	var prevGroupCollapsed;
	var prevGroupEnd;

	function disabledLog() {}

	disabledLog.__reactDisabledLog = true;
	function disableLogs() {
	  {
	    if (disabledDepth === 0) {
	      /* eslint-disable react-internal/no-production-logging */
	      prevLog = console.log;
	      prevInfo = console.info;
	      prevWarn = console.warn;
	      prevError = console.error;
	      prevGroup = console.group;
	      prevGroupCollapsed = console.groupCollapsed;
	      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

	      var props = {
	        configurable: true,
	        enumerable: true,
	        value: disabledLog,
	        writable: true
	      }; // $FlowFixMe Flow thinks console is immutable.

	      Object.defineProperties(console, {
	        info: props,
	        log: props,
	        warn: props,
	        error: props,
	        group: props,
	        groupCollapsed: props,
	        groupEnd: props
	      });
	      /* eslint-enable react-internal/no-production-logging */
	    }

	    disabledDepth++;
	  }
	}
	function reenableLogs() {
	  {
	    disabledDepth--;

	    if (disabledDepth === 0) {
	      /* eslint-disable react-internal/no-production-logging */
	      var props = {
	        configurable: true,
	        enumerable: true,
	        writable: true
	      }; // $FlowFixMe Flow thinks console is immutable.

	      Object.defineProperties(console, {
	        log: assign({}, props, {
	          value: prevLog
	        }),
	        info: assign({}, props, {
	          value: prevInfo
	        }),
	        warn: assign({}, props, {
	          value: prevWarn
	        }),
	        error: assign({}, props, {
	          value: prevError
	        }),
	        group: assign({}, props, {
	          value: prevGroup
	        }),
	        groupCollapsed: assign({}, props, {
	          value: prevGroupCollapsed
	        }),
	        groupEnd: assign({}, props, {
	          value: prevGroupEnd
	        })
	      });
	      /* eslint-enable react-internal/no-production-logging */
	    }

	    if (disabledDepth < 0) {
	      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
	    }
	  }
	}

	var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
	var prefix;
	function describeBuiltInComponentFrame(name, source, ownerFn) {
	  {
	    if (prefix === undefined) {
	      // Extract the VM specific prefix used by each line.
	      try {
	        throw Error();
	      } catch (x) {
	        var match = x.stack.trim().match(/\n( *(at )?)/);
	        prefix = match && match[1] || '';
	      }
	    } // We use the prefix to ensure our stacks line up with native stack frames.


	    return '\n' + prefix + name;
	  }
	}
	var reentry = false;
	var componentFrameCache;

	{
	  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
	  componentFrameCache = new PossiblyWeakMap();
	}

	function describeNativeComponentFrame(fn, construct) {
	  // If something asked for a stack inside a fake render, it should get ignored.
	  if ( !fn || reentry) {
	    return '';
	  }

	  {
	    var frame = componentFrameCache.get(fn);

	    if (frame !== undefined) {
	      return frame;
	    }
	  }

	  var control;
	  reentry = true;
	  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

	  Error.prepareStackTrace = undefined;
	  var previousDispatcher;

	  {
	    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
	    // for warnings.

	    ReactCurrentDispatcher.current = null;
	    disableLogs();
	  }

	  try {
	    // This should throw.
	    if (construct) {
	      // Something should be setting the props in the constructor.
	      var Fake = function () {
	        throw Error();
	      }; // $FlowFixMe


	      Object.defineProperty(Fake.prototype, 'props', {
	        set: function () {
	          // We use a throwing setter instead of frozen or non-writable props
	          // because that won't throw in a non-strict mode function.
	          throw Error();
	        }
	      });

	      if (typeof Reflect === 'object' && Reflect.construct) {
	        // We construct a different control for this case to include any extra
	        // frames added by the construct call.
	        try {
	          Reflect.construct(Fake, []);
	        } catch (x) {
	          control = x;
	        }

	        Reflect.construct(fn, [], Fake);
	      } else {
	        try {
	          Fake.call();
	        } catch (x) {
	          control = x;
	        }

	        fn.call(Fake.prototype);
	      }
	    } else {
	      try {
	        throw Error();
	      } catch (x) {
	        control = x;
	      }

	      fn();
	    }
	  } catch (sample) {
	    // This is inlined manually because closure doesn't do it for us.
	    if (sample && control && typeof sample.stack === 'string') {
	      // This extracts the first frame from the sample that isn't also in the control.
	      // Skipping one frame that we assume is the frame that calls the two.
	      var sampleLines = sample.stack.split('\n');
	      var controlLines = control.stack.split('\n');
	      var s = sampleLines.length - 1;
	      var c = controlLines.length - 1;

	      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
	        // We expect at least one stack frame to be shared.
	        // Typically this will be the root most one. However, stack frames may be
	        // cut off due to maximum stack limits. In this case, one maybe cut off
	        // earlier than the other. We assume that the sample is longer or the same
	        // and there for cut off earlier. So we should find the root most frame in
	        // the sample somewhere in the control.
	        c--;
	      }

	      for (; s >= 1 && c >= 0; s--, c--) {
	        // Next we find the first one that isn't the same which should be the
	        // frame that called our sample function and the control.
	        if (sampleLines[s] !== controlLines[c]) {
	          // In V8, the first line is describing the message but other VMs don't.
	          // If we're about to return the first line, and the control is also on the same
	          // line, that's a pretty good indicator that our sample threw at same line as
	          // the control. I.e. before we entered the sample frame. So we ignore this result.
	          // This can happen if you passed a class to function component, or non-function.
	          if (s !== 1 || c !== 1) {
	            do {
	              s--;
	              c--; // We may still have similar intermediate frames from the construct call.
	              // The next one that isn't the same should be our match though.

	              if (c < 0 || sampleLines[s] !== controlLines[c]) {
	                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
	                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
	                // but we have a user-provided "displayName"
	                // splice it in to make the stack more readable.


	                if (fn.displayName && _frame.includes('<anonymous>')) {
	                  _frame = _frame.replace('<anonymous>', fn.displayName);
	                }

	                {
	                  if (typeof fn === 'function') {
	                    componentFrameCache.set(fn, _frame);
	                  }
	                } // Return the line we found.


	                return _frame;
	              }
	            } while (s >= 1 && c >= 0);
	          }

	          break;
	        }
	      }
	    }
	  } finally {
	    reentry = false;

	    {
	      ReactCurrentDispatcher.current = previousDispatcher;
	      reenableLogs();
	    }

	    Error.prepareStackTrace = previousPrepareStackTrace;
	  } // Fallback to just using the name if we couldn't make it throw.


	  var name = fn ? fn.displayName || fn.name : '';
	  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

	  {
	    if (typeof fn === 'function') {
	      componentFrameCache.set(fn, syntheticFrame);
	    }
	  }

	  return syntheticFrame;
	}
	function describeFunctionComponentFrame(fn, source, ownerFn) {
	  {
	    return describeNativeComponentFrame(fn, false);
	  }
	}

	function shouldConstruct(Component) {
	  var prototype = Component.prototype;
	  return !!(prototype && prototype.isReactComponent);
	}

	function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

	  if (type == null) {
	    return '';
	  }

	  if (typeof type === 'function') {
	    {
	      return describeNativeComponentFrame(type, shouldConstruct(type));
	    }
	  }

	  if (typeof type === 'string') {
	    return describeBuiltInComponentFrame(type);
	  }

	  switch (type) {
	    case REACT_SUSPENSE_TYPE:
	      return describeBuiltInComponentFrame('Suspense');

	    case REACT_SUSPENSE_LIST_TYPE:
	      return describeBuiltInComponentFrame('SuspenseList');
	  }

	  if (typeof type === 'object') {
	    switch (type.$$typeof) {
	      case REACT_FORWARD_REF_TYPE:
	        return describeFunctionComponentFrame(type.render);

	      case REACT_MEMO_TYPE:
	        // Memo may contain any component type so we recursively resolve it.
	        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

	      case REACT_LAZY_TYPE:
	        {
	          var lazyComponent = type;
	          var payload = lazyComponent._payload;
	          var init = lazyComponent._init;

	          try {
	            // Lazy may contain any component type so we recursively resolve it.
	            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
	          } catch (x) {}
	        }
	    }
	  }

	  return '';
	}

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var loggedTypeFailures = {};
	var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

	function setCurrentlyValidatingElement(element) {
	  {
	    if (element) {
	      var owner = element._owner;
	      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	      ReactDebugCurrentFrame.setExtraStackFrame(stack);
	    } else {
	      ReactDebugCurrentFrame.setExtraStackFrame(null);
	    }
	  }
	}

	function checkPropTypes(typeSpecs, values, location, componentName, element) {
	  {
	    // $FlowFixMe This is okay but Flow doesn't know it.
	    var has = Function.call.bind(hasOwnProperty);

	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.

	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            // eslint-disable-next-line react-internal/prod-error-codes
	            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
	            err.name = 'Invariant Violation';
	            throw err;
	          }

	          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	        } catch (ex) {
	          error$1 = ex;
	        }

	        if (error$1 && !(error$1 instanceof Error)) {
	          setCurrentlyValidatingElement(element);

	          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

	          setCurrentlyValidatingElement(null);
	        }

	        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error$1.message] = true;
	          setCurrentlyValidatingElement(element);

	          error('Failed %s type: %s', location, error$1.message);

	          setCurrentlyValidatingElement(null);
	        }
	      }
	    }
	  }
	}

	var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

	function isArray(a) {
	  return isArrayImpl(a);
	}

	/*
	 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
	 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
	 *
	 * The functions in this module will throw an easier-to-understand,
	 * easier-to-debug exception with a clear errors message message explaining the
	 * problem. (Instead of a confusing exception thrown inside the implementation
	 * of the `value` object).
	 */
	// $FlowFixMe only called in DEV, so void return is not possible.
	function typeName(value) {
	  {
	    // toStringTag is needed for namespaced types like Temporal.Instant
	    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
	    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
	    return type;
	  }
	} // $FlowFixMe only called in DEV, so void return is not possible.


	function willCoercionThrow(value) {
	  {
	    try {
	      testStringCoercion(value);
	      return false;
	    } catch (e) {
	      return true;
	    }
	  }
	}

	function testStringCoercion(value) {
	  // If you ended up here by following an exception call stack, here's what's
	  // happened: you supplied an object or symbol value to React (as a prop, key,
	  // DOM attribute, CSS property, string ref, etc.) and when React tried to
	  // coerce it to a string using `'' + value`, an exception was thrown.
	  //
	  // The most common types that will cause this exception are `Symbol` instances
	  // and Temporal objects like `Temporal.Instant`. But any object that has a
	  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
	  // exception. (Library authors do this to prevent users from using built-in
	  // numeric operators like `+` or comparison operators like `>=` because custom
	  // methods are needed to perform accurate arithmetic or comparison.)
	  //
	  // To fix the problem, coerce this object or symbol value to a string before
	  // passing it to React. The most reliable way is usually `String(value)`.
	  //
	  // To find which value is throwing, check the browser or debugger console.
	  // Before this exception was thrown, there should be `console.error` output
	  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
	  // problem and how that type was used: key, atrribute, input value prop, etc.
	  // In most cases, this console output also shows the component and its
	  // ancestor components where the exception happened.
	  //
	  // eslint-disable-next-line react-internal/safe-string-coercion
	  return '' + value;
	}
	function checkKeyStringCoercion(value) {
	  {
	    if (willCoercionThrow(value)) {
	      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

	      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
	    }
	  }
	}

	var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	var specialPropKeyWarningShown;
	var specialPropRefWarningShown;
	var didWarnAboutStringRefs;

	{
	  didWarnAboutStringRefs = {};
	}

	function hasValidRef(config) {
	  {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }

	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }

	  return config.key !== undefined;
	}

	function warnIfStringRefCannotBeAutoConverted(config, self) {
	  {
	    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
	      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

	      if (!didWarnAboutStringRefs[componentName]) {
	        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

	        didWarnAboutStringRefs[componentName] = true;
	      }
	    }
	  }
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  {
	    var warnAboutAccessingKey = function () {
	      if (!specialPropKeyWarningShown) {
	        specialPropKeyWarningShown = true;

	        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
	      }
	    };

	    warnAboutAccessingKey.isReactWarning = true;
	    Object.defineProperty(props, 'key', {
	      get: warnAboutAccessingKey,
	      configurable: true
	    });
	  }
	}

	function defineRefPropWarningGetter(props, displayName) {
	  {
	    var warnAboutAccessingRef = function () {
	      if (!specialPropRefWarningShown) {
	        specialPropRefWarningShown = true;

	        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
	      }
	    };

	    warnAboutAccessingRef.isReactWarning = true;
	    Object.defineProperty(props, 'ref', {
	      get: warnAboutAccessingRef,
	      configurable: true
	    });
	  }
	}
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, instanceof check
	 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} props
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} owner
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @internal
	 */


	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allows us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.

	    Object.defineProperty(element._store, 'validated', {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: false
	    }); // self and source are DEV only properties.

	    Object.defineProperty(element, '_self', {
	      configurable: false,
	      enumerable: false,
	      writable: false,
	      value: self
	    }); // Two elements created in two different places should be considered
	    // equal for testing purposes and therefore we hide it from enumeration.

	    Object.defineProperty(element, '_source', {
	      configurable: false,
	      enumerable: false,
	      writable: false,
	      value: source
	    });

	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};
	/**
	 * https://github.com/reactjs/rfcs/pull/107
	 * @param {*} type
	 * @param {object} props
	 * @param {string} key
	 */

	function jsxDEV(type, config, maybeKey, source, self) {
	  {
	    var propName; // Reserved names are extracted

	    var props = {};
	    var key = null;
	    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
	    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
	    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
	    // but as an intermediary step, we will use jsxDEV for everything except
	    // <div {...props} key="Hi" />, because we aren't currently able to tell if
	    // key is explicitly declared to be undefined or not.

	    if (maybeKey !== undefined) {
	      {
	        checkKeyStringCoercion(maybeKey);
	      }

	      key = '' + maybeKey;
	    }

	    if (hasValidKey(config)) {
	      {
	        checkKeyStringCoercion(config.key);
	      }

	      key = '' + config.key;
	    }

	    if (hasValidRef(config)) {
	      ref = config.ref;
	      warnIfStringRefCannotBeAutoConverted(config, self);
	    } // Remaining properties are added to a new props object


	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    } // Resolve default props


	    if (type && type.defaultProps) {
	      var defaultProps = type.defaultProps;

	      for (propName in defaultProps) {
	        if (props[propName] === undefined) {
	          props[propName] = defaultProps[propName];
	        }
	      }
	    }

	    if (key || ref) {
	      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

	      if (key) {
	        defineKeyPropWarningGetter(props, displayName);
	      }

	      if (ref) {
	        defineRefPropWarningGetter(props, displayName);
	      }
	    }

	    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	  }
	}

	var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
	var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

	function setCurrentlyValidatingElement$1(element) {
	  {
	    if (element) {
	      var owner = element._owner;
	      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
	    } else {
	      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
	    }
	  }
	}

	var propTypesMisspellWarningShown;

	{
	  propTypesMisspellWarningShown = false;
	}
	/**
	 * Verifies the object is a ReactElement.
	 * See https://reactjs.org/docs/react-api.html#isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a ReactElement.
	 * @final
	 */


	function isValidElement(object) {
	  {
	    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	  }
	}

	function getDeclarationErrorAddendum() {
	  {
	    if (ReactCurrentOwner$1.current) {
	      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

	      if (name) {
	        return '\n\nCheck the render method of `' + name + '`.';
	      }
	    }

	    return '';
	  }
	}

	function getSourceInfoErrorAddendum(source) {
	  {
	    if (source !== undefined) {
	      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
	      var lineNumber = source.lineNumber;
	      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
	    }

	    return '';
	  }
	}
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */


	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  {
	    var info = getDeclarationErrorAddendum();

	    if (!info) {
	      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

	      if (parentName) {
	        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
	      }
	    }

	    return info;
	  }
	}
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */


	function validateExplicitKey(element, parentType) {
	  {
	    if (!element._store || element._store.validated || element.key != null) {
	      return;
	    }

	    element._store.validated = true;
	    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

	    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
	      return;
	    }

	    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
	    // property, it may be the creator of the child that's responsible for
	    // assigning it a key.

	    var childOwner = '';

	    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
	      // Give the component that originally created this child.
	      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
	    }

	    setCurrentlyValidatingElement$1(element);

	    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

	    setCurrentlyValidatingElement$1(null);
	  }
	}
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */


	function validateChildKeys(node, parentType) {
	  {
	    if (typeof node !== 'object') {
	      return;
	    }

	    if (isArray(node)) {
	      for (var i = 0; i < node.length; i++) {
	        var child = node[i];

	        if (isValidElement(child)) {
	          validateExplicitKey(child, parentType);
	        }
	      }
	    } else if (isValidElement(node)) {
	      // This element was passed in a valid location.
	      if (node._store) {
	        node._store.validated = true;
	      }
	    } else if (node) {
	      var iteratorFn = getIteratorFn(node);

	      if (typeof iteratorFn === 'function') {
	        // Entry iterators used to provide implicit keys,
	        // but now we print a separate warning for them later.
	        if (iteratorFn !== node.entries) {
	          var iterator = iteratorFn.call(node);
	          var step;

	          while (!(step = iterator.next()).done) {
	            if (isValidElement(step.value)) {
	              validateExplicitKey(step.value, parentType);
	            }
	          }
	        }
	      }
	    }
	  }
	}
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */


	function validatePropTypes(element) {
	  {
	    var type = element.type;

	    if (type === null || type === undefined || typeof type === 'string') {
	      return;
	    }

	    var propTypes;

	    if (typeof type === 'function') {
	      propTypes = type.propTypes;
	    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
	    // Inner props are checked in the reconciler.
	    type.$$typeof === REACT_MEMO_TYPE)) {
	      propTypes = type.propTypes;
	    } else {
	      return;
	    }

	    if (propTypes) {
	      // Intentionally inside to avoid triggering lazy initializers:
	      var name = getComponentNameFromType(type);
	      checkPropTypes(propTypes, element.props, 'prop', name, element);
	    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
	      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

	      var _name = getComponentNameFromType(type);

	      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
	    }

	    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
	      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
	    }
	  }
	}
	/**
	 * Given a fragment, validate that it can only be provided with fragment props
	 * @param {ReactElement} fragment
	 */


	function validateFragmentProps(fragment) {
	  {
	    var keys = Object.keys(fragment.props);

	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];

	      if (key !== 'children' && key !== 'key') {
	        setCurrentlyValidatingElement$1(fragment);

	        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

	        setCurrentlyValidatingElement$1(null);
	        break;
	      }
	    }

	    if (fragment.ref !== null) {
	      setCurrentlyValidatingElement$1(fragment);

	      error('Invalid attribute `ref` supplied to `React.Fragment`.');

	      setCurrentlyValidatingElement$1(null);
	    }
	  }
	}

	function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
	  {
	    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.

	    if (!validType) {
	      var info = '';

	      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
	      }

	      var sourceInfo = getSourceInfoErrorAddendum(source);

	      if (sourceInfo) {
	        info += sourceInfo;
	      } else {
	        info += getDeclarationErrorAddendum();
	      }

	      var typeString;

	      if (type === null) {
	        typeString = 'null';
	      } else if (isArray(type)) {
	        typeString = 'array';
	      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
	        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
	        info = ' Did you accidentally export a JSX literal instead of a component?';
	      } else {
	        typeString = typeof type;
	      }

	      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
	    }

	    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.

	    if (element == null) {
	      return element;
	    } // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)


	    if (validType) {
	      var children = props.children;

	      if (children !== undefined) {
	        if (isStaticChildren) {
	          if (isArray(children)) {
	            for (var i = 0; i < children.length; i++) {
	              validateChildKeys(children[i], type);
	            }

	            if (Object.freeze) {
	              Object.freeze(children);
	            }
	          } else {
	            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
	          }
	        } else {
	          validateChildKeys(children, type);
	        }
	      }
	    }

	    if (type === REACT_FRAGMENT_TYPE) {
	      validateFragmentProps(element);
	    } else {
	      validatePropTypes(element);
	    }

	    return element;
	  }
	} // These two functions exist to still get child warnings in dev
	// even with the prod transform. This means that jsxDEV is purely
	// opt-in behavior for better messages but that we won't stop
	// giving you warnings if you use production apis.

	function jsxWithValidationStatic(type, props, key) {
	  {
	    return jsxWithValidation(type, props, key, true);
	  }
	}
	function jsxWithValidationDynamic(type, props, key) {
	  {
	    return jsxWithValidation(type, props, key, false);
	  }
	}

	var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
	// for now we can ship identical prod functions

	var jsxs =  jsxWithValidationStatic ;

	reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
	reactJsxRuntime_development.jsx = jsx;
	reactJsxRuntime_development.jsxs = jsxs;
	  })();
	}
	return reactJsxRuntime_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactJsxRuntime_production_min();
	} else {
	  module.exports = requireReactJsxRuntime_development();
	}
} (jsxRuntime));

var shim = {exports: {}};

var useSyncExternalStoreShim_production_min = {};

/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_production_min;

function requireUseSyncExternalStoreShim_production_min () {
	if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;
	hasRequiredUseSyncExternalStoreShim_production_min = 1;
var e=React;function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k="function"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c});},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c});})},[a]);p(d);return d}
	function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k(a,d)}catch(f){return !0}}function t(a,b){return b()}var u="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t:q;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;
	return useSyncExternalStoreShim_production_min;
}

var useSyncExternalStoreShim_development = {};

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_development;

function requireUseSyncExternalStoreShim_development () {
	if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
	hasRequiredUseSyncExternalStoreShim_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	if (
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
	    'function'
	) {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
	}
	          var React$1 = React;

	var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

	function error(format) {
	  {
	    {
	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      printWarning('error', format, args);
	    }
	  }
	}

	function printWarning(level, format, args) {
	  // When changing this logic, you might want to also
	  // update consoleWithStackDev.www.js as well.
	  {
	    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	    var stack = ReactDebugCurrentFrame.getStackAddendum();

	    if (stack !== '') {
	      format += '%s';
	      args = args.concat([stack]);
	    } // eslint-disable-next-line react-internal/safe-string-coercion


	    var argsWithFormat = args.map(function (item) {
	      return String(item);
	    }); // Careful: RN currently depends on this prefix

	    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
	    // breaks IE9: https://github.com/facebook/react/issues/13610
	    // eslint-disable-next-line react-internal/no-production-logging

	    Function.prototype.apply.call(console[level], console, argsWithFormat);
	  }
	}

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
	  ;
	}

	var objectIs = typeof Object.is === 'function' ? Object.is : is;

	// dispatch for CommonJS interop named imports.

	var useState = React$1.useState,
	    useEffect = React$1.useEffect,
	    useLayoutEffect = React$1.useLayoutEffect,
	    useDebugValue = React$1.useDebugValue;
	var didWarnOld18Alpha = false;
	var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
	// because of a very particular set of implementation details and assumptions
	// -- change any one of them and it will break. The most important assumption
	// is that updates are always synchronous, because concurrent rendering is
	// only available in versions of React that also have a built-in
	// useSyncExternalStore API. And we only use this shim when the built-in API
	// does not exist.
	//
	// Do not assume that the clever hacks used by this hook also work in general.
	// The point of this shim is to replace the need for hacks by other libraries.

	function useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
	// React do not expose a way to check if we're hydrating. So users of the shim
	// will need to track that themselves and return the correct value
	// from `getSnapshot`.
	getServerSnapshot) {
	  {
	    if (!didWarnOld18Alpha) {
	      if (React$1.startTransition !== undefined) {
	        didWarnOld18Alpha = true;

	        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');
	      }
	    }
	  } // Read the current snapshot from the store on every render. Again, this
	  // breaks the rules of React, and only works here because of specific
	  // implementation details, most importantly that updates are
	  // always synchronous.


	  var value = getSnapshot();

	  {
	    if (!didWarnUncachedGetSnapshot) {
	      var cachedValue = getSnapshot();

	      if (!objectIs(value, cachedValue)) {
	        error('The result of getSnapshot should be cached to avoid an infinite loop');

	        didWarnUncachedGetSnapshot = true;
	      }
	    }
	  } // Because updates are synchronous, we don't queue them. Instead we force a
	  // re-render whenever the subscribed state changes by updating an some
	  // arbitrary useState hook. Then, during render, we call getSnapshot to read
	  // the current value.
	  //
	  // Because we don't actually use the state returned by the useState hook, we
	  // can save a bit of memory by storing other stuff in that slot.
	  //
	  // To implement the early bailout, we need to track some things on a mutable
	  // object. Usually, we would put that in a useRef hook, but we can stash it in
	  // our useState hook instead.
	  //
	  // To force a re-render, we call forceUpdate({inst}). That works because the
	  // new object always fails an equality check.


	  var _useState = useState({
	    inst: {
	      value: value,
	      getSnapshot: getSnapshot
	    }
	  }),
	      inst = _useState[0].inst,
	      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated
	  // in the layout phase so we can access it during the tearing check that
	  // happens on subscribe.


	  useLayoutEffect(function () {
	    inst.value = value;
	    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
	    // commit phase if there was an interleaved mutation. In concurrent mode
	    // this can happen all the time, but even in synchronous mode, an earlier
	    // effect may have mutated the store.

	    if (checkIfSnapshotChanged(inst)) {
	      // Force a re-render.
	      forceUpdate({
	        inst: inst
	      });
	    }
	  }, [subscribe, value, getSnapshot]);
	  useEffect(function () {
	    // Check for changes right before subscribing. Subsequent changes will be
	    // detected in the subscription handler.
	    if (checkIfSnapshotChanged(inst)) {
	      // Force a re-render.
	      forceUpdate({
	        inst: inst
	      });
	    }

	    var handleStoreChange = function () {
	      // TODO: Because there is no cross-renderer API for batching updates, it's
	      // up to the consumer of this library to wrap their subscription event
	      // with unstable_batchedUpdates. Should we try to detect when this isn't
	      // the case and print a warning in development?
	      // The store changed. Check if the snapshot changed since the last time we
	      // read from the store.
	      if (checkIfSnapshotChanged(inst)) {
	        // Force a re-render.
	        forceUpdate({
	          inst: inst
	        });
	      }
	    }; // Subscribe to the store and return a clean-up function.


	    return subscribe(handleStoreChange);
	  }, [subscribe]);
	  useDebugValue(value);
	  return value;
	}

	function checkIfSnapshotChanged(inst) {
	  var latestGetSnapshot = inst.getSnapshot;
	  var prevValue = inst.value;

	  try {
	    var nextValue = latestGetSnapshot();
	    return !objectIs(prevValue, nextValue);
	  } catch (error) {
	    return true;
	  }
	}

	function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
	  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
	  // React do not expose a way to check if we're hydrating. So users of the shim
	  // will need to track that themselves and return the correct value
	  // from `getSnapshot`.
	  return getSnapshot();
	}

	var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

	var isServerEnvironment = !canUseDOM;

	var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
	var useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;

	useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
	          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	if (
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
	    'function'
	) {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
	}
	        
	  })();
	}
	return useSyncExternalStoreShim_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireUseSyncExternalStoreShim_production_min();
	} else {
	  module.exports = requireUseSyncExternalStoreShim_development();
	}
} (shim));

var withSelector = {exports: {}};

var withSelector_production_min = {};

/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredWithSelector_production_min;

function requireWithSelector_production_min () {
	if (hasRequiredWithSelector_production_min) return withSelector_production_min;
	hasRequiredWithSelector_production_min = 1;
var h=React,n=shim.exports;function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q="function"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;
	withSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);
	u(function(){f.hasValue=!0;f.value=d;},[d]);w(d);return d};
	return withSelector_production_min;
}

var withSelector_development = {};

/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredWithSelector_development;

function requireWithSelector_development () {
	if (hasRequiredWithSelector_development) return withSelector_development;
	hasRequiredWithSelector_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	if (
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
	    'function'
	) {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
	}
	          var React$1 = React;
	var shim$1 = shim.exports;

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
	  ;
	}

	var objectIs = typeof Object.is === 'function' ? Object.is : is;

	var useSyncExternalStore = shim$1.useSyncExternalStore;

	// for CommonJS interop.

	var useRef = React$1.useRef,
	    useEffect = React$1.useEffect,
	    useMemo = React$1.useMemo,
	    useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.

	function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
	  // Use this to track the rendered snapshot.
	  var instRef = useRef(null);
	  var inst;

	  if (instRef.current === null) {
	    inst = {
	      hasValue: false,
	      value: null
	    };
	    instRef.current = inst;
	  } else {
	    inst = instRef.current;
	  }

	  var _useMemo = useMemo(function () {
	    // Track the memoized state using closure variables that are local to this
	    // memoized instance of a getSnapshot function. Intentionally not using a
	    // useRef hook, because that state would be shared across all concurrent
	    // copies of the hook/component.
	    var hasMemo = false;
	    var memoizedSnapshot;
	    var memoizedSelection;

	    var memoizedSelector = function (nextSnapshot) {
	      if (!hasMemo) {
	        // The first time the hook is called, there is no memoized result.
	        hasMemo = true;
	        memoizedSnapshot = nextSnapshot;

	        var _nextSelection = selector(nextSnapshot);

	        if (isEqual !== undefined) {
	          // Even if the selector has changed, the currently rendered selection
	          // may be equal to the new selection. We should attempt to reuse the
	          // current value if possible, to preserve downstream memoizations.
	          if (inst.hasValue) {
	            var currentSelection = inst.value;

	            if (isEqual(currentSelection, _nextSelection)) {
	              memoizedSelection = currentSelection;
	              return currentSelection;
	            }
	          }
	        }

	        memoizedSelection = _nextSelection;
	        return _nextSelection;
	      } // We may be able to reuse the previous invocation's result.


	      // We may be able to reuse the previous invocation's result.
	      var prevSnapshot = memoizedSnapshot;
	      var prevSelection = memoizedSelection;

	      if (objectIs(prevSnapshot, nextSnapshot)) {
	        // The snapshot is the same as last time. Reuse the previous selection.
	        return prevSelection;
	      } // The snapshot has changed, so we need to compute a new selection.


	      // The snapshot has changed, so we need to compute a new selection.
	      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data
	      // has changed. If it hasn't, return the previous selection. That signals
	      // to React that the selections are conceptually equal, and we can bail
	      // out of rendering.

	      // If a custom isEqual function is provided, use that to check if the data
	      // has changed. If it hasn't, return the previous selection. That signals
	      // to React that the selections are conceptually equal, and we can bail
	      // out of rendering.
	      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {
	        return prevSelection;
	      }

	      memoizedSnapshot = nextSnapshot;
	      memoizedSelection = nextSelection;
	      return nextSelection;
	    }; // Assigning this to a constant so that Flow knows it can't change.


	    // Assigning this to a constant so that Flow knows it can't change.
	    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;

	    var getSnapshotWithSelector = function () {
	      return memoizedSelector(getSnapshot());
	    };

	    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {
	      return memoizedSelector(maybeGetServerSnapshot());
	    };
	    return [getSnapshotWithSelector, getServerSnapshotWithSelector];
	  }, [getSnapshot, getServerSnapshot, selector, isEqual]),
	      getSelection = _useMemo[0],
	      getServerSelection = _useMemo[1];

	  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
	  useEffect(function () {
	    inst.hasValue = true;
	    inst.value = value;
	  }, [value]);
	  useDebugValue(value);
	  return value;
	}

	withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
	          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	if (
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
	    'function'
	) {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
	}
	        
	  })();
	}
	return withSelector_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireWithSelector_production_min();
	} else {
	  module.exports = requireWithSelector_development();
	}
} (withSelector));

// Default to a dummy "batch" implementation that just runs the callback
function defaultNoopBatch(callback) {
  callback();
}

let batch = defaultNoopBatch; // Allow injecting another batching function later

const setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings

const getBatch = () => batch;

const ReactReduxContext = /*#__PURE__*/React.createContext(null);

if (process.env.NODE_ENV !== 'production') {
  ReactReduxContext.displayName = 'ReactRedux';
}

/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */
function useReduxContext() {
  const contextValue = useContext(ReactReduxContext);

  if (process.env.NODE_ENV !== 'production' && !contextValue) {
    throw new Error('could not find react-redux context value; please ensure the component is wrapped in a <Provider>');
  }

  return contextValue;
}

const notInitialized = () => {
  throw new Error('uSES not initialized!');
};

let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = fn => {
  useSyncExternalStoreWithSelector = fn;
};

const refEquality = (a, b) => a === b;
/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */


function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : () => useContext(context);
  return function useSelector(selector, equalityFn = refEquality) {
    if (process.env.NODE_ENV !== 'production') {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }

      if (typeof selector !== 'function') {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }

      if (typeof equalityFn !== 'function') {
        throw new Error(`You must pass a function as an equality function to useSelector`);
      }
    }

    const {
      store,
      subscription,
      getServerState
    } = useReduxContext$1();
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, selector, equalityFn);
    useDebugValue(selectedState);
    return selectedState;
  };
}
/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */

const useSelector = /*#__PURE__*/createSelectorHook();

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var reactIs$2 = {exports: {}};

var reactIs_production_min$1 = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min$1;

function requireReactIs_production_min$1 () {
	if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
	hasRequiredReactIs_production_min$1 = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min$1.AsyncMode=l;reactIs_production_min$1.ConcurrentMode=m;reactIs_production_min$1.ContextConsumer=k;reactIs_production_min$1.ContextProvider=h;reactIs_production_min$1.Element=c;reactIs_production_min$1.ForwardRef=n;reactIs_production_min$1.Fragment=e;reactIs_production_min$1.Lazy=t;reactIs_production_min$1.Memo=r;reactIs_production_min$1.Portal=d;
	reactIs_production_min$1.Profiler=g;reactIs_production_min$1.StrictMode=f;reactIs_production_min$1.Suspense=p;reactIs_production_min$1.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min$1.isConcurrentMode=A;reactIs_production_min$1.isContextConsumer=function(a){return z(a)===k};reactIs_production_min$1.isContextProvider=function(a){return z(a)===h};reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min$1.isForwardRef=function(a){return z(a)===n};reactIs_production_min$1.isFragment=function(a){return z(a)===e};reactIs_production_min$1.isLazy=function(a){return z(a)===t};
	reactIs_production_min$1.isMemo=function(a){return z(a)===r};reactIs_production_min$1.isPortal=function(a){return z(a)===d};reactIs_production_min$1.isProfiler=function(a){return z(a)===g};reactIs_production_min$1.isStrictMode=function(a){return z(a)===f};reactIs_production_min$1.isSuspense=function(a){return z(a)===p};
	reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min$1.typeOf=z;
	return reactIs_production_min$1;
}

var reactIs_development$1 = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$1;

function requireReactIs_development$1 () {
	if (hasRequiredReactIs_development$1) return reactIs_development$1;
	hasRequiredReactIs_development$1 = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development$1.AsyncMode = AsyncMode;
	reactIs_development$1.ConcurrentMode = ConcurrentMode;
	reactIs_development$1.ContextConsumer = ContextConsumer;
	reactIs_development$1.ContextProvider = ContextProvider;
	reactIs_development$1.Element = Element;
	reactIs_development$1.ForwardRef = ForwardRef;
	reactIs_development$1.Fragment = Fragment;
	reactIs_development$1.Lazy = Lazy;
	reactIs_development$1.Memo = Memo;
	reactIs_development$1.Portal = Portal;
	reactIs_development$1.Profiler = Profiler;
	reactIs_development$1.StrictMode = StrictMode;
	reactIs_development$1.Suspense = Suspense;
	reactIs_development$1.isAsyncMode = isAsyncMode;
	reactIs_development$1.isConcurrentMode = isConcurrentMode;
	reactIs_development$1.isContextConsumer = isContextConsumer;
	reactIs_development$1.isContextProvider = isContextProvider;
	reactIs_development$1.isElement = isElement;
	reactIs_development$1.isForwardRef = isForwardRef;
	reactIs_development$1.isFragment = isFragment;
	reactIs_development$1.isLazy = isLazy;
	reactIs_development$1.isMemo = isMemo;
	reactIs_development$1.isPortal = isPortal;
	reactIs_development$1.isProfiler = isProfiler;
	reactIs_development$1.isStrictMode = isStrictMode;
	reactIs_development$1.isSuspense = isSuspense;
	reactIs_development$1.isValidElementType = isValidElementType;
	reactIs_development$1.typeOf = typeOf;
	  })();
	}
	return reactIs_development$1;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min$1();
	} else {
	  module.exports = requireReactIs_development$1();
	}
} (reactIs$2));

var reactIs$1 = reactIs$2.exports;
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;

var reactIs = {exports: {}};

var reactIs_production_min = {};

/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
	function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;
	reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return !1};reactIs_production_min.isConcurrentMode=function(){return !1};reactIs_production_min.isContextConsumer=function(a){return v(a)===h};reactIs_production_min.isContextProvider=function(a){return v(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return v(a)===l};reactIs_production_min.isFragment=function(a){return v(a)===d};reactIs_production_min.isLazy=function(a){return v(a)===q};reactIs_production_min.isMemo=function(a){return v(a)===p};
	reactIs_production_min.isPortal=function(a){return v(a)===c};reactIs_production_min.isProfiler=function(a){return v(a)===f};reactIs_production_min.isStrictMode=function(a){return v(a)===e};reactIs_production_min.isSuspense=function(a){return v(a)===m};reactIs_production_min.isSuspenseList=function(a){return v(a)===n};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};reactIs_production_min.typeOf=v;
	return reactIs_production_min;
}

var reactIs_development = {};

/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// -----------------------------------------------------------------------------

	var enableScopeAPI = false; // Experimental Create Event Handle API.
	var enableCacheElement = false;
	var enableTransitionTracing = false; // No known bugs, but needs performance testing

	var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
	// stuff. Intended to enable React core members to more easily debug scheduling
	// issues in DEV builds.

	var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

	// ATTENTION

	var REACT_ELEMENT_TYPE =  Symbol.for('react.element');
	var REACT_PORTAL_TYPE =  Symbol.for('react.portal');
	var REACT_FRAGMENT_TYPE =  Symbol.for('react.fragment');
	var REACT_STRICT_MODE_TYPE =  Symbol.for('react.strict_mode');
	var REACT_PROFILER_TYPE =  Symbol.for('react.profiler');
	var REACT_PROVIDER_TYPE =  Symbol.for('react.provider');
	var REACT_CONTEXT_TYPE =  Symbol.for('react.context');
	var REACT_SERVER_CONTEXT_TYPE =  Symbol.for('react.server_context');
	var REACT_FORWARD_REF_TYPE =  Symbol.for('react.forward_ref');
	var REACT_SUSPENSE_TYPE =  Symbol.for('react.suspense');
	var REACT_SUSPENSE_LIST_TYPE =  Symbol.for('react.suspense_list');
	var REACT_MEMO_TYPE =  Symbol.for('react.memo');
	var REACT_LAZY_TYPE =  Symbol.for('react.lazy');
	var REACT_OFFSCREEN_TYPE =  Symbol.for('react.offscreen');

	var REACT_MODULE_REFERENCE;

	{
	  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
	}

	function isValidElementType(type) {
	  if (typeof type === 'string' || typeof type === 'function') {
	    return true;
	  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


	  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
	    return true;
	  }

	  if (typeof type === 'object' && type !== null) {
	    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
	    // types supported by any Flight configuration anywhere since
	    // we don't know which Flight build this will end up being used
	    // with.
	    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
	      return true;
	    }
	  }

	  return false;
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	          case REACT_SUSPENSE_LIST_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_SERVER_CONTEXT_TYPE:
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	}
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false;
	var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	    }
	  }

	  return false;
	}
	function isConcurrentMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
	      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	    }
	  }

	  return false;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}
	function isSuspenseList(object) {
	  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
	}

	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.SuspenseList = SuspenseList;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isSuspenseList = isSuspenseList;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min();
	} else {
	  module.exports = requireReactIs_development();
	}
} (reactIs));

// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

function createListenerCollection() {
  const batch = getBatch();
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },

    notify() {
      batch(() => {
        let listener = first;

        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },

    get() {
      let listeners = [];
      let listener = first;

      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }

      return listeners;
    },

    subscribe(callback) {
      let isSubscribed = true;
      let listener = last = {
        callback,
        next: null,
        prev: last
      };

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }

        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }

  };
}

const nullListeners = {
  notify() {},

  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;

  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }

  function notifyNestedSubs() {
    listeners.notify();
  }

  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }

  function isSubscribed() {
    return Boolean(unsubscribe);
  }

  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }

  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = undefined;
      listeners.clear();
      listeners = nullListeners;
    }
  }

  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: () => listeners
  };
  return subscription;
}

// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed
// Matches logic in React's `shared/ExecutionEnvironment` file

const canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
const useIsomorphicLayoutEffect = canUseDOM ? useLayoutEffect : useEffect;

function Provider$1({
  store,
  context,
  children,
  serverState
}) {
  const contextValue = useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : undefined
    };
  }, [store, serverState]);
  const previousState = useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }

    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = undefined;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype

  return /*#__PURE__*/React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}

/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */

function createStoreHook(context = ReactReduxContext) {
  const useReduxContext$1 = // @ts-ignore
  context === ReactReduxContext ? useReduxContext : () => useContext(context);
  return function useStore() {
    const {
      store
    } = useReduxContext$1(); // @ts-ignore

    return store;
  };
}
/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */

const useStore = /*#__PURE__*/createStoreHook();

/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */

function createDispatchHook(context = ReactReduxContext) {
  const useStore$1 = // @ts-ignore
  context === ReactReduxContext ? useStore : createStoreHook(context);
  return function useDispatch() {
    const store = useStore$1(); // @ts-ignore

    return store.dispatch;
  };
}
/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */

const useDispatch = /*#__PURE__*/createDispatchHook();

// The primary entry point assumes we're working with standard ReactDOM/RN, but
initializeUseSelector(withSelector.exports.useSyncExternalStoreWithSelector);
// with standard React renderers (ReactDOM, React Native)

setBatch(unstable_batchedUpdates);

function n$1(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if("production"!==process.env.NODE_ENV){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return "'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r$2(n){return !!n&&!!n[Q]}function t$1(n){return !!n&&(function(n){if(!n||"object"!=typeof n)return !1;var r=Object.getPrototypeOf(n);if(null===r)return !0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s$1(n)||v(n))}function i(n,r,t){void 0===t&&(t=!1),0===o$1(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n);})):n.forEach((function(t,e){return r(e,t,n)}));}function o$1(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s$1(n)?2:v(n)?3:0}function u(n,r){return 2===o$1(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o$1(n)?n.get(r):n[r]}function f$1(n,r,t){var e=o$1(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t;}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s$1(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]});}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r$2(n)||!t$1(n)?n:(o$1(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n$1(2);}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n$1(18,r),t}function m(n,r){tn[n]||(tn[n]=r);}function _(){return "production"===process.env.NODE_ENV||U||n$1(0),U}function j(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r);}function O(n){g(n),n.p.forEach(S),n.p=null;}function g(n){n===U&&(U=n.l);}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0;}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O(e),n$1(4)),t$1(r)&&(r=M(e,r),e.l||x$1(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x$1(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x$1(n,o,!1),t&&n.u&&b("Patches").R(e,t,n.u,n.s);}return e.o}function A(e,i,o,a,c,s){if("production"!==process.env.NODE_ENV&&c===o&&n$1(5),r$2(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f$1(o,a,v),!r$2(v))return;e.m=!1;}if(t$1(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x$1(e,c);}}function x$1(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t);}function z$1(n,r){var t=n[Q];return (t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t);}}function k(n){n.P||(n.P=!0,n.l&&k(n.l));}function E(n){n.o||(n.o=l(n.t));}function R(n,r,t){var e=s$1(r)?b("MapSet").N(r,t):v(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return (t?t.A:_()).p.push(e),e}function D(e){return r$2(e)||n$1(22,e),function n(r){if(!t$1(r))return r;var e,u=r[Q],c=o$1(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1;}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f$1(e,r,n(t));})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N$1(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return "production"!==process.env.NODE_ENV&&f(r),en.get(r,n)},set:function(r){var t=this[Q];"production"!==process.env.NODE_ENV&&f(t),en.set(t,n,r);}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t);}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return !0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return !0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return !0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return !0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return !0;return !1}function f(r){r.O&&n$1(3,JSON.stringify(p(r)));}var s={};m("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable);}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r$2(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)));})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t));}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l]);}}}}(n.p[0]),e(n.p));},K:function(n){return 4===n.i?o(n):a(n)}});}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return "Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return "Unsupported patch operation: "+n},18:function(n){return "The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return "'current' expects a draft, got: "+n},23:function(n){return "'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t);})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t$1(i)?i:i===z$1(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z$1(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return !0;E(n),k(n);}return n.o[r]===t&&"number"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z$1(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n$1(11);},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n$1(12);}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)};})),on.deleteProperty=function(r,t){return "production"!==process.env.NODE_ENV&&isNaN(parseInt(t))&&n$1(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return "production"!==process.env.NODE_ENV&&"length"!==t&&isNaN(parseInt(t))&&n$1(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return (t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n$1(6),void 0!==o&&"function"!=typeof o&&n$1(7),t$1(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1;}finally{v?O(c):g(c);}return "undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l);}return f}n$1(21,r);},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r;}));return "undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return [n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze);}var i=e.prototype;return i.createDraft=function(e){t$1(e)||n$1(8),r$2(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q];"production"!==process.env.NODE_ENV&&(e&&e.C||n$1(9),e.I&&n$1(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n;},i.setUseProxies=function(r){r&&!B&&n$1(20),this.g=r;},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r$2(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce;an.produceWithPatches.bind(an);an.setAutoFreeze.bind(an);an.setUseProxies.bind(an);an.applyPatches.bind(an);an.createDraft.bind(an);an.finishDraft.bind(an);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject$1(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (process.env.NODE_ENV !== 'production') {
    typeOfVal = miniKindOf(val);
  }

  return typeOfVal;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }

    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject$1(action)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }

    if (typeof action.type === 'undefined') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }

    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning$1(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject$1(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(12) : "The slice reducer for key \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(13) : "The slice reducer for key \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle '" + ActionTypes.INIT + "' or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning$1("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning$1(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(14) : "When called with an action of type " + (actionType ? "\"" + String(actionType) + "\"" : '(unknown type)') + ", the slice reducer for key \"" + _key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.");
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(15) : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning$1('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

/** A function that accepts a potential "extra argument" value to be injected later,
 * and returns an instance of the thunk middleware that uses that value
 */
function createThunkMiddleware(extraArgument) {
  // Standard Redux middleware definition pattern:
  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
  var middleware = function middleware(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        // The thunk middleware looks for any functions that were passed to `store.dispatch`.
        // If this "action" is really a function, call it and return the result.
        if (typeof action === 'function') {
          // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
          return action(dispatch, getState, extraArgument);
        } // Otherwise, pass the action down the middleware chain as usual


        return next(action);
      };
    };
  };

  return middleware;
}

var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
// with whatever "extra arg" they want to inject into their thunks

thunk.withExtraArgument = createThunkMiddleware;

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function (obj, key, value) { return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value }) : obj[key] = value; };
var __spreadValues = function (a, b) {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {
            var prop = _c[_i];
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
    if (arguments.length === 0)
        return void 0;
    if (typeof arguments[0] === "object")
        return compose;
    return compose.apply(null, arguments);
};
// src/isPlainObject.ts
function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
        return false;
    var proto = Object.getPrototypeOf(value);
    if (proto === null)
        return true;
    var baseProto = proto;
    while (Object.getPrototypeOf(baseProto) !== null) {
        baseProto = Object.getPrototypeOf(baseProto);
    }
    return proto === baseProto;
}
// src/utils.ts
function getTimeMeasureUtils(maxDelay, fnName) {
    var elapsed = 0;
    return {
        measureTime: function (fn) {
            var started = Date.now();
            try {
                return fn();
            }
            finally {
                var finished = Date.now();
                elapsed += finished - started;
            }
        },
        warnIfExceeded: function () {
            if (elapsed > maxDelay) {
                console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
            }
        }
    };
}
var MiddlewareArray = /** @class */ (function (_super) {
    __extends(MiddlewareArray, _super);
    function MiddlewareArray() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        Object.setPrototypeOf(_this, MiddlewareArray.prototype);
        return _this;
    }
    Object.defineProperty(MiddlewareArray, Symbol.species, {
        get: function () {
            return MiddlewareArray;
        },
        enumerable: false,
        configurable: true
    });
    MiddlewareArray.prototype.concat = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray.prototype.prepend = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();
        }
        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();
    };
    return MiddlewareArray;
}(Array));
// src/immutableStateInvariantMiddleware.ts
var isProduction$2 = process.env.NODE_ENV === "production";
var prefix$1 = "Invariant failed";
function invariant$1(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction$2) {
        throw new Error(prefix$1);
    }
    throw new Error(prefix$1 + ": " + (message || ""));
}
function stringify(obj, serializer, indent, decycler) {
    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}
function getSerialize(serializer, decycler) {
    var stack = [], keys = [];
    if (!decycler)
        decycler = function (_, value) {
            if (stack[0] === value)
                return "[Circular ~]";
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
    return function (key, value) {
        if (stack.length > 0) {
            var thisPos = stack.indexOf(this);
            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
            if (~stack.indexOf(value))
                value = decycler.call(this, key, value);
        }
        else
            stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
    };
}
function isImmutableDefault(value) {
    return typeof value !== "object" || value === null || typeof value === "undefined" || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
        detectMutations: function () {
            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
        }
    };
}
function trackProperties(isImmutable, ignorePaths, obj, path) {
    if (ignorePaths === void 0) { ignorePaths = []; }
    if (path === void 0) { path = ""; }
    var tracked = { value: obj };
    if (!isImmutable(obj)) {
        tracked.children = {};
        for (var key in obj) {
            var childPath = path ? path + "." + key : key;
            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
                continue;
            }
            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
        }
    }
    return tracked;
}
function detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
    if (ignorePaths === void 0) { ignorePaths = []; }
    if (sameParentRef === void 0) { sameParentRef = false; }
    if (path === void 0) { path = ""; }
    var prevObj = trackedProperty ? trackedProperty.value : void 0;
    var sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
        return { wasMutated: true, path: path };
    }
    if (isImmutable(prevObj) || isImmutable(obj)) {
        return { wasMutated: false };
    }
    var keysToDetect = {};
    for (var key in trackedProperty.children) {
        keysToDetect[key] = true;
    }
    for (var key in obj) {
        keysToDetect[key] = true;
    }
    for (var key in keysToDetect) {
        var childPath = path ? path + "." + key : key;
        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
            continue;
        }
        var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);
        if (result.wasMutated) {
            return result;
        }
    }
    return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options) {
    if (options === void 0) { options = {}; }
    if (process.env.NODE_ENV === "production") {
        return function () { return function (next) { return function (action) { return next(action); }; }; };
    }
    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;
    ignoredPaths = ignoredPaths || ignore;
    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return function (_c) {
        var getState = _c.getState;
        var state = getState();
        var tracker = track(state);
        var result;
        return function (next) { return function (action) {
            var measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
            measureUtils.measureTime(function () {
                state = getState();
                result = tracker.detectMutations();
                tracker = track(state);
                invariant$1(!result.wasMutated, "A state mutation was detected between dispatches, in the path '" + (result.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            var dispatchedAction = next(action);
            measureUtils.measureTime(function () {
                state = getState();
                result = tracker.detectMutations();
                tracker = track(state);
                result.wasMutated && invariant$1(!result.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (result.path || "") + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            measureUtils.warnIfExceeded();
            return dispatchedAction;
        }; };
    };
}
// src/serializableStateInvariantMiddleware.ts
function isPlain(val) {
    var type = typeof val;
    return type === "undefined" || val === null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
    if (path === void 0) { path = ""; }
    if (isSerializable === void 0) { isSerializable = isPlain; }
    if (ignoredPaths === void 0) { ignoredPaths = []; }
    var foundNestedSerializable;
    if (!isSerializable(value)) {
        return {
            keyPath: path || "<root>",
            value: value
        };
    }
    if (typeof value !== "object" || value === null) {
        return false;
    }
    var entries = getEntries != null ? getEntries(value) : Object.entries(value);
    var hasIgnoredPaths = ignoredPaths.length > 0;
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];
        var nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {
            continue;
        }
        if (!isSerializable(nestedValue)) {
            return {
                keyPath: nestedPath,
                value: nestedValue
            };
        }
        if (typeof nestedValue === "object") {
            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);
            if (foundNestedSerializable) {
                return foundNestedSerializable;
            }
        }
    }
    return false;
}
function createSerializableStateInvariantMiddleware(options) {
    if (options === void 0) { options = {}; }
    if (process.env.NODE_ENV === "production") {
        return function () { return function (next) { return function (action) { return next(action); }; }; };
    }
    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j;
    return function (storeAPI) { return function (next) { return function (action) {
        var result = next(action);
        var measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
            measureUtils.measureTime(function () {
                var foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths);
                if (foundActionNonSerializableValue) {
                    var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;
                    console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
                }
            });
        }
        if (!ignoreState) {
            measureUtils.measureTime(function () {
                var state = storeAPI.getState();
                var foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths);
                if (foundStateNonSerializableValue) {
                    var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;
                    console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
                }
            });
            measureUtils.warnIfExceeded();
        }
        return result;
    }; }; };
}
// src/getDefaultMiddleware.ts
function isBoolean(x) {
    return typeof x === "boolean";
}
function curryGetDefaultMiddleware() {
    return function curriedGetDefaultMiddleware(options) {
        return getDefaultMiddleware(options);
    };
}
function getDefaultMiddleware(options) {
    if (options === void 0) { options = {}; }
    var _c = options.thunk, thunk$1 = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;
    var middlewareArray = new MiddlewareArray();
    if (thunk$1) {
        if (isBoolean(thunk$1)) {
            middlewareArray.push(thunk);
        }
        else {
            middlewareArray.push(thunk.withExtraArgument(thunk$1.extraArgument));
        }
    }
    if (process.env.NODE_ENV !== "production") {
        if (immutableCheck) {
            var immutableOptions = {};
            if (!isBoolean(immutableCheck)) {
                immutableOptions = immutableCheck;
            }
            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
        }
        if (serializableCheck) {
            var serializableOptions = {};
            if (!isBoolean(serializableCheck)) {
                serializableOptions = serializableCheck;
            }
            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
        }
    }
    return middlewareArray;
}
// src/configureStore.ts
var IS_PRODUCTION = process.env.NODE_ENV === "production";
function configureStore(options) {
    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
    var rootReducer;
    if (typeof reducer === "function") {
        rootReducer = reducer;
    }
    else if (isPlainObject(reducer)) {
        rootReducer = combineReducers(reducer);
    }
    else {
        throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
    }
    var finalMiddleware = middleware;
    if (typeof finalMiddleware === "function") {
        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
            throw new Error("when using a middleware builder function, an array of middleware must be returned");
        }
    }
    if (!IS_PRODUCTION && finalMiddleware.some(function (item) { return typeof item !== "function"; })) {
        throw new Error("each middleware provided to configureStore must be a function");
    }
    var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
    var finalCompose = compose;
    if (devTools) {
        finalCompose = composeWithDevTools(__spreadValues({
            trace: !IS_PRODUCTION
        }, typeof devTools === "object" && devTools));
    }
    var storeEnhancers = [middlewareEnhancer];
    if (Array.isArray(enhancers)) {
        storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
    }
    else if (typeof enhancers === "function") {
        storeEnhancers = enhancers(storeEnhancers);
    }
    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
    return createStore(rootReducer, preloadedState, composedEnhancer);
}
// src/createAction.ts
function createAction(type, prepareAction) {
    function actionCreator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (prepareAction) {
            var prepared = prepareAction.apply(void 0, args);
            if (!prepared) {
                throw new Error("prepareAction did not return an object");
            }
            return __spreadValues(__spreadValues({
                type: type,
                payload: prepared.payload
            }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
        }
        return { type: type, payload: args[0] };
    }
    actionCreator.toString = function () { return "" + type; };
    actionCreator.type = type;
    actionCreator.match = function (action) { return action.type === type; };
    return actionCreator;
}
// src/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
    var actionsMap = {};
    var actionMatchers = [];
    var defaultCaseReducer;
    var builder = {
        addCase: function (typeOrActionCreator, reducer) {
            if (process.env.NODE_ENV !== "production") {
                if (actionMatchers.length > 0) {
                    throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
                }
                if (defaultCaseReducer) {
                    throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
                }
            }
            var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (type in actionsMap) {
                throw new Error("addCase cannot be called with two reducers for the same action type");
            }
            actionsMap[type] = reducer;
            return builder;
        },
        addMatcher: function (matcher, reducer) {
            if (process.env.NODE_ENV !== "production") {
                if (defaultCaseReducer) {
                    throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
                }
            }
            actionMatchers.push({ matcher: matcher, reducer: reducer });
            return builder;
        },
        addDefaultCase: function (reducer) {
            if (process.env.NODE_ENV !== "production") {
                if (defaultCaseReducer) {
                    throw new Error("`builder.addDefaultCase` can only be called once");
                }
            }
            defaultCaseReducer = reducer;
            return builder;
        }
    };
    builderCallback(builder);
    return [actionsMap, actionMatchers, defaultCaseReducer];
}
// src/createReducer.ts
function isStateFunction(x) {
    return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
    if (actionMatchers === void 0) { actionMatchers = []; }
    var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
    var getInitialState;
    if (isStateFunction(initialState)) {
        getInitialState = function () { return fn(initialState(), function () {
        }); };
    }
    else {
        var frozenInitialState_1 = fn(initialState, function () {
        });
        getInitialState = function () { return frozenInitialState_1; };
    }
    function reducer(state, action) {
        if (state === void 0) { state = getInitialState(); }
        var caseReducers = __spreadArray([
            actionsMap[action.type]
        ], finalActionMatchers.filter(function (_c) {
            var matcher = _c.matcher;
            return matcher(action);
        }).map(function (_c) {
            var reducer2 = _c.reducer;
            return reducer2;
        }));
        if (caseReducers.filter(function (cr) { return !!cr; }).length === 0) {
            caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce(function (previousState, caseReducer) {
            if (caseReducer) {
                if (r$2(previousState)) {
                    var draft = previousState;
                    var result = caseReducer(draft, action);
                    if (typeof result === "undefined") {
                        return previousState;
                    }
                    return result;
                }
                else if (!t$1(previousState)) {
                    var result = caseReducer(previousState, action);
                    if (typeof result === "undefined") {
                        if (previousState === null) {
                            return previousState;
                        }
                        throw Error("A case reducer on a non-draftable value must not return undefined");
                    }
                    return result;
                }
                else {
                    return fn(previousState, function (draft) {
                        return caseReducer(draft, action);
                    });
                }
            }
            return previousState;
        }, state);
    }
    reducer.getInitialState = getInitialState;
    return reducer;
}
// src/createSlice.ts
function getType2(slice, actionKey) {
    return slice + "/" + actionKey;
}
function createSlice(options) {
    var name = options.name;
    if (!name) {
        throw new Error("`name` is a required option for createSlice");
    }
    var initialState = typeof options.initialState == "function" ? options.initialState : fn(options.initialState, function () {
    });
    var reducers = options.reducers || {};
    var reducerNames = Object.keys(reducers);
    var sliceCaseReducersByName = {};
    var sliceCaseReducersByType = {};
    var actionCreators = {};
    reducerNames.forEach(function (reducerName) {
        var maybeReducerWithPrepare = reducers[reducerName];
        var type = getType2(name, reducerName);
        var caseReducer;
        var prepareCallback;
        if ("reducer" in maybeReducerWithPrepare) {
            caseReducer = maybeReducerWithPrepare.reducer;
            prepareCallback = maybeReducerWithPrepare.prepare;
        }
        else {
            caseReducer = maybeReducerWithPrepare;
        }
        sliceCaseReducersByName[reducerName] = caseReducer;
        sliceCaseReducersByType[type] = caseReducer;
        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
    });
    function buildReducer() {
        var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
        return createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
    }
    var _reducer;
    return {
        name: name,
        reducer: function (state, action) {
            if (!_reducer)
                _reducer = buildReducer();
            return _reducer(state, action);
        },
        actions: actionCreators,
        caseReducers: sliceCaseReducersByName,
        getInitialState: function () {
            if (!_reducer)
                _reducer = buildReducer();
            return _reducer.getInitialState();
        }
    };
}
var alm = "listenerMiddleware";
createAction(alm + "/add");
createAction(alm + "/removeAll");
createAction(alm + "/remove");
// src/index.ts
N$1();

function e(e){this.message=e;}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r$1="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw "Illegal base64url string!"}try{return function(e){return decodeURIComponent(r$1(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return r$1(t)}}function n(e){this.message=e;}function o(e,r){if("string"!=typeof e)throw new n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(".")[o]))}catch(e){throw new n("Invalid token specified: "+e.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";

var _a$8;
var generateInitialState$8 = function () { return ({
    jwt: '',
    account: '',
    customerId: '',
}); };
var authSlice = createSlice({
    name: 'auth-slice',
    initialState: generateInitialState$8(),
    reducers: {
        setAuth: function (state, action) {
            var decoded = o(action.payload);
            state.jwt = action.payload;
            state.account = decoded.identity.wallet_address;
        },
        reset: function (state) {
            state = generateInitialState$8();
            return state;
        },
        setCustomerId: function (state, action) {
            state.customerId = action.payload;
        },
    },
});
var setAuth = (_a$8 = authSlice.actions, _a$8.setAuth), reset$8 = _a$8.reset, setCustomerId = _a$8.setCustomerId;
var authReducer = authSlice.reducer;

var _a$7;
var KYCFieldType;
(function (KYCFieldType) {
    KYCFieldType["ADDRESS_LINE_1"] = "address1";
    KYCFieldType["ADDRESS_LINE_2"] = "address2";
    KYCFieldType["FIRST_NAME"] = "firstName";
    KYCFieldType["LAST_NAME"] = "lastName";
    KYCFieldType["CITY"] = "city";
    KYCFieldType["PROVINCE"] = "province";
    KYCFieldType["ZIP"] = "zip";
    KYCFieldType["COUNTRY"] = "country";
})(KYCFieldType || (KYCFieldType = {}));
var generateInitialState$7 = function () { return ({
    formFieldTypes: [],
    formValues: {
        address1: '',
        address2: '',
        city: '',
        zip: '',
        province: '',
        firstName: '',
        lastName: '',
    },
    formErrors: {
        address1: '',
        address2: '',
        city: '',
        zip: '',
        province: '',
        firstName: '',
        lastName: '',
    },
    submitting: false,
    submittedSuccessfully: false,
}); };
var slice$4 = createSlice({
    name: 'KYCFormSlice',
    initialState: generateInitialState$7(),
    reducers: {
        updateKYCFormFieldTypes: function (state, action) {
            state.formFieldTypes = action.payload;
        },
        updateKYCFormValue: function (state, action) {
            state.formValues[action.payload.type] = action.payload.value;
        },
        multiUpdateKYCForm: function (state, action) {
            state.formValues.address1 = action.payload.address1;
            state.formValues.address2 = action.payload.address2;
            state.formValues.city = action.payload.city;
            state.formValues.zip = action.payload.zip;
            state.formValues.province = action.payload.province;
            state.formValues.firstName = action.payload.firstName;
            state.formValues.lastName = action.payload.lastName;
        },
        clearCountry: function (state) {
            state.formValues.province = '';
            state.formValues.zip = '';
            state.formValues.city = '';
            state.formValues.address1 = '';
            state.formValues.address2 = '';
        },
        submittedSuccessfully: function (state) {
            state.submittedSuccessfully = true;
            state.submitting = false;
        },
        submittingFailed: function (state) {
            state.submittedSuccessfully = false;
            state.submitting = false;
        },
        submitting: function (state) {
            state.submitting = true;
            state.formErrors = {
                address1: '',
                address2: '',
                city: '',
                zip: '',
                province: '',
                firstName: '',
                lastName: '',
            };
        },
        clearKYCFormSlice: function (state) {
            state.submitting = false;
            state.submittedSuccessfully = false;
            state.formValues = {
                address1: '',
                address2: '',
                city: '',
                zip: '',
                province: '',
                firstName: '',
                lastName: '',
            };
        },
        setKYCFormError: function (state, action) {
            state.formErrors[action.payload.type] = action.payload.value;
        },
        reset: function (state) {
            state = generateInitialState$7();
            return state;
        },
    },
});
var updateKYCFormFieldTypes = (_a$7 = slice$4.actions, _a$7.updateKYCFormFieldTypes), updateKYCFormValue = _a$7.updateKYCFormValue; _a$7.multiUpdateKYCForm; var clearCountry = _a$7.clearCountry, submittedSuccessfully = _a$7.submittedSuccessfully, submitting = _a$7.submitting; _a$7.clearKYCFormSlice; var submittingFailed = _a$7.submittingFailed, setKYCFormError = _a$7.setKYCFormError, reset$7 = _a$7.reset;
var kycFormReducer = slice$4.reducer;

var _a$6;
var generateInitialState$6 = function () { return ({
    debug: false,
}); };
var settingsSlice = createSlice({
    name: 'settings-slice',
    initialState: generateInitialState$6(),
    reducers: {
        setDebug: function (state, action) {
            state.debug = action.payload;
        },
        reset: function (state) {
            state = generateInitialState$6();
            return state;
        },
    },
});
var setDebug = (_a$6 = settingsSlice.actions, _a$6.setDebug), reset$6 = _a$6.reset;
var settingsReducer = settingsSlice.reducer;

var _a$5;
var Page$1;
(function (Page) {
    Page["INTRO"] = "INTRO";
    Page["TOS"] = "TOS";
    Page["SIGN_WALLET"] = "SIGN_WALLET";
    Page["VERIFF"] = "VERIFF";
    Page["VERIFF_STATUS"] = "VERIFF_STATUS";
    Page["KYC_FORM"] = "KYC_FORM";
    Page["MINT_NFT"] = "MINT_NFT";
    Page["MINT_NFT_STATUS"] = "MINT_NFT_STATUS";
    Page["MINT_NFT_COMPLETE"] = "MINT_NFT_COMPLETE";
})(Page$1 || (Page$1 = {}));
var PageError;
(function (PageError) {
    PageError["AUTH_ERROR"] = "AUTH_ERROR";
    PageError["VERIFF_ERROR"] = "VERIFF_ERROR";
    PageError["KYC_ERROR"] = "KYC_ERROR";
})(PageError || (PageError = {}));
var generateInitialState$5 = function () { return ({
    page: Page$1.INTRO,
    error: false,
}); };
var navigationSlice = createSlice({
    name: 'navigation-slice',
    initialState: generateInitialState$5(),
    reducers: {
        setPage: function (state, action) {
            if (state.page !== action.payload) {
                state.page = action.payload;
                state.error = action.payload in PageError;
            }
        },
        reset: function (state) {
            state = generateInitialState$5();
            return state;
        },
    },
});
var setPage = (_a$5 = navigationSlice.actions, _a$5.setPage), reset$5 = _a$5.reset;
var navigationReducer = navigationSlice.reducer;

var _a$4;
var generateInitialState$4 = function () { return ({
    currentCountry: {},
    allCountries: [],
}); };
var slice$3 = createSlice({
    name: 'LocalizationSlice',
    initialState: generateInitialState$4(),
    reducers: {
        updateCurrentCountry: function (state, action) {
            state.currentCountry = action.payload;
        },
        fetchAllCountries: function (state, action) {
            state.allCountries = action.payload;
        },
        reset: function (state) {
            state = generateInitialState$4();
            return state;
        },
    },
});
var updateCurrentCountry = (_a$4 = slice$3.actions, _a$4.updateCurrentCountry), fetchAllCountries = _a$4.fetchAllCountries, reset$4 = _a$4.reset;
var localizationReducer = slice$3.reducer;

var IDVerificationStatus;
(function (IDVerificationStatus) {
    IDVerificationStatus["PENDING"] = "PENDING";
    IDVerificationStatus["PASS"] = "PASS";
    IDVerificationStatus["FAIL"] = "FAIL";
})(IDVerificationStatus || (IDVerificationStatus = {}));
var getKycStatus = function (customerId, backendUrl) { return __awaiter$g(void 0, void 0, void 0, function () {
    var url, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                url = "".concat(backendUrl, "/kyc?customerId=").concat(customerId);
                return [4 /*yield*/, fetch(url, {
                        method: 'GET',
                        headers: {
                            Authorization: "Bearer ".concat(store.getState().auth.jwt),
                        },
                    })];
            case 1:
                response = _a.sent();
                return [2 /*return*/, response.json()];
        }
    });
}); };

var _a$3;
var AMLVerificationStatus;
(function (AMLVerificationStatus) {
    AMLVerificationStatus["PENDING"] = "PENDING";
    AMLVerificationStatus["LOW_RISK"] = "LOW_RISK";
    AMLVerificationStatus["MEDIUM_RISK"] = "MEDIUM_RISK";
    AMLVerificationStatus["HIGH_RISK"] = "HIGH_RISK";
    AMLVerificationStatus["REVIEW_REQUIRED"] = "REVIEW_REQUIRED";
})(AMLVerificationStatus || (AMLVerificationStatus = {}));
var generateInitialState$3 = function () { return ({
    amlVerificationStatus: AMLVerificationStatus.PENDING,
    idVerificationStatus: IDVerificationStatus.PENDING,
    blockChainMineComplete: false,
}); };
var slice$2 = createSlice({
    name: 'PollingStatusSlice',
    initialState: generateInitialState$3(),
    reducers: {
        updateIdVerificationStatus: function (state, action) {
            state.idVerificationStatus = action.payload;
        },
        updateAmlVerificationStatus: function (state, action) {
            state.amlVerificationStatus = action.payload;
        },
        blockChainMineSetComplete: function (state) {
            state.blockChainMineComplete = true;
        },
        clearKYCPollingStatus: function (state) {
            state.amlVerificationStatus = AMLVerificationStatus.PENDING;
            state.blockChainMineComplete = false;
        },
        clearIdPollingStatus: function (state) {
            state.idVerificationStatus = IDVerificationStatus.PENDING;
        },
        clearPollingStatusSlice: function (state) {
            state.amlVerificationStatus = AMLVerificationStatus.PENDING;
            state.blockChainMineComplete = false;
            state.idVerificationStatus = IDVerificationStatus.PENDING;
        },
        reset: function (state) {
            state = generateInitialState$3();
            return state;
        },
    },
});
var updateIdVerificationStatus = (_a$3 = slice$2.actions, _a$3.updateIdVerificationStatus); _a$3.updateAmlVerificationStatus; _a$3.blockChainMineSetComplete; _a$3.clearKYCPollingStatus; var clearIdPollingStatus = _a$3.clearIdPollingStatus; _a$3.clearPollingStatusSlice; var reset$3 = _a$3.reset;
var veriffStatusReducer = slice$2.reducer;

var _a$2;
var generateInitialState$2 = function () { return ({
    id: '',
    url: '',
    vendorData: '',
    host: '',
    status: '',
    sessionToken: '',
}); };
var veriffSessionSlice = createSlice({
    name: 'veriff-session',
    initialState: generateInitialState$2(),
    reducers: {
        updateVeriffSession: function (state, action) {
            state.id = action.payload.id;
            state.url = action.payload.url;
            state.vendorData = action.payload.vendorData;
            state.host = action.payload.host;
            state.status = action.payload.status;
            state.sessionToken = action.payload.sessionToken;
        },
        clearVeriffSessionSlice: function (state) {
            state.id = '';
            state.url = '';
            state.vendorData = '';
            state.host = '';
            state.status = '';
            state.sessionToken = '';
        },
        reset: function (state) {
            state = generateInitialState$2();
            return state;
        },
    },
});
var updateVeriffSession = (_a$2 = veriffSessionSlice.actions, _a$2.updateVeriffSession); _a$2.clearVeriffSessionSlice; var reset$2 = _a$2.reset;
var veriffSessionReducer = veriffSessionSlice.reducer;

var _a$1;
var VeriffStatus;
(function (VeriffStatus) {
    VeriffStatus[VeriffStatus["PENDING"] = 0] = "PENDING";
    VeriffStatus[VeriffStatus["STARTED"] = 1] = "STARTED";
    VeriffStatus[VeriffStatus["CANCELED"] = 2] = "CANCELED";
    VeriffStatus[VeriffStatus["FINISHED"] = 3] = "FINISHED";
})(VeriffStatus || (VeriffStatus = {}));
var generateInitialState$1 = function () { return ({
    status: VeriffStatus.PENDING,
    veriffFrame: null,
}); };
var slice$1 = createSlice({
    name: 'VeriffResponseSlice',
    initialState: generateInitialState$1(),
    reducers: {
        updateVeriffStatus: function (state, action) {
            state.status = action.payload;
        },
        clearVeriffStatus: function (state) {
            state.status = VeriffStatus.PENDING;
        },
        setVeriffFrame: function (state, action) {
            state.veriffFrame = action.payload;
        },
        reset: function (state) {
            state = generateInitialState$1();
            return state;
        },
    },
});
var updateVeriffStatus = (_a$1 = slice$1.actions, _a$1.updateVeriffStatus); _a$1.clearVeriffStatus; var setVeriffFrame = _a$1.setVeriffFrame, reset$1 = _a$1.reset;
var veriffResponseReducer = slice$1.reducer;

var _a;
var generateInitialState = function () { return ({
    governanceAddress: '',
    contractAddress: '',
    country: '',
    aml: '',
    did: '',
    signature: '',
    issuedAt: 0,
    tokenId: 0,
    txHash: '',
    isBusiness: false,
}); };
var slice = createSlice({
    name: 'EthereumContractSlice',
    initialState: generateInitialState(),
    reducers: {
        setEthereumContract: function (state, action) {
            state.governanceAddress = action.payload.governanceAddress;
            state.contractAddress = action.payload.contractAddress;
            state.country = action.payload.country;
            state.aml = action.payload.aml;
            state.did = action.payload.did;
            state.signature = action.payload.signature;
            state.issuedAt = action.payload.issuedAt;
            state.tokenId = action.payload.tokenId;
            state.isBusiness = !!action.payload.isBusiness;
        },
        clearEthereumContract: function (state) {
            state.contractAddress = '';
            state.country = '';
            state.aml = '';
            state.did = '';
            state.signature = '';
            state.issuedAt = 0;
            state.tokenId = 0;
            state.txHash = '';
            state.isBusiness = false;
        },
        setTxHash: function (state, action) {
            state.txHash = action.payload;
        },
        reset: function (state) {
            state = generateInitialState();
            return state;
        },
    },
});
var setEthereumContract = (_a = slice.actions, _a.setEthereumContract); _a.clearEthereumContract; var setTxHash = _a.setTxHash, reset = _a.reset;
var ethereumContractReducer = slice.reducer;

var store = configureStore({
    reducer: {
        auth: authReducer,
        kycForm: kycFormReducer,
        settings: settingsReducer,
        navigation: navigationReducer,
        localization: localizationReducer,
        pollingStatus: veriffStatusReducer,
        veriffSession: veriffSessionReducer,
        veriffResponse: veriffResponseReducer,
        ethereumContract: ethereumContractReducer,
    },
});
// Use throughout your app instead of plain `useDispatch` and `useSelector`
var useAppDispatch = function () { return useDispatch(); };
var useAppSelector = useSelector;

var Navigator = function (_a) {
    var page = _a.page, children = _a.children;
    var currentPage = useAppSelector(function (state) { return state.navigation; }).page;
    return currentPage === page ? jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children }) : jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {});
};

var useSettings = function () {
    var dispatch = useAppDispatch();
    var debug = useAppSelector(function (state) { return state.settings; }).debug;
    var setDebugMode = useCallback(function (debug) {
        dispatch(setDebug(debug));
    }, [dispatch]);
    var resetSettings = useCallback(function () {
        dispatch(reset$6());
    }, [dispatch]);
    return useMemo(function () {
        return {
            debug: debug,
            setDebugMode: setDebugMode,
            resetSettings: resetSettings,
        };
    }, [debug, setDebugMode, resetSettings]);
};

var useNavigation = function () {
    var dispatch = useAppDispatch();
    var page = useAppSelector(function (state) { return state.navigation; }).page;
    var debug = useSettings().debug;
    var navigate = useCallback(function (page) {
        debug && console.log('Navigating to page: ', page);
        dispatch(setPage(page));
    }, [dispatch]);
    var navigateByStatus = useCallback(function (_a) {
        var veriffSession = _a.veriffSession, contractParameters = _a.contractParameters, error = _a.error;
        debug && console.log('Navigating by status: ', veriffSession, contractParameters, error);
        if (error) {
            debug && console.log('Navigation by status error: ', error);
            dispatch(setPage(PageError.KYC_ERROR));
        }
        else if (veriffSession) {
            dispatch(updateVeriffSession({
                id: veriffSession.id,
                url: veriffSession.url,
                vendorData: veriffSession.vendorData,
                host: veriffSession.host,
                status: veriffSession.status,
                sessionToken: veriffSession.sessionToken,
            }));
            dispatch(setPage(Page$1.VERIFF));
        }
        else if (contractParameters) {
            dispatch(setEthereumContract({
                governanceAddress: contractParameters.governanceAddress,
                contractAddress: contractParameters.address,
                country: contractParameters.country,
                aml: contractParameters.aml,
                did: contractParameters.did,
                signature: contractParameters.signature,
                issuedAt: contractParameters.issuedAt,
                tokenId: contractParameters.tokenId,
                isBusiness: contractParameters.isBusiness,
            }));
            dispatch(setPage(Page$1.MINT_NFT));
        }
    }, [dispatch]);
    var resetNavigation = useCallback(function () {
        dispatch(reset$5());
    }, [dispatch]);
    return useMemo(function () {
        return {
            page: page,
            navigate: navigate,
            resetNavigation: resetNavigation,
            navigateByStatus: navigateByStatus,
        };
    }, [page, navigate, resetNavigation, navigateByStatus]);
};

var PageLayout = function (_a) {
    var children = _a.children;
    return jsxRuntime.exports.jsx("div", __assign({ className: "kyc-page" }, { children: children }));
};

// Media
var QUADRATA_MINTED_VIDEO_URL = 'https://quadrata.com/quadrata-passport-web.mp4';
var QUADRATA_MINTED_VIDEO_PLACEHOLDER = 'https://quadrata.com/images/video-placeholder.jpg';

var Passport = function () {
    return (jsxRuntime.exports.jsxs("video", __assign({ loop: true, muted: true, autoPlay: true, playsInline: true, poster: QUADRATA_MINTED_VIDEO_PLACEHOLDER, style: {
            position: 'relative',
            width: '100%',
            left: 0,
            top: 0,
        } }, { children: [jsxRuntime.exports.jsx("source", { src: QUADRATA_MINTED_VIDEO_URL, type: "video/mp4" }), "Your browser does not support the video tag."] })));
};

var PageIntro = function () {
    var navigate = useNavigation().navigate;
    var _a = useState(false), readMore = _a[0], setReadMore = _a[1];
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("h1", { children: "Let\u2019s create your Web3 Identity Passport" }), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx("p", { children: "In order to create your Web3 Identity Passport, we\u2019ll collect information from you to securely confirm your identity so you can claim your digital passport. Your passport will be issued as a non-transferable NFT, which permanently lives on the blockchain and cannot be modified, edited, or deleted." }) }), jsxRuntime.exports.jsx(Passport, {}), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx("button", __assign({ className: "kyc-button kyc-button-toggle", onClick: function () { return setReadMore(!readMore); } }, { children: readMore ? '- Read less' : '+ Read more about KYC' })) }), readMore && (jsxRuntime.exports.jsx("section", __assign({ className: "kyc-read-more" }, { children: jsxRuntime.exports.jsx("p", { children: "Know Your Customer (KYC) requirements are part of the regulations set forth by the US Financial Crimes Enforcement Network (FinCEN) to address performing customer due diligence when doing business. It is meant to facilitate the avoidance of any illicit activities by customers of financial institutions. As part of this process, scanning for anti-money laundering risk or terrorist financing is a necessary component." }) }))), jsxRuntime.exports.jsx("section", __assign({ className: "kyc-buttons kyc-buttons-single" }, { children: jsxRuntime.exports.jsx("button", __assign({ onClick: function () {
                        navigate(Page$1.TOS);
                    }, className: "kyc-button kyc-button-primary" }, { children: "Start Verification" })) }))] }));
};

var getTOSPDFLink = function (backendUrl) { return __awaiter$g(void 0, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fetch("".concat(backendUrl, "/kyc/tos"))];
            case 1:
                response = _a.sent();
                return [2 /*return*/, response.url];
        }
    });
}); };

function commonjsRequire$1(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var pdf = {exports: {}};

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(commonjsGlobal, function() {
	return /******/ (() => { // webpackBootstrap
	/******/ 	var __webpack_modules__ = ([
	/* 0 */,
	/* 1 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.LinkTarget = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;
	exports.addLinkAttributes = addLinkAttributes;
	exports.deprecated = deprecated;
	exports.getFilenameFromUrl = getFilenameFromUrl;
	exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
	exports.getXfaPageViewport = getXfaPageViewport;
	exports.isDataScheme = isDataScheme;
	exports.isPdfFile = isPdfFile;
	exports.isValidFetchUrl = isValidFetchUrl;
	exports.loadScript = loadScript;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	var _base_factory = __w_pdfjs_require__(135);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
	var SVG_NS = "http://www.w3.org/2000/svg";
	var PixelsPerInch = {
	  CSS: 96.0,
	  PDF: 72.0,

	  get PDF_TO_CSS_UNITS() {
	    return (0, _util.shadow)(this, "PDF_TO_CSS_UNITS", this.CSS / this.PDF);
	  }

	};
	exports.PixelsPerInch = PixelsPerInch;

	var DOMCanvasFactory = /*#__PURE__*/function (_BaseCanvasFactory) {
	  _inherits(DOMCanvasFactory, _BaseCanvasFactory);

	  var _super = _createSuper(DOMCanvasFactory);

	  function DOMCanvasFactory() {
	    var _this;

	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref$ownerDocument = _ref.ownerDocument,
	        ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;

	    _classCallCheck(this, DOMCanvasFactory);

	    _this = _super.call(this);
	    _this._document = ownerDocument;
	    return _this;
	  }

	  _createClass(DOMCanvasFactory, [{
	    key: "_createCanvas",
	    value: function _createCanvas(width, height) {
	      var canvas = this._document.createElement("canvas");

	      canvas.width = width;
	      canvas.height = height;
	      return canvas;
	    }
	  }]);

	  return DOMCanvasFactory;
	}(_base_factory.BaseCanvasFactory);

	exports.DOMCanvasFactory = DOMCanvasFactory;

	function fetchData(_x) {
	  return _fetchData.apply(this, arguments);
	}

	function _fetchData() {
	  _fetchData = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
	    var asTypedArray,
	        response,
	        _args = arguments;
	    return _regenerator["default"].wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            asTypedArray = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;

	            if (!isValidFetchUrl(url, document.baseURI)) {
	              _context.next = 21;
	              break;
	            }

	            _context.next = 4;
	            return fetch(url);

	          case 4:
	            response = _context.sent;

	            if (response.ok) {
	              _context.next = 7;
	              break;
	            }

	            throw new Error(response.statusText);

	          case 7:
	            if (!asTypedArray) {
	              _context.next = 15;
	              break;
	            }

	            _context.t1 = Uint8Array;
	            _context.next = 11;
	            return response.arrayBuffer();

	          case 11:
	            _context.t2 = _context.sent;
	            _context.t0 = new _context.t1(_context.t2);
	            _context.next = 20;
	            break;

	          case 15:
	            _context.t3 = _util.stringToBytes;
	            _context.next = 18;
	            return response.text();

	          case 18:
	            _context.t4 = _context.sent;
	            _context.t0 = (0, _context.t3)(_context.t4);

	          case 20:
	            return _context.abrupt("return", _context.t0);

	          case 21:
	            return _context.abrupt("return", new Promise(function (resolve, reject) {
	              var request = new XMLHttpRequest();
	              request.open("GET", url, true);

	              if (asTypedArray) {
	                request.responseType = "arraybuffer";
	              }

	              request.onreadystatechange = function () {
	                if (request.readyState !== XMLHttpRequest.DONE) {
	                  return;
	                }

	                if (request.status === 200 || request.status === 0) {
	                  var data;

	                  if (asTypedArray && request.response) {
	                    data = new Uint8Array(request.response);
	                  } else if (!asTypedArray && request.responseText) {
	                    data = (0, _util.stringToBytes)(request.responseText);
	                  }

	                  if (data) {
	                    resolve(data);
	                    return;
	                  }
	                }

	                reject(new Error(request.statusText));
	              };

	              request.send(null);
	            }));

	          case 22:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));
	  return _fetchData.apply(this, arguments);
	}

	var DOMCMapReaderFactory = /*#__PURE__*/function (_BaseCMapReaderFactor) {
	  _inherits(DOMCMapReaderFactory, _BaseCMapReaderFactor);

	  var _super2 = _createSuper(DOMCMapReaderFactory);

	  function DOMCMapReaderFactory() {
	    _classCallCheck(this, DOMCMapReaderFactory);

	    return _super2.apply(this, arguments);
	  }

	  _createClass(DOMCMapReaderFactory, [{
	    key: "_fetchData",
	    value: function _fetchData(url, compressionType) {
	      return fetchData(url, this.isCompressed).then(function (data) {
	        return {
	          cMapData: data,
	          compressionType: compressionType
	        };
	      });
	    }
	  }]);

	  return DOMCMapReaderFactory;
	}(_base_factory.BaseCMapReaderFactory);

	exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

	var DOMStandardFontDataFactory = /*#__PURE__*/function (_BaseStandardFontData) {
	  _inherits(DOMStandardFontDataFactory, _BaseStandardFontData);

	  var _super3 = _createSuper(DOMStandardFontDataFactory);

	  function DOMStandardFontDataFactory() {
	    _classCallCheck(this, DOMStandardFontDataFactory);

	    return _super3.apply(this, arguments);
	  }

	  _createClass(DOMStandardFontDataFactory, [{
	    key: "_fetchData",
	    value: function _fetchData(url) {
	      return fetchData(url, true);
	    }
	  }]);

	  return DOMStandardFontDataFactory;
	}(_base_factory.BaseStandardFontDataFactory);

	exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;

	var DOMSVGFactory = /*#__PURE__*/function (_BaseSVGFactory) {
	  _inherits(DOMSVGFactory, _BaseSVGFactory);

	  var _super4 = _createSuper(DOMSVGFactory);

	  function DOMSVGFactory() {
	    _classCallCheck(this, DOMSVGFactory);

	    return _super4.apply(this, arguments);
	  }

	  _createClass(DOMSVGFactory, [{
	    key: "_createSVG",
	    value: function _createSVG(type) {
	      return document.createElementNS(SVG_NS, type);
	    }
	  }]);

	  return DOMSVGFactory;
	}(_base_factory.BaseSVGFactory);

	exports.DOMSVGFactory = DOMSVGFactory;

	var PageViewport = /*#__PURE__*/function () {
	  function PageViewport(_ref2) {
	    var viewBox = _ref2.viewBox,
	        scale = _ref2.scale,
	        rotation = _ref2.rotation,
	        _ref2$offsetX = _ref2.offsetX,
	        offsetX = _ref2$offsetX === void 0 ? 0 : _ref2$offsetX,
	        _ref2$offsetY = _ref2.offsetY,
	        offsetY = _ref2$offsetY === void 0 ? 0 : _ref2$offsetY,
	        _ref2$dontFlip = _ref2.dontFlip,
	        dontFlip = _ref2$dontFlip === void 0 ? false : _ref2$dontFlip;

	    _classCallCheck(this, PageViewport);

	    this.viewBox = viewBox;
	    this.scale = scale;
	    this.rotation = rotation;
	    this.offsetX = offsetX;
	    this.offsetY = offsetY;
	    var centerX = (viewBox[2] + viewBox[0]) / 2;
	    var centerY = (viewBox[3] + viewBox[1]) / 2;
	    var rotateA, rotateB, rotateC, rotateD;
	    rotation %= 360;

	    if (rotation < 0) {
	      rotation += 360;
	    }

	    switch (rotation) {
	      case 180:
	        rotateA = -1;
	        rotateB = 0;
	        rotateC = 0;
	        rotateD = 1;
	        break;

	      case 90:
	        rotateA = 0;
	        rotateB = 1;
	        rotateC = 1;
	        rotateD = 0;
	        break;

	      case 270:
	        rotateA = 0;
	        rotateB = -1;
	        rotateC = -1;
	        rotateD = 0;
	        break;

	      case 0:
	        rotateA = 1;
	        rotateB = 0;
	        rotateC = 0;
	        rotateD = -1;
	        break;

	      default:
	        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
	    }

	    if (dontFlip) {
	      rotateC = -rotateC;
	      rotateD = -rotateD;
	    }

	    var offsetCanvasX, offsetCanvasY;
	    var width, height;

	    if (rotateA === 0) {
	      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
	      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
	      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
	      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
	    } else {
	      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
	      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
	      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
	      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
	    }

	    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
	    this.width = width;
	    this.height = height;
	  }

	  _createClass(PageViewport, [{
	    key: "clone",
	    value: function clone() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref3$scale = _ref3.scale,
	          scale = _ref3$scale === void 0 ? this.scale : _ref3$scale,
	          _ref3$rotation = _ref3.rotation,
	          rotation = _ref3$rotation === void 0 ? this.rotation : _ref3$rotation,
	          _ref3$offsetX = _ref3.offsetX,
	          offsetX = _ref3$offsetX === void 0 ? this.offsetX : _ref3$offsetX,
	          _ref3$offsetY = _ref3.offsetY,
	          offsetY = _ref3$offsetY === void 0 ? this.offsetY : _ref3$offsetY,
	          _ref3$dontFlip = _ref3.dontFlip,
	          dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;

	      return new PageViewport({
	        viewBox: this.viewBox.slice(),
	        scale: scale,
	        rotation: rotation,
	        offsetX: offsetX,
	        offsetY: offsetY,
	        dontFlip: dontFlip
	      });
	    }
	  }, {
	    key: "convertToViewportPoint",
	    value: function convertToViewportPoint(x, y) {
	      return _util.Util.applyTransform([x, y], this.transform);
	    }
	  }, {
	    key: "convertToViewportRectangle",
	    value: function convertToViewportRectangle(rect) {
	      var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

	      var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

	      return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
	    }
	  }, {
	    key: "convertToPdfPoint",
	    value: function convertToPdfPoint(x, y) {
	      return _util.Util.applyInverseTransform([x, y], this.transform);
	    }
	  }]);

	  return PageViewport;
	}();

	exports.PageViewport = PageViewport;

	var RenderingCancelledException = /*#__PURE__*/function (_BaseException) {
	  _inherits(RenderingCancelledException, _BaseException);

	  var _super5 = _createSuper(RenderingCancelledException);

	  function RenderingCancelledException(msg, type) {
	    var _this2;

	    _classCallCheck(this, RenderingCancelledException);

	    _this2 = _super5.call(this, msg, "RenderingCancelledException");
	    _this2.type = type;
	    return _this2;
	  }

	  return RenderingCancelledException;
	}(_util.BaseException);

	exports.RenderingCancelledException = RenderingCancelledException;
	var LinkTarget = {
	  NONE: 0,
	  SELF: 1,
	  BLANK: 2,
	  PARENT: 3,
	  TOP: 4
	};
	exports.LinkTarget = LinkTarget;

	function addLinkAttributes(link) {
	  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      url = _ref4.url,
	      target = _ref4.target,
	      rel = _ref4.rel,
	      _ref4$enabled = _ref4.enabled,
	      enabled = _ref4$enabled === void 0 ? true : _ref4$enabled;

	  (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
	  var urlNullRemoved = (0, _util.removeNullCharacters)(url);

	  if (enabled) {
	    link.href = link.title = urlNullRemoved;
	  } else {
	    link.href = "";
	    link.title = "Disabled: ".concat(urlNullRemoved);

	    link.onclick = function () {
	      return false;
	    };
	  }

	  var targetStr = "";

	  switch (target) {
	    case LinkTarget.NONE:
	      break;

	    case LinkTarget.SELF:
	      targetStr = "_self";
	      break;

	    case LinkTarget.BLANK:
	      targetStr = "_blank";
	      break;

	    case LinkTarget.PARENT:
	      targetStr = "_parent";
	      break;

	    case LinkTarget.TOP:
	      targetStr = "_top";
	      break;
	  }

	  link.target = targetStr;
	  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
	}

	function isDataScheme(url) {
	  var ii = url.length;
	  var i = 0;

	  while (i < ii && url[i].trim() === "") {
	    i++;
	  }

	  return url.substring(i, i + 5).toLowerCase() === "data:";
	}

	function isPdfFile(filename) {
	  return typeof filename === "string" && /\.pdf$/i.test(filename);
	}

	function getFilenameFromUrl(url) {
	  var anchor = url.indexOf("#");
	  var query = url.indexOf("?");
	  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
	  return url.substring(url.lastIndexOf("/", end) + 1, end);
	}

	function getPdfFilenameFromUrl(url) {
	  var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf";

	  if (typeof url !== "string") {
	    return defaultFilename;
	  }

	  if (isDataScheme(url)) {
	    (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
	    return defaultFilename;
	  }

	  var reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
	  var reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
	  var splitURI = reURI.exec(url);
	  var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

	  if (suggestedFilename) {
	    suggestedFilename = suggestedFilename[0];

	    if (suggestedFilename.includes("%")) {
	      try {
	        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
	      } catch (ex) {}
	    }
	  }

	  return suggestedFilename || defaultFilename;
	}

	var StatTimer = /*#__PURE__*/function () {
	  function StatTimer() {
	    _classCallCheck(this, StatTimer);

	    this.started = Object.create(null);
	    this.times = [];
	  }

	  _createClass(StatTimer, [{
	    key: "time",
	    value: function time(name) {
	      if (name in this.started) {
	        (0, _util.warn)("Timer is already running for ".concat(name));
	      }

	      this.started[name] = Date.now();
	    }
	  }, {
	    key: "timeEnd",
	    value: function timeEnd(name) {
	      if (!(name in this.started)) {
	        (0, _util.warn)("Timer has not been started for ".concat(name));
	      }

	      this.times.push({
	        name: name,
	        start: this.started[name],
	        end: Date.now()
	      });
	      delete this.started[name];
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var outBuf = [];
	      var longest = 0;

	      var _iterator = _createForOfIteratorHelper(this.times),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var time = _step.value;
	          var name = time.name;

	          if (name.length > longest) {
	            longest = name.length;
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      var _iterator2 = _createForOfIteratorHelper(this.times),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _time = _step2.value;
	          var duration = _time.end - _time.start;
	          outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n"));
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      return outBuf.join("");
	    }
	  }]);

	  return StatTimer;
	}();

	exports.StatTimer = StatTimer;

	function isValidFetchUrl(url, baseUrl) {
	  try {
	    var _ref5 = baseUrl ? new URL(url, baseUrl) : new URL(url),
	        protocol = _ref5.protocol;

	    return protocol === "http:" || protocol === "https:";
	  } catch (ex) {
	    return false;
	  }
	}

	function loadScript(src) {
	  var removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  return new Promise(function (resolve, reject) {
	    var script = document.createElement("script");
	    script.src = src;

	    script.onload = function (evt) {
	      if (removeScriptElement) {
	        script.remove();
	      }

	      resolve(evt);
	    };

	    script.onerror = function () {
	      reject(new Error("Cannot load script at: ".concat(script.src)));
	    };

	    (document.head || document.documentElement).appendChild(script);
	  });
	}

	function deprecated(details) {
	  console.log("Deprecated API usage: " + details);
	}

	var pdfDateStringRegex;

	var PDFDateString = /*#__PURE__*/function () {
	  function PDFDateString() {
	    _classCallCheck(this, PDFDateString);
	  }

	  _createClass(PDFDateString, null, [{
	    key: "toDateObject",
	    value: function toDateObject(input) {
	      if (!input || !(0, _util.isString)(input)) {
	        return null;
	      }

	      if (!pdfDateStringRegex) {
	        pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
	      }

	      var matches = pdfDateStringRegex.exec(input);

	      if (!matches) {
	        return null;
	      }

	      var year = parseInt(matches[1], 10);
	      var month = parseInt(matches[2], 10);
	      month = month >= 1 && month <= 12 ? month - 1 : 0;
	      var day = parseInt(matches[3], 10);
	      day = day >= 1 && day <= 31 ? day : 1;
	      var hour = parseInt(matches[4], 10);
	      hour = hour >= 0 && hour <= 23 ? hour : 0;
	      var minute = parseInt(matches[5], 10);
	      minute = minute >= 0 && minute <= 59 ? minute : 0;
	      var second = parseInt(matches[6], 10);
	      second = second >= 0 && second <= 59 ? second : 0;
	      var universalTimeRelation = matches[7] || "Z";
	      var offsetHour = parseInt(matches[8], 10);
	      offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
	      var offsetMinute = parseInt(matches[9], 10) || 0;
	      offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

	      if (universalTimeRelation === "-") {
	        hour += offsetHour;
	        minute += offsetMinute;
	      } else if (universalTimeRelation === "+") {
	        hour -= offsetHour;
	        minute -= offsetMinute;
	      }

	      return new Date(Date.UTC(year, month, day, hour, minute, second));
	    }
	  }]);

	  return PDFDateString;
	}();

	exports.PDFDateString = PDFDateString;

	function getXfaPageViewport(xfaPage, _ref6) {
	  var _ref6$scale = _ref6.scale,
	      scale = _ref6$scale === void 0 ? 1 : _ref6$scale,
	      _ref6$rotation = _ref6.rotation,
	      rotation = _ref6$rotation === void 0 ? 0 : _ref6$rotation;
	  var _xfaPage$attributes$s = xfaPage.attributes.style,
	      width = _xfaPage$attributes$s.width,
	      height = _xfaPage$attributes$s.height;
	  var viewBox = [0, 0, parseInt(width), parseInt(height)];
	  return new PageViewport({
	    viewBox: viewBox,
	    scale: scale,
	    rotation: rotation
	  });
	}

	/***/ }),
	/* 2 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {


	module.exports = __w_pdfjs_require__(3);

	/***/ }),
	/* 3 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {
	/* module decorator */ module = __w_pdfjs_require__.nmd(module);


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var runtime = function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1;
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }

	  try {
	    define({}, "");
	  } catch (err) {
	    define = function define(obj, key, value) {
	      return obj[key] = value;
	    };
	  }

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	    return generator;
	  }

	  exports.wrap = wrap;

	  function tryCatch(fn, obj, arg) {
	    try {
	      return {
	        type: "normal",
	        arg: fn.call(obj, arg)
	      };
	    } catch (err) {
	      return {
	        type: "throw",
	        arg: err
	      };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	  var ContinueSentinel = {};

	  function Generator() {}

	  function GeneratorFunction() {}

	  function GeneratorFunctionPrototype() {}

	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

	  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
	  define(Gp, "constructor", GeneratorFunctionPrototype);
	  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
	  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      define(prototype, method, function (arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }

	  exports.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };

	  exports.mark = function (genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }

	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  exports.awrap = function (arg) {
	    return {
	      __await: arg
	    };
	  };

	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);

	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;

	        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function (value) {
	            invoke("next", value, resolve, reject);
	          }, function (err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return PromiseImpl.resolve(value).then(function (unwrapped) {
	          result.value = unwrapped;
	          resolve(result);
	        }, function (error) {
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function (resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	    }

	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  });
	  exports.AsyncIterator = AsyncIterator;

	  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
	    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;

	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);

	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          context.sent = context._sent = context.arg;
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;
	        var record = tryCatch(innerFn, self, context);

	        if (record.type === "normal") {
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];

	    if (method === undefined$1) {
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator["return"]) {
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError("The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (!info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      context[delegate.resultName] = info.value;
	      context.next = delegate.nextLoc;

	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }
	    } else {
	      return info;
	    }

	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  defineIteratorMethods(Gp);
	  define(Gp, toStringTagSymbol, "Generator");
	  define(Gp, iteratorSymbol, function () {
	    return this;
	  });
	  define(Gp, "toString", function () {
	    return "[object Generator]";
	  });

	  function pushTryEntry(locs) {
	    var entry = {
	      tryLoc: locs[0]
	    };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function (object) {
	    var keys = [];

	    for (var key in object) {
	      keys.push(key);
	    }

	    keys.reverse();
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();

	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];

	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1,
	            next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;
	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    return {
	      next: doneResult
	    };
	  }

	  exports.values = values;

	  function doneResult() {
	    return {
	      value: undefined$1,
	      done: true
	    };
	  }

	  Context.prototype = {
	    constructor: Context,
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;
	      this.method = "next";
	      this.arg = undefined$1;
	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },
	    stop: function stop() {
	      this.done = true;
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;

	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;

	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !!caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];

	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];

	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];

	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;

	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }

	          return thrown;
	        }
	      }

	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };
	  return exports;
	}(( _typeof(module)) === "object" ? module.exports : {});

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
	    globalThis.regeneratorRuntime = runtime;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}

	/***/ }),
	/* 4 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
	exports.arrayByteLength = arrayByteLength;
	exports.arraysToBytes = arraysToBytes;
	exports.assert = assert;
	exports.bytesToString = bytesToString;
	exports.createObjectURL = createObjectURL;
	exports.createPromiseCapability = createPromiseCapability;
	exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
	exports.escapeString = escapeString;
	exports.getModificationDate = getModificationDate;
	exports.getVerbosityLevel = getVerbosityLevel;
	exports.info = info;
	exports.isArrayBuffer = isArrayBuffer;
	exports.isArrayEqual = isArrayEqual;
	exports.isAscii = isAscii;
	exports.isBool = isBool;
	exports.isNum = isNum;
	exports.isSameOrigin = isSameOrigin;
	exports.isString = isString;
	exports.objectFromMap = objectFromMap;
	exports.objectSize = objectSize;
	exports.removeNullCharacters = removeNullCharacters;
	exports.setVerbosityLevel = setVerbosityLevel;
	exports.shadow = shadow;
	exports.string32 = string32;
	exports.stringToBytes = stringToBytes;
	exports.stringToPDFString = stringToPDFString;
	exports.stringToUTF16BEString = stringToUTF16BEString;
	exports.stringToUTF8String = stringToUTF8String;
	exports.unreachable = unreachable;
	exports.utf8StringToString = utf8StringToString;
	exports.warn = warn;

	__w_pdfjs_require__(5);

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
	exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
	var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
	exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
	var RenderingIntentFlag = {
	  ANY: 0x01,
	  DISPLAY: 0x02,
	  PRINT: 0x04,
	  ANNOTATIONS_FORMS: 0x10,
	  ANNOTATIONS_STORAGE: 0x20,
	  ANNOTATIONS_DISABLE: 0x40,
	  OPLIST: 0x100
	};
	exports.RenderingIntentFlag = RenderingIntentFlag;
	var AnnotationMode = {
	  DISABLE: 0,
	  ENABLE: 1,
	  ENABLE_FORMS: 2,
	  ENABLE_STORAGE: 3
	};
	exports.AnnotationMode = AnnotationMode;
	var PermissionFlag = {
	  PRINT: 0x04,
	  MODIFY_CONTENTS: 0x08,
	  COPY: 0x10,
	  MODIFY_ANNOTATIONS: 0x20,
	  FILL_INTERACTIVE_FORMS: 0x100,
	  COPY_FOR_ACCESSIBILITY: 0x200,
	  ASSEMBLE: 0x400,
	  PRINT_HIGH_QUALITY: 0x800
	};
	exports.PermissionFlag = PermissionFlag;
	var TextRenderingMode = {
	  FILL: 0,
	  STROKE: 1,
	  FILL_STROKE: 2,
	  INVISIBLE: 3,
	  FILL_ADD_TO_PATH: 4,
	  STROKE_ADD_TO_PATH: 5,
	  FILL_STROKE_ADD_TO_PATH: 6,
	  ADD_TO_PATH: 7,
	  FILL_STROKE_MASK: 3,
	  ADD_TO_PATH_FLAG: 4
	};
	exports.TextRenderingMode = TextRenderingMode;
	var ImageKind = {
	  GRAYSCALE_1BPP: 1,
	  RGB_24BPP: 2,
	  RGBA_32BPP: 3
	};
	exports.ImageKind = ImageKind;
	var AnnotationType = {
	  TEXT: 1,
	  LINK: 2,
	  FREETEXT: 3,
	  LINE: 4,
	  SQUARE: 5,
	  CIRCLE: 6,
	  POLYGON: 7,
	  POLYLINE: 8,
	  HIGHLIGHT: 9,
	  UNDERLINE: 10,
	  SQUIGGLY: 11,
	  STRIKEOUT: 12,
	  STAMP: 13,
	  CARET: 14,
	  INK: 15,
	  POPUP: 16,
	  FILEATTACHMENT: 17,
	  SOUND: 18,
	  MOVIE: 19,
	  WIDGET: 20,
	  SCREEN: 21,
	  PRINTERMARK: 22,
	  TRAPNET: 23,
	  WATERMARK: 24,
	  THREED: 25,
	  REDACT: 26
	};
	exports.AnnotationType = AnnotationType;
	var AnnotationStateModelType = {
	  MARKED: "Marked",
	  REVIEW: "Review"
	};
	exports.AnnotationStateModelType = AnnotationStateModelType;
	var AnnotationMarkedState = {
	  MARKED: "Marked",
	  UNMARKED: "Unmarked"
	};
	exports.AnnotationMarkedState = AnnotationMarkedState;
	var AnnotationReviewState = {
	  ACCEPTED: "Accepted",
	  REJECTED: "Rejected",
	  CANCELLED: "Cancelled",
	  COMPLETED: "Completed",
	  NONE: "None"
	};
	exports.AnnotationReviewState = AnnotationReviewState;
	var AnnotationReplyType = {
	  GROUP: "Group",
	  REPLY: "R"
	};
	exports.AnnotationReplyType = AnnotationReplyType;
	var AnnotationFlag = {
	  INVISIBLE: 0x01,
	  HIDDEN: 0x02,
	  PRINT: 0x04,
	  NOZOOM: 0x08,
	  NOROTATE: 0x10,
	  NOVIEW: 0x20,
	  READONLY: 0x40,
	  LOCKED: 0x80,
	  TOGGLENOVIEW: 0x100,
	  LOCKEDCONTENTS: 0x200
	};
	exports.AnnotationFlag = AnnotationFlag;
	var AnnotationFieldFlag = {
	  READONLY: 0x0000001,
	  REQUIRED: 0x0000002,
	  NOEXPORT: 0x0000004,
	  MULTILINE: 0x0001000,
	  PASSWORD: 0x0002000,
	  NOTOGGLETOOFF: 0x0004000,
	  RADIO: 0x0008000,
	  PUSHBUTTON: 0x0010000,
	  COMBO: 0x0020000,
	  EDIT: 0x0040000,
	  SORT: 0x0080000,
	  FILESELECT: 0x0100000,
	  MULTISELECT: 0x0200000,
	  DONOTSPELLCHECK: 0x0400000,
	  DONOTSCROLL: 0x0800000,
	  COMB: 0x1000000,
	  RICHTEXT: 0x2000000,
	  RADIOSINUNISON: 0x2000000,
	  COMMITONSELCHANGE: 0x4000000
	};
	exports.AnnotationFieldFlag = AnnotationFieldFlag;
	var AnnotationBorderStyleType = {
	  SOLID: 1,
	  DASHED: 2,
	  BEVELED: 3,
	  INSET: 4,
	  UNDERLINE: 5
	};
	exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
	var AnnotationActionEventType = {
	  E: "Mouse Enter",
	  X: "Mouse Exit",
	  D: "Mouse Down",
	  U: "Mouse Up",
	  Fo: "Focus",
	  Bl: "Blur",
	  PO: "PageOpen",
	  PC: "PageClose",
	  PV: "PageVisible",
	  PI: "PageInvisible",
	  K: "Keystroke",
	  F: "Format",
	  V: "Validate",
	  C: "Calculate"
	};
	exports.AnnotationActionEventType = AnnotationActionEventType;
	var DocumentActionEventType = {
	  WC: "WillClose",
	  WS: "WillSave",
	  DS: "DidSave",
	  WP: "WillPrint",
	  DP: "DidPrint"
	};
	exports.DocumentActionEventType = DocumentActionEventType;
	var PageActionEventType = {
	  O: "PageOpen",
	  C: "PageClose"
	};
	exports.PageActionEventType = PageActionEventType;
	var StreamType = {
	  UNKNOWN: "UNKNOWN",
	  FLATE: "FLATE",
	  LZW: "LZW",
	  DCT: "DCT",
	  JPX: "JPX",
	  JBIG: "JBIG",
	  A85: "A85",
	  AHX: "AHX",
	  CCF: "CCF",
	  RLX: "RLX"
	};
	exports.StreamType = StreamType;
	var FontType = {
	  UNKNOWN: "UNKNOWN",
	  TYPE1: "TYPE1",
	  TYPE1STANDARD: "TYPE1STANDARD",
	  TYPE1C: "TYPE1C",
	  CIDFONTTYPE0: "CIDFONTTYPE0",
	  CIDFONTTYPE0C: "CIDFONTTYPE0C",
	  TRUETYPE: "TRUETYPE",
	  CIDFONTTYPE2: "CIDFONTTYPE2",
	  TYPE3: "TYPE3",
	  OPENTYPE: "OPENTYPE",
	  TYPE0: "TYPE0",
	  MMTYPE1: "MMTYPE1"
	};
	exports.FontType = FontType;
	var VerbosityLevel = {
	  ERRORS: 0,
	  WARNINGS: 1,
	  INFOS: 5
	};
	exports.VerbosityLevel = VerbosityLevel;
	var CMapCompressionType = {
	  NONE: 0,
	  BINARY: 1,
	  STREAM: 2
	};
	exports.CMapCompressionType = CMapCompressionType;
	var OPS = {
	  dependency: 1,
	  setLineWidth: 2,
	  setLineCap: 3,
	  setLineJoin: 4,
	  setMiterLimit: 5,
	  setDash: 6,
	  setRenderingIntent: 7,
	  setFlatness: 8,
	  setGState: 9,
	  save: 10,
	  restore: 11,
	  transform: 12,
	  moveTo: 13,
	  lineTo: 14,
	  curveTo: 15,
	  curveTo2: 16,
	  curveTo3: 17,
	  closePath: 18,
	  rectangle: 19,
	  stroke: 20,
	  closeStroke: 21,
	  fill: 22,
	  eoFill: 23,
	  fillStroke: 24,
	  eoFillStroke: 25,
	  closeFillStroke: 26,
	  closeEOFillStroke: 27,
	  endPath: 28,
	  clip: 29,
	  eoClip: 30,
	  beginText: 31,
	  endText: 32,
	  setCharSpacing: 33,
	  setWordSpacing: 34,
	  setHScale: 35,
	  setLeading: 36,
	  setFont: 37,
	  setTextRenderingMode: 38,
	  setTextRise: 39,
	  moveText: 40,
	  setLeadingMoveText: 41,
	  setTextMatrix: 42,
	  nextLine: 43,
	  showText: 44,
	  showSpacedText: 45,
	  nextLineShowText: 46,
	  nextLineSetSpacingShowText: 47,
	  setCharWidth: 48,
	  setCharWidthAndBounds: 49,
	  setStrokeColorSpace: 50,
	  setFillColorSpace: 51,
	  setStrokeColor: 52,
	  setStrokeColorN: 53,
	  setFillColor: 54,
	  setFillColorN: 55,
	  setStrokeGray: 56,
	  setFillGray: 57,
	  setStrokeRGBColor: 58,
	  setFillRGBColor: 59,
	  setStrokeCMYKColor: 60,
	  setFillCMYKColor: 61,
	  shadingFill: 62,
	  beginInlineImage: 63,
	  beginImageData: 64,
	  endInlineImage: 65,
	  paintXObject: 66,
	  markPoint: 67,
	  markPointProps: 68,
	  beginMarkedContent: 69,
	  beginMarkedContentProps: 70,
	  endMarkedContent: 71,
	  beginCompat: 72,
	  endCompat: 73,
	  paintFormXObjectBegin: 74,
	  paintFormXObjectEnd: 75,
	  beginGroup: 76,
	  endGroup: 77,
	  beginAnnotations: 78,
	  endAnnotations: 79,
	  beginAnnotation: 80,
	  endAnnotation: 81,
	  paintJpegXObject: 82,
	  paintImageMaskXObject: 83,
	  paintImageMaskXObjectGroup: 84,
	  paintImageXObject: 85,
	  paintInlineImageXObject: 86,
	  paintInlineImageXObjectGroup: 87,
	  paintImageXObjectRepeat: 88,
	  paintImageMaskXObjectRepeat: 89,
	  paintSolidColorImageMask: 90,
	  constructPath: 91
	};
	exports.OPS = OPS;
	var UNSUPPORTED_FEATURES = {
	  unknown: "unknown",
	  forms: "forms",
	  javaScript: "javaScript",
	  signatures: "signatures",
	  smask: "smask",
	  shadingPattern: "shadingPattern",
	  font: "font",
	  errorTilingPattern: "errorTilingPattern",
	  errorExtGState: "errorExtGState",
	  errorXObject: "errorXObject",
	  errorFontLoadType3: "errorFontLoadType3",
	  errorFontState: "errorFontState",
	  errorFontMissing: "errorFontMissing",
	  errorFontTranslate: "errorFontTranslate",
	  errorColorSpace: "errorColorSpace",
	  errorOperatorList: "errorOperatorList",
	  errorFontToUnicode: "errorFontToUnicode",
	  errorFontLoadNative: "errorFontLoadNative",
	  errorFontBuildPath: "errorFontBuildPath",
	  errorFontGetPath: "errorFontGetPath",
	  errorMarkedContent: "errorMarkedContent",
	  errorContentSubStream: "errorContentSubStream"
	};
	exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
	var PasswordResponses = {
	  NEED_PASSWORD: 1,
	  INCORRECT_PASSWORD: 2
	};
	exports.PasswordResponses = PasswordResponses;
	var verbosity = VerbosityLevel.WARNINGS;

	function setVerbosityLevel(level) {
	  if (Number.isInteger(level)) {
	    verbosity = level;
	  }
	}

	function getVerbosityLevel() {
	  return verbosity;
	}

	function info(msg) {
	  if (verbosity >= VerbosityLevel.INFOS) {
	    console.log("Info: ".concat(msg));
	  }
	}

	function warn(msg) {
	  if (verbosity >= VerbosityLevel.WARNINGS) {
	    console.log("Warning: ".concat(msg));
	  }
	}

	function unreachable(msg) {
	  throw new Error(msg);
	}

	function assert(cond, msg) {
	  if (!cond) {
	    unreachable(msg);
	  }
	}

	function isSameOrigin(baseUrl, otherUrl) {
	  var base;

	  try {
	    base = new URL(baseUrl);

	    if (!base.origin || base.origin === "null") {
	      return false;
	    }
	  } catch (e) {
	    return false;
	  }

	  var other = new URL(otherUrl, base);
	  return base.origin === other.origin;
	}

	function _isValidProtocol(url) {
	  if (!url) {
	    return false;
	  }

	  switch (url.protocol) {
	    case "http:":
	    case "https:":
	    case "ftp:":
	    case "mailto:":
	    case "tel:":
	      return true;

	    default:
	      return false;
	  }
	}

	function createValidAbsoluteUrl(url) {
	  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (!url) {
	    return null;
	  }

	  try {
	    if (options && typeof url === "string") {
	      if (options.addDefaultProtocol && url.startsWith("www.")) {
	        var dots = url.match(/\./g);

	        if (dots && dots.length >= 2) {
	          url = "http://".concat(url);
	        }
	      }

	      if (options.tryConvertEncoding) {
	        try {
	          url = stringToUTF8String(url);
	        } catch (ex) {}
	      }
	    }

	    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

	    if (_isValidProtocol(absoluteUrl)) {
	      return absoluteUrl;
	    }
	  } catch (ex) {}

	  return null;
	}

	function shadow(obj, prop, value) {
	  Object.defineProperty(obj, prop, {
	    value: value,
	    enumerable: true,
	    configurable: true,
	    writable: false
	  });
	  return value;
	}

	var BaseException = function BaseExceptionClosure() {
	  function BaseException(message, name) {
	    if (this.constructor === BaseException) {
	      unreachable("Cannot initialize BaseException.");
	    }

	    this.message = message;
	    this.name = name;
	  }

	  BaseException.prototype = new Error();
	  BaseException.constructor = BaseException;
	  return BaseException;
	}();

	exports.BaseException = BaseException;

	var PasswordException = /*#__PURE__*/function (_BaseException) {
	  _inherits(PasswordException, _BaseException);

	  var _super = _createSuper(PasswordException);

	  function PasswordException(msg, code) {
	    var _this;

	    _classCallCheck(this, PasswordException);

	    _this = _super.call(this, msg, "PasswordException");
	    _this.code = code;
	    return _this;
	  }

	  return PasswordException;
	}(BaseException);

	exports.PasswordException = PasswordException;

	var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {
	  _inherits(UnknownErrorException, _BaseException2);

	  var _super2 = _createSuper(UnknownErrorException);

	  function UnknownErrorException(msg, details) {
	    var _this2;

	    _classCallCheck(this, UnknownErrorException);

	    _this2 = _super2.call(this, msg, "UnknownErrorException");
	    _this2.details = details;
	    return _this2;
	  }

	  return UnknownErrorException;
	}(BaseException);

	exports.UnknownErrorException = UnknownErrorException;

	var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {
	  _inherits(InvalidPDFException, _BaseException3);

	  var _super3 = _createSuper(InvalidPDFException);

	  function InvalidPDFException(msg) {
	    _classCallCheck(this, InvalidPDFException);

	    return _super3.call(this, msg, "InvalidPDFException");
	  }

	  return InvalidPDFException;
	}(BaseException);

	exports.InvalidPDFException = InvalidPDFException;

	var MissingPDFException = /*#__PURE__*/function (_BaseException4) {
	  _inherits(MissingPDFException, _BaseException4);

	  var _super4 = _createSuper(MissingPDFException);

	  function MissingPDFException(msg) {
	    _classCallCheck(this, MissingPDFException);

	    return _super4.call(this, msg, "MissingPDFException");
	  }

	  return MissingPDFException;
	}(BaseException);

	exports.MissingPDFException = MissingPDFException;

	var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {
	  _inherits(UnexpectedResponseException, _BaseException5);

	  var _super5 = _createSuper(UnexpectedResponseException);

	  function UnexpectedResponseException(msg, status) {
	    var _this3;

	    _classCallCheck(this, UnexpectedResponseException);

	    _this3 = _super5.call(this, msg, "UnexpectedResponseException");
	    _this3.status = status;
	    return _this3;
	  }

	  return UnexpectedResponseException;
	}(BaseException);

	exports.UnexpectedResponseException = UnexpectedResponseException;

	var FormatError = /*#__PURE__*/function (_BaseException6) {
	  _inherits(FormatError, _BaseException6);

	  var _super6 = _createSuper(FormatError);

	  function FormatError(msg) {
	    _classCallCheck(this, FormatError);

	    return _super6.call(this, msg, "FormatError");
	  }

	  return FormatError;
	}(BaseException);

	exports.FormatError = FormatError;

	var AbortException = /*#__PURE__*/function (_BaseException7) {
	  _inherits(AbortException, _BaseException7);

	  var _super7 = _createSuper(AbortException);

	  function AbortException(msg) {
	    _classCallCheck(this, AbortException);

	    return _super7.call(this, msg, "AbortException");
	  }

	  return AbortException;
	}(BaseException);

	exports.AbortException = AbortException;
	var NullCharactersRegExp = /\x00+/g;
	var InvisibleCharactersRegExp = /[\x01-\x1F]/g;

	function removeNullCharacters(str) {
	  var replaceInvisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (typeof str !== "string") {
	    warn("The argument for removeNullCharacters must be a string.");
	    return str;
	  }

	  if (replaceInvisible) {
	    str = str.replace(InvisibleCharactersRegExp, " ");
	  }

	  return str.replace(NullCharactersRegExp, "");
	}

	function bytesToString(bytes) {
	  assert(bytes !== null && _typeof(bytes) === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
	  var length = bytes.length;
	  var MAX_ARGUMENT_COUNT = 8192;

	  if (length < MAX_ARGUMENT_COUNT) {
	    return String.fromCharCode.apply(null, bytes);
	  }

	  var strBuf = [];

	  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
	    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
	    var chunk = bytes.subarray(i, chunkEnd);
	    strBuf.push(String.fromCharCode.apply(null, chunk));
	  }

	  return strBuf.join("");
	}

	function stringToBytes(str) {
	  assert(typeof str === "string", "Invalid argument for stringToBytes");
	  var length = str.length;
	  var bytes = new Uint8Array(length);

	  for (var i = 0; i < length; ++i) {
	    bytes[i] = str.charCodeAt(i) & 0xff;
	  }

	  return bytes;
	}

	function arrayByteLength(arr) {
	  if (arr.length !== undefined) {
	    return arr.length;
	  }

	  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
	  return arr.byteLength;
	}

	function arraysToBytes(arr) {
	  var length = arr.length;

	  if (length === 1 && arr[0] instanceof Uint8Array) {
	    return arr[0];
	  }

	  var resultLength = 0;

	  for (var i = 0; i < length; i++) {
	    resultLength += arrayByteLength(arr[i]);
	  }

	  var pos = 0;
	  var data = new Uint8Array(resultLength);

	  for (var _i = 0; _i < length; _i++) {
	    var item = arr[_i];

	    if (!(item instanceof Uint8Array)) {
	      if (typeof item === "string") {
	        item = stringToBytes(item);
	      } else {
	        item = new Uint8Array(item);
	      }
	    }

	    var itemLength = item.byteLength;
	    data.set(item, pos);
	    pos += itemLength;
	  }

	  return data;
	}

	function string32(value) {
	  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
	}

	function objectSize(obj) {
	  return Object.keys(obj).length;
	}

	function objectFromMap(map) {
	  var obj = Object.create(null);

	  var _iterator = _createForOfIteratorHelper(map),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var _step$value = _slicedToArray(_step.value, 2),
	          key = _step$value[0],
	          value = _step$value[1];

	      obj[key] = value;
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  return obj;
	}

	function isLittleEndian() {
	  var buffer8 = new Uint8Array(4);
	  buffer8[0] = 1;
	  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
	  return view32[0] === 1;
	}

	var IsLittleEndianCached = {
	  get value() {
	    return shadow(this, "value", isLittleEndian());
	  }

	};
	exports.IsLittleEndianCached = IsLittleEndianCached;

	function isEvalSupported() {
	  try {
	    new Function("");
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	var IsEvalSupportedCached = {
	  get value() {
	    return shadow(this, "value", isEvalSupported());
	  }

	};
	exports.IsEvalSupportedCached = IsEvalSupportedCached;

	var hexNumbers = _toConsumableArray(Array(256).keys()).map(function (n) {
	  return n.toString(16).padStart(2, "0");
	});

	var Util = /*#__PURE__*/function () {
	  function Util() {
	    _classCallCheck(this, Util);
	  }

	  _createClass(Util, null, [{
	    key: "makeHexColor",
	    value: function makeHexColor(r, g, b) {
	      return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
	    }
	  }, {
	    key: "transform",
	    value: function transform(m1, m2) {
	      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
	    }
	  }, {
	    key: "applyTransform",
	    value: function applyTransform(p, m) {
	      var xt = p[0] * m[0] + p[1] * m[2] + m[4];
	      var yt = p[0] * m[1] + p[1] * m[3] + m[5];
	      return [xt, yt];
	    }
	  }, {
	    key: "applyInverseTransform",
	    value: function applyInverseTransform(p, m) {
	      var d = m[0] * m[3] - m[1] * m[2];
	      var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
	      var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
	      return [xt, yt];
	    }
	  }, {
	    key: "getAxialAlignedBoundingBox",
	    value: function getAxialAlignedBoundingBox(r, m) {
	      var p1 = Util.applyTransform(r, m);
	      var p2 = Util.applyTransform(r.slice(2, 4), m);
	      var p3 = Util.applyTransform([r[0], r[3]], m);
	      var p4 = Util.applyTransform([r[2], r[1]], m);
	      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
	    }
	  }, {
	    key: "inverseTransform",
	    value: function inverseTransform(m) {
	      var d = m[0] * m[3] - m[1] * m[2];
	      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
	    }
	  }, {
	    key: "apply3dTransform",
	    value: function apply3dTransform(m, v) {
	      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
	    }
	  }, {
	    key: "singularValueDecompose2dScale",
	    value: function singularValueDecompose2dScale(m) {
	      var transpose = [m[0], m[2], m[1], m[3]];
	      var a = m[0] * transpose[0] + m[1] * transpose[2];
	      var b = m[0] * transpose[1] + m[1] * transpose[3];
	      var c = m[2] * transpose[0] + m[3] * transpose[2];
	      var d = m[2] * transpose[1] + m[3] * transpose[3];
	      var first = (a + d) / 2;
	      var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;
	      var sx = first + second || 1;
	      var sy = first - second || 1;
	      return [Math.sqrt(sx), Math.sqrt(sy)];
	    }
	  }, {
	    key: "normalizeRect",
	    value: function normalizeRect(rect) {
	      var r = rect.slice(0);

	      if (rect[0] > rect[2]) {
	        r[0] = rect[2];
	        r[2] = rect[0];
	      }

	      if (rect[1] > rect[3]) {
	        r[1] = rect[3];
	        r[3] = rect[1];
	      }

	      return r;
	    }
	  }, {
	    key: "intersect",
	    value: function intersect(rect1, rect2) {
	      function compare(a, b) {
	        return a - b;
	      }

	      var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
	      var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
	      var result = [];
	      rect1 = Util.normalizeRect(rect1);
	      rect2 = Util.normalizeRect(rect2);

	      if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
	        result[0] = orderedX[1];
	        result[2] = orderedX[2];
	      } else {
	        return null;
	      }

	      if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
	        result[1] = orderedY[1];
	        result[3] = orderedY[2];
	      } else {
	        return null;
	      }

	      return result;
	    }
	  }, {
	    key: "bezierBoundingBox",
	    value: function bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
	      var tvalues = [],
	          bounds = [[], []];
	      var a, b, c, t, t1, t2, b2ac, sqrtb2ac;

	      for (var i = 0; i < 2; ++i) {
	        if (i === 0) {
	          b = 6 * x0 - 12 * x1 + 6 * x2;
	          a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	          c = 3 * x1 - 3 * x0;
	        } else {
	          b = 6 * y0 - 12 * y1 + 6 * y2;
	          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	          c = 3 * y1 - 3 * y0;
	        }

	        if (Math.abs(a) < 1e-12) {
	          if (Math.abs(b) < 1e-12) {
	            continue;
	          }

	          t = -c / b;

	          if (0 < t && t < 1) {
	            tvalues.push(t);
	          }

	          continue;
	        }

	        b2ac = b * b - 4 * c * a;
	        sqrtb2ac = Math.sqrt(b2ac);

	        if (b2ac < 0) {
	          continue;
	        }

	        t1 = (-b + sqrtb2ac) / (2 * a);

	        if (0 < t1 && t1 < 1) {
	          tvalues.push(t1);
	        }

	        t2 = (-b - sqrtb2ac) / (2 * a);

	        if (0 < t2 && t2 < 1) {
	          tvalues.push(t2);
	        }
	      }

	      var j = tvalues.length,
	          mt;
	      var jlen = j;

	      while (j--) {
	        t = tvalues[j];
	        mt = 1 - t;
	        bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
	        bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
	      }

	      bounds[0][jlen] = x0;
	      bounds[1][jlen] = y0;
	      bounds[0][jlen + 1] = x3;
	      bounds[1][jlen + 1] = y3;
	      bounds[0].length = bounds[1].length = jlen + 2;
	      return [Math.min.apply(Math, _toConsumableArray(bounds[0])), Math.min.apply(Math, _toConsumableArray(bounds[1])), Math.max.apply(Math, _toConsumableArray(bounds[0])), Math.max.apply(Math, _toConsumableArray(bounds[1]))];
	    }
	  }]);

	  return Util;
	}();

	exports.Util = Util;
	var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

	function stringToPDFString(str) {
	  var length = str.length,
	      strBuf = [];

	  if (str[0] === "\xFE" && str[1] === "\xFF") {
	    for (var i = 2; i < length; i += 2) {
	      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
	    }
	  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
	    for (var _i2 = 2; _i2 < length; _i2 += 2) {
	      strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));
	    }
	  } else {
	    for (var _i3 = 0; _i3 < length; ++_i3) {
	      var code = PDFStringTranslateTable[str.charCodeAt(_i3)];
	      strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));
	    }
	  }

	  return strBuf.join("");
	}

	function escapeString(str) {
	  return str.replace(/([()\\\n\r])/g, function (match) {
	    if (match === "\n") {
	      return "\\n";
	    } else if (match === "\r") {
	      return "\\r";
	    }

	    return "\\".concat(match);
	  });
	}

	function isAscii(str) {
	  return /^[\x00-\x7F]*$/.test(str);
	}

	function stringToUTF16BEString(str) {
	  var buf = ["\xFE\xFF"];

	  for (var i = 0, ii = str.length; i < ii; i++) {
	    var _char = str.charCodeAt(i);

	    buf.push(String.fromCharCode(_char >> 8 & 0xff), String.fromCharCode(_char & 0xff));
	  }

	  return buf.join("");
	}

	function stringToUTF8String(str) {
	  return decodeURIComponent(escape(str));
	}

	function utf8StringToString(str) {
	  return unescape(encodeURIComponent(str));
	}

	function isBool(v) {
	  return typeof v === "boolean";
	}

	function isNum(v) {
	  return typeof v === "number";
	}

	function isString(v) {
	  return typeof v === "string";
	}

	function isArrayBuffer(v) {
	  return _typeof(v) === "object" && v !== null && v.byteLength !== undefined;
	}

	function isArrayEqual(arr1, arr2) {
	  if (arr1.length !== arr2.length) {
	    return false;
	  }

	  for (var i = 0, ii = arr1.length; i < ii; i++) {
	    if (arr1[i] !== arr2[i]) {
	      return false;
	    }
	  }

	  return true;
	}

	function getModificationDate() {
	  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
	  var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
	  return buffer.join("");
	}

	function createPromiseCapability() {
	  var capability = Object.create(null);
	  var isSettled = false;
	  Object.defineProperty(capability, "settled", {
	    get: function get() {
	      return isSettled;
	    }
	  });
	  capability.promise = new Promise(function (resolve, reject) {
	    capability.resolve = function (data) {
	      isSettled = true;
	      resolve(data);
	    };

	    capability.reject = function (reason) {
	      isSettled = true;
	      reject(reason);
	    };
	  });
	  return capability;
	}

	function createObjectURL(data) {
	  var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
	  var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
	    return URL.createObjectURL(new Blob([data], {
	      type: contentType
	    }));
	  }

	  var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	  var buffer = "data:".concat(contentType, ";base64,");

	  for (var i = 0, ii = data.length; i < ii; i += 3) {
	    var b1 = data[i] & 0xff;
	    var b2 = data[i + 1] & 0xff;
	    var b3 = data[i + 2] & 0xff;
	    var d1 = b1 >> 2,
	        d2 = (b1 & 3) << 4 | b2 >> 4;
	    var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
	    var d4 = i + 2 < ii ? b3 & 0x3f : 64;
	    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
	  }

	  return buffer;
	}

	/***/ }),
	/* 5 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {


	var _is_node = __w_pdfjs_require__(6);

	if (typeof globalThis === "undefined" || !globalThis._pdfjsCompatibilityChecked) {
	  if (typeof globalThis === "undefined" || globalThis.Math !== Math) {
	    globalThis = __w_pdfjs_require__(7);
	  }

	  globalThis._pdfjsCompatibilityChecked = true;

	  (function checkNodeBtoa() {
	    if (globalThis.btoa || !_is_node.isNodeJS) {
	      return;
	    }

	    globalThis.btoa = function (chars) {
	      return Buffer.from(chars, "binary").toString("base64");
	    };
	  })();

	  (function checkNodeAtob() {
	    if (globalThis.atob || !_is_node.isNodeJS) {
	      return;
	    }

	    globalThis.atob = function (input) {
	      return Buffer.from(input, "base64").toString("binary");
	    };
	  })();

	  (function checkDOMMatrix() {
	    if (globalThis.DOMMatrix || !_is_node.isNodeJS) {
	      return;
	    }

	    globalThis.DOMMatrix = __w_pdfjs_require__(69);
	  })();

	  (function checkObjectFromEntries() {
	    if (Object.fromEntries) {
	      return;
	    }

	    __w_pdfjs_require__(70);
	  })();

	  (function checkPromise() {
	    if (globalThis.Promise.allSettled) {
	      return;
	    }

	    globalThis.Promise = __w_pdfjs_require__(97);
	  })();

	  (function checkReadableStream() {
	    if (globalThis.ReadableStream || !_is_node.isNodeJS) {
	      return;
	    }

	    globalThis.ReadableStream = (__w_pdfjs_require__(134).ReadableStream);
	  })();
	}

	/***/ }),
	/* 6 */
	/***/ ((__unused_webpack_module, exports) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.isNodeJS = void 0;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
	exports.isNodeJS = isNodeJS;

	/***/ }),
	/* 7 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	__w_pdfjs_require__(8);
	module.exports = __w_pdfjs_require__(10);

	/***/ }),
	/* 8 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var global = __w_pdfjs_require__(10);
	$({ global: true }, { globalThis: global });

	/***/ }),
	/* 9 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var getOwnPropertyDescriptor = (__w_pdfjs_require__(11).f);
	var createNonEnumerableProperty = __w_pdfjs_require__(47);
	var redefine = __w_pdfjs_require__(50);
	var setGlobal = __w_pdfjs_require__(41);
	var copyConstructorProperties = __w_pdfjs_require__(57);
	var isForced = __w_pdfjs_require__(68);
	module.exports = function (options, source) {
	 var TARGET = options.target;
	 var GLOBAL = options.global;
	 var STATIC = options.stat;
	 var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	 if (GLOBAL) {
	  target = global;
	 } else if (STATIC) {
	  target = global[TARGET] || setGlobal(TARGET, {});
	 } else {
	  target = (global[TARGET] || {}).prototype;
	 }
	 if (target)
	  for (key in source) {
	   sourceProperty = source[key];
	   if (options.noTargetGet) {
	    descriptor = getOwnPropertyDescriptor(target, key);
	    targetProperty = descriptor && descriptor.value;
	   } else
	    targetProperty = target[key];
	   FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	   if (!FORCED && targetProperty !== undefined) {
	    if (typeof sourceProperty == typeof targetProperty)
	     continue;
	    copyConstructorProperties(sourceProperty, targetProperty);
	   }
	   if (options.sham || targetProperty && targetProperty.sham) {
	    createNonEnumerableProperty(sourceProperty, 'sham', true);
	   }
	   redefine(target, key, sourceProperty, options);
	  }
	};

	/***/ }),
	/* 10 */
	/***/ ((module) => {

	var check = function (it) {
	 return it && it.Math == Math && it;
	};
	module.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || (function () {
	 return this;
	}()) || Function('return this')();

	/***/ }),
	/* 11 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

	var DESCRIPTORS = __w_pdfjs_require__(12);
	var call = __w_pdfjs_require__(14);
	var propertyIsEnumerableModule = __w_pdfjs_require__(15);
	var createPropertyDescriptor = __w_pdfjs_require__(16);
	var toIndexedObject = __w_pdfjs_require__(17);
	var toPropertyKey = __w_pdfjs_require__(22);
	var hasOwn = __w_pdfjs_require__(42);
	var IE8_DOM_DEFINE = __w_pdfjs_require__(45);
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	 O = toIndexedObject(O);
	 P = toPropertyKey(P);
	 if (IE8_DOM_DEFINE)
	  try {
	   return $getOwnPropertyDescriptor(O, P);
	  } catch (error) {
	  }
	 if (hasOwn(O, P))
	  return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
	};

	/***/ }),
	/* 12 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var fails = __w_pdfjs_require__(13);
	module.exports = !fails(function () {
	 return Object.defineProperty({}, 1, {
	  get: function () {
	   return 7;
	  }
	 })[1] != 7;
	});

	/***/ }),
	/* 13 */
	/***/ ((module) => {

	module.exports = function (exec) {
	 try {
	  return !!exec();
	 } catch (error) {
	  return true;
	 }
	};

	/***/ }),
	/* 14 */
	/***/ ((module) => {

	var call = Function.prototype.call;
	module.exports = call.bind ? call.bind(call) : function () {
	 return call.apply(call, arguments);
	};

	/***/ }),
	/* 15 */
	/***/ ((__unused_webpack_module, exports) => {

	var $propertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
	exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	 var descriptor = getOwnPropertyDescriptor(this, V);
	 return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;

	/***/ }),
	/* 16 */
	/***/ ((module) => {

	module.exports = function (bitmap, value) {
	 return {
	  enumerable: !(bitmap & 1),
	  configurable: !(bitmap & 2),
	  writable: !(bitmap & 4),
	  value: value
	 };
	};

	/***/ }),
	/* 17 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var IndexedObject = __w_pdfjs_require__(18);
	var requireObjectCoercible = __w_pdfjs_require__(21);
	module.exports = function (it) {
	 return IndexedObject(requireObjectCoercible(it));
	};

	/***/ }),
	/* 18 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var uncurryThis = __w_pdfjs_require__(19);
	var fails = __w_pdfjs_require__(13);
	var classof = __w_pdfjs_require__(20);
	var Object = global.Object;
	var split = uncurryThis(''.split);
	module.exports = fails(function () {
	 return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	 return classof(it) == 'String' ? split(it, '') : Object(it);
	} : Object;

	/***/ }),
	/* 19 */
	/***/ ((module) => {

	var FunctionPrototype = Function.prototype;
	var bind = FunctionPrototype.bind;
	var call = FunctionPrototype.call;
	var callBind = bind && bind.bind(call);
	module.exports = bind ? function (fn) {
	 return fn && callBind(call, fn);
	} : function (fn) {
	 return fn && function () {
	  return call.apply(fn, arguments);
	 };
	};

	/***/ }),
	/* 20 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var toString = uncurryThis({}.toString);
	var stringSlice = uncurryThis(''.slice);
	module.exports = function (it) {
	 return stringSlice(toString(it), 8, -1);
	};

	/***/ }),
	/* 21 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var TypeError = global.TypeError;
	module.exports = function (it) {
	 if (it == undefined)
	  throw TypeError("Can't call method on " + it);
	 return it;
	};

	/***/ }),
	/* 22 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toPrimitive = __w_pdfjs_require__(23);
	var isSymbol = __w_pdfjs_require__(26);
	module.exports = function (argument) {
	 var key = toPrimitive(argument, 'string');
	 return isSymbol(key) ? key : key + '';
	};

	/***/ }),
	/* 23 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var call = __w_pdfjs_require__(14);
	var isObject = __w_pdfjs_require__(24);
	var isSymbol = __w_pdfjs_require__(26);
	var getMethod = __w_pdfjs_require__(33);
	var ordinaryToPrimitive = __w_pdfjs_require__(36);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var TypeError = global.TypeError;
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	module.exports = function (input, pref) {
	 if (!isObject(input) || isSymbol(input))
	  return input;
	 var exoticToPrim = getMethod(input, TO_PRIMITIVE);
	 var result;
	 if (exoticToPrim) {
	  if (pref === undefined)
	   pref = 'default';
	  result = call(exoticToPrim, input, pref);
	  if (!isObject(result) || isSymbol(result))
	   return result;
	  throw TypeError("Can't convert object to primitive value");
	 }
	 if (pref === undefined)
	  pref = 'number';
	 return ordinaryToPrimitive(input, pref);
	};

	/***/ }),
	/* 24 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var isCallable = __w_pdfjs_require__(25);
	module.exports = function (it) {
	 return typeof it == 'object' ? it !== null : isCallable(it);
	};

	/***/ }),
	/* 25 */
	/***/ ((module) => {

	module.exports = function (argument) {
	 return typeof argument == 'function';
	};

	/***/ }),
	/* 26 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var getBuiltIn = __w_pdfjs_require__(27);
	var isCallable = __w_pdfjs_require__(25);
	var isPrototypeOf = __w_pdfjs_require__(28);
	var USE_SYMBOL_AS_UID = __w_pdfjs_require__(29);
	var Object = global.Object;
	module.exports = USE_SYMBOL_AS_UID ? function (it) {
	 return typeof it == 'symbol';
	} : function (it) {
	 var $Symbol = getBuiltIn('Symbol');
	 return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
	};

	/***/ }),
	/* 27 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isCallable = __w_pdfjs_require__(25);
	var aFunction = function (argument) {
	 return isCallable(argument) ? argument : undefined;
	};
	module.exports = function (namespace, method) {
	 return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
	};

	/***/ }),
	/* 28 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	module.exports = uncurryThis({}.isPrototypeOf);

	/***/ }),
	/* 29 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var NATIVE_SYMBOL = __w_pdfjs_require__(30);
	module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';

	/***/ }),
	/* 30 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var V8_VERSION = __w_pdfjs_require__(31);
	var fails = __w_pdfjs_require__(13);
	module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
	 var symbol = Symbol();
	 return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
	});

	/***/ }),
	/* 31 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var userAgent = __w_pdfjs_require__(32);
	var process = global.process;
	var Deno = global.Deno;
	var versions = process && process.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version;
	if (v8) {
	 match = v8.split('.');
	 version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}
	if (!version && userAgent) {
	 match = userAgent.match(/Edge\/(\d+)/);
	 if (!match || match[1] >= 74) {
	  match = userAgent.match(/Chrome\/(\d+)/);
	  if (match)
	   version = +match[1];
	 }
	}
	module.exports = version;

	/***/ }),
	/* 32 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var getBuiltIn = __w_pdfjs_require__(27);
	module.exports = getBuiltIn('navigator', 'userAgent') || '';

	/***/ }),
	/* 33 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var aCallable = __w_pdfjs_require__(34);
	module.exports = function (V, P) {
	 var func = V[P];
	 return func == null ? undefined : aCallable(func);
	};

	/***/ }),
	/* 34 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isCallable = __w_pdfjs_require__(25);
	var tryToString = __w_pdfjs_require__(35);
	var TypeError = global.TypeError;
	module.exports = function (argument) {
	 if (isCallable(argument))
	  return argument;
	 throw TypeError(tryToString(argument) + ' is not a function');
	};

	/***/ }),
	/* 35 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var String = global.String;
	module.exports = function (argument) {
	 try {
	  return String(argument);
	 } catch (error) {
	  return 'Object';
	 }
	};

	/***/ }),
	/* 36 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var call = __w_pdfjs_require__(14);
	var isCallable = __w_pdfjs_require__(25);
	var isObject = __w_pdfjs_require__(24);
	var TypeError = global.TypeError;
	module.exports = function (input, pref) {
	 var fn, val;
	 if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
	  return val;
	 if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
	  return val;
	 if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
	  return val;
	 throw TypeError("Can't convert object to primitive value");
	};

	/***/ }),
	/* 37 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var shared = __w_pdfjs_require__(38);
	var hasOwn = __w_pdfjs_require__(42);
	var uid = __w_pdfjs_require__(44);
	var NATIVE_SYMBOL = __w_pdfjs_require__(30);
	var USE_SYMBOL_AS_UID = __w_pdfjs_require__(29);
	var WellKnownSymbolsStore = shared('wks');
	var Symbol = global.Symbol;
	var symbolFor = Symbol && Symbol['for'];
	var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
	module.exports = function (name) {
	 if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
	  var description = 'Symbol.' + name;
	  if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
	   WellKnownSymbolsStore[name] = Symbol[name];
	  } else if (USE_SYMBOL_AS_UID && symbolFor) {
	   WellKnownSymbolsStore[name] = symbolFor(description);
	  } else {
	   WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
	  }
	 }
	 return WellKnownSymbolsStore[name];
	};

	/***/ }),
	/* 38 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var IS_PURE = __w_pdfjs_require__(39);
	var store = __w_pdfjs_require__(40);
	(module.exports = function (key, value) {
	 return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	 version: '3.19.3',
	 mode: IS_PURE ? 'pure' : 'global',
	 copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
	});

	/***/ }),
	/* 39 */
	/***/ ((module) => {

	module.exports = false;

	/***/ }),
	/* 40 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var setGlobal = __w_pdfjs_require__(41);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || setGlobal(SHARED, {});
	module.exports = store;

	/***/ }),
	/* 41 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var defineProperty = Object.defineProperty;
	module.exports = function (key, value) {
	 try {
	  defineProperty(global, key, {
	   value: value,
	   configurable: true,
	   writable: true
	  });
	 } catch (error) {
	  global[key] = value;
	 }
	 return value;
	};

	/***/ }),
	/* 42 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var toObject = __w_pdfjs_require__(43);
	var hasOwnProperty = uncurryThis({}.hasOwnProperty);
	module.exports = Object.hasOwn || function hasOwn(it, key) {
	 return hasOwnProperty(toObject(it), key);
	};

	/***/ }),
	/* 43 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var requireObjectCoercible = __w_pdfjs_require__(21);
	var Object = global.Object;
	module.exports = function (argument) {
	 return Object(requireObjectCoercible(argument));
	};

	/***/ }),
	/* 44 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var id = 0;
	var postfix = Math.random();
	var toString = uncurryThis(1.0.toString);
	module.exports = function (key) {
	 return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
	};

	/***/ }),
	/* 45 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var DESCRIPTORS = __w_pdfjs_require__(12);
	var fails = __w_pdfjs_require__(13);
	var createElement = __w_pdfjs_require__(46);
	module.exports = !DESCRIPTORS && !fails(function () {
	 return Object.defineProperty(createElement('div'), 'a', {
	  get: function () {
	   return 7;
	  }
	 }).a != 7;
	});

	/***/ }),
	/* 46 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isObject = __w_pdfjs_require__(24);
	var document = global.document;
	var EXISTS = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	 return EXISTS ? document.createElement(it) : {};
	};

	/***/ }),
	/* 47 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var DESCRIPTORS = __w_pdfjs_require__(12);
	var definePropertyModule = __w_pdfjs_require__(48);
	var createPropertyDescriptor = __w_pdfjs_require__(16);
	module.exports = DESCRIPTORS ? function (object, key, value) {
	 return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	 object[key] = value;
	 return object;
	};

	/***/ }),
	/* 48 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var DESCRIPTORS = __w_pdfjs_require__(12);
	var IE8_DOM_DEFINE = __w_pdfjs_require__(45);
	var anObject = __w_pdfjs_require__(49);
	var toPropertyKey = __w_pdfjs_require__(22);
	var TypeError = global.TypeError;
	var $defineProperty = Object.defineProperty;
	exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
	 anObject(O);
	 P = toPropertyKey(P);
	 anObject(Attributes);
	 if (IE8_DOM_DEFINE)
	  try {
	   return $defineProperty(O, P, Attributes);
	  } catch (error) {
	  }
	 if ('get' in Attributes || 'set' in Attributes)
	  throw TypeError('Accessors not supported');
	 if ('value' in Attributes)
	  O[P] = Attributes.value;
	 return O;
	};

	/***/ }),
	/* 49 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isObject = __w_pdfjs_require__(24);
	var String = global.String;
	var TypeError = global.TypeError;
	module.exports = function (argument) {
	 if (isObject(argument))
	  return argument;
	 throw TypeError(String(argument) + ' is not an object');
	};

	/***/ }),
	/* 50 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isCallable = __w_pdfjs_require__(25);
	var hasOwn = __w_pdfjs_require__(42);
	var createNonEnumerableProperty = __w_pdfjs_require__(47);
	var setGlobal = __w_pdfjs_require__(41);
	var inspectSource = __w_pdfjs_require__(51);
	var InternalStateModule = __w_pdfjs_require__(52);
	var CONFIGURABLE_FUNCTION_NAME = (__w_pdfjs_require__(56).CONFIGURABLE);
	var getInternalState = InternalStateModule.get;
	var enforceInternalState = InternalStateModule.enforce;
	var TEMPLATE = String(String).split('String');
	(module.exports = function (O, key, value, options) {
	 var unsafe = options ? !!options.unsafe : false;
	 var simple = options ? !!options.enumerable : false;
	 var noTargetGet = options ? !!options.noTargetGet : false;
	 var name = options && options.name !== undefined ? options.name : key;
	 var state;
	 if (isCallable(value)) {
	  if (String(name).slice(0, 7) === 'Symbol(') {
	   name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
	  }
	  if (!hasOwn(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
	   createNonEnumerableProperty(value, 'name', name);
	  }
	  state = enforceInternalState(value);
	  if (!state.source) {
	   state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
	  }
	 }
	 if (O === global) {
	  if (simple)
	   O[key] = value;
	  else
	   setGlobal(key, value);
	  return;
	 } else if (!unsafe) {
	  delete O[key];
	 } else if (!noTargetGet && O[key]) {
	  simple = true;
	 }
	 if (simple)
	  O[key] = value;
	 else
	  createNonEnumerableProperty(O, key, value);
	})(Function.prototype, 'toString', function toString() {
	 return isCallable(this) && getInternalState(this).source || inspectSource(this);
	});

	/***/ }),
	/* 51 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var isCallable = __w_pdfjs_require__(25);
	var store = __w_pdfjs_require__(40);
	var functionToString = uncurryThis(Function.toString);
	if (!isCallable(store.inspectSource)) {
	 store.inspectSource = function (it) {
	  return functionToString(it);
	 };
	}
	module.exports = store.inspectSource;

	/***/ }),
	/* 52 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var NATIVE_WEAK_MAP = __w_pdfjs_require__(53);
	var global = __w_pdfjs_require__(10);
	var uncurryThis = __w_pdfjs_require__(19);
	var isObject = __w_pdfjs_require__(24);
	var createNonEnumerableProperty = __w_pdfjs_require__(47);
	var hasOwn = __w_pdfjs_require__(42);
	var shared = __w_pdfjs_require__(40);
	var sharedKey = __w_pdfjs_require__(54);
	var hiddenKeys = __w_pdfjs_require__(55);
	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError = global.TypeError;
	var WeakMap = global.WeakMap;
	var set, get, has;
	var enforce = function (it) {
	 return has(it) ? get(it) : set(it, {});
	};
	var getterFor = function (TYPE) {
	 return function (it) {
	  var state;
	  if (!isObject(it) || (state = get(it)).type !== TYPE) {
	   throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	  }
	  return state;
	 };
	};
	if (NATIVE_WEAK_MAP || shared.state) {
	 var store = shared.state || (shared.state = new WeakMap());
	 var wmget = uncurryThis(store.get);
	 var wmhas = uncurryThis(store.has);
	 var wmset = uncurryThis(store.set);
	 set = function (it, metadata) {
	  if (wmhas(store, it))
	   throw new TypeError(OBJECT_ALREADY_INITIALIZED);
	  metadata.facade = it;
	  wmset(store, it, metadata);
	  return metadata;
	 };
	 get = function (it) {
	  return wmget(store, it) || {};
	 };
	 has = function (it) {
	  return wmhas(store, it);
	 };
	} else {
	 var STATE = sharedKey('state');
	 hiddenKeys[STATE] = true;
	 set = function (it, metadata) {
	  if (hasOwn(it, STATE))
	   throw new TypeError(OBJECT_ALREADY_INITIALIZED);
	  metadata.facade = it;
	  createNonEnumerableProperty(it, STATE, metadata);
	  return metadata;
	 };
	 get = function (it) {
	  return hasOwn(it, STATE) ? it[STATE] : {};
	 };
	 has = function (it) {
	  return hasOwn(it, STATE);
	 };
	}
	module.exports = {
	 set: set,
	 get: get,
	 has: has,
	 enforce: enforce,
	 getterFor: getterFor
	};

	/***/ }),
	/* 53 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isCallable = __w_pdfjs_require__(25);
	var inspectSource = __w_pdfjs_require__(51);
	var WeakMap = global.WeakMap;
	module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));

	/***/ }),
	/* 54 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var shared = __w_pdfjs_require__(38);
	var uid = __w_pdfjs_require__(44);
	var keys = shared('keys');
	module.exports = function (key) {
	 return keys[key] || (keys[key] = uid(key));
	};

	/***/ }),
	/* 55 */
	/***/ ((module) => {

	module.exports = {};

	/***/ }),
	/* 56 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var DESCRIPTORS = __w_pdfjs_require__(12);
	var hasOwn = __w_pdfjs_require__(42);
	var FunctionPrototype = Function.prototype;
	var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
	var EXISTS = hasOwn(FunctionPrototype, 'name');
	var PROPER = EXISTS && function something() {
	}.name === 'something';
	var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable);
	module.exports = {
	 EXISTS: EXISTS,
	 PROPER: PROPER,
	 CONFIGURABLE: CONFIGURABLE
	};

	/***/ }),
	/* 57 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var hasOwn = __w_pdfjs_require__(42);
	var ownKeys = __w_pdfjs_require__(58);
	var getOwnPropertyDescriptorModule = __w_pdfjs_require__(11);
	var definePropertyModule = __w_pdfjs_require__(48);
	module.exports = function (target, source) {
	 var keys = ownKeys(source);
	 var defineProperty = definePropertyModule.f;
	 var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
	 for (var i = 0; i < keys.length; i++) {
	  var key = keys[i];
	  if (!hasOwn(target, key))
	   defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	 }
	};

	/***/ }),
	/* 58 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var getBuiltIn = __w_pdfjs_require__(27);
	var uncurryThis = __w_pdfjs_require__(19);
	var getOwnPropertyNamesModule = __w_pdfjs_require__(59);
	var getOwnPropertySymbolsModule = __w_pdfjs_require__(67);
	var anObject = __w_pdfjs_require__(49);
	var concat = uncurryThis([].concat);
	module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	 var keys = getOwnPropertyNamesModule.f(anObject(it));
	 var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
	 return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
	};

	/***/ }),
	/* 59 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

	var internalObjectKeys = __w_pdfjs_require__(60);
	var enumBugKeys = __w_pdfjs_require__(66);
	var hiddenKeys = enumBugKeys.concat('length', 'prototype');
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	 return internalObjectKeys(O, hiddenKeys);
	};

	/***/ }),
	/* 60 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var hasOwn = __w_pdfjs_require__(42);
	var toIndexedObject = __w_pdfjs_require__(17);
	var indexOf = (__w_pdfjs_require__(61).indexOf);
	var hiddenKeys = __w_pdfjs_require__(55);
	var push = uncurryThis([].push);
	module.exports = function (object, names) {
	 var O = toIndexedObject(object);
	 var i = 0;
	 var result = [];
	 var key;
	 for (key in O)
	  !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
	 while (names.length > i)
	  if (hasOwn(O, key = names[i++])) {
	   ~indexOf(result, key) || push(result, key);
	  }
	 return result;
	};

	/***/ }),
	/* 61 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toIndexedObject = __w_pdfjs_require__(17);
	var toAbsoluteIndex = __w_pdfjs_require__(62);
	var lengthOfArrayLike = __w_pdfjs_require__(64);
	var createMethod = function (IS_INCLUDES) {
	 return function ($this, el, fromIndex) {
	  var O = toIndexedObject($this);
	  var length = lengthOfArrayLike(O);
	  var index = toAbsoluteIndex(fromIndex, length);
	  var value;
	  if (IS_INCLUDES && el != el)
	   while (length > index) {
	    value = O[index++];
	    if (value != value)
	     return true;
	   }
	  else
	   for (; length > index; index++) {
	    if ((IS_INCLUDES || index in O) && O[index] === el)
	     return IS_INCLUDES || index || 0;
	   }
	  return !IS_INCLUDES && -1;
	 };
	};
	module.exports = {
	 includes: createMethod(true),
	 indexOf: createMethod(false)
	};

	/***/ }),
	/* 62 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toIntegerOrInfinity = __w_pdfjs_require__(63);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	 var integer = toIntegerOrInfinity(index);
	 return integer < 0 ? max(integer + length, 0) : min(integer, length);
	};

	/***/ }),
	/* 63 */
	/***/ ((module) => {

	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (argument) {
	 var number = +argument;
	 return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
	};

	/***/ }),
	/* 64 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toLength = __w_pdfjs_require__(65);
	module.exports = function (obj) {
	 return toLength(obj.length);
	};

	/***/ }),
	/* 65 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toIntegerOrInfinity = __w_pdfjs_require__(63);
	var min = Math.min;
	module.exports = function (argument) {
	 return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0;
	};

	/***/ }),
	/* 66 */
	/***/ ((module) => {

	module.exports = [
	 'constructor',
	 'hasOwnProperty',
	 'isPrototypeOf',
	 'propertyIsEnumerable',
	 'toLocaleString',
	 'toString',
	 'valueOf'
	];

	/***/ }),
	/* 67 */
	/***/ ((__unused_webpack_module, exports) => {

	exports.f = Object.getOwnPropertySymbols;

	/***/ }),
	/* 68 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var fails = __w_pdfjs_require__(13);
	var isCallable = __w_pdfjs_require__(25);
	var replacement = /#|\.prototype\./;
	var isForced = function (feature, detection) {
	 var value = data[normalize(feature)];
	 return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
	};
	var normalize = isForced.normalize = function (string) {
	 return String(string).replace(replacement, '.').toLowerCase();
	};
	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	module.exports = isForced;

	/***/ }),
	/* 69 */
	/***/ ((module, exports, __w_pdfjs_require__) => {
	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	(function (global, factory) {
	  ( _typeof(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() :  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
			__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
			(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __w_pdfjs_require__, exports, module)) :
			__WEBPACK_AMD_DEFINE_FACTORY__),
			__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) ;
	})(void 0, function () {

	  function fromArray(array) {
	    var m = new CSSMatrix();
	    var a = Array.from(array);

	    if (!a.every(function (n) {
	      return !Number.isNaN(n);
	    })) {
	      throw TypeError("CSSMatrix: \"" + array + "\" must only have numbers.");
	    }

	    if (a.length === 16) {
	      var m11 = a[0];
	      var m12 = a[1];
	      var m13 = a[2];
	      var m14 = a[3];
	      var m21 = a[4];
	      var m22 = a[5];
	      var m23 = a[6];
	      var m24 = a[7];
	      var m31 = a[8];
	      var m32 = a[9];
	      var m33 = a[10];
	      var m34 = a[11];
	      var m41 = a[12];
	      var m42 = a[13];
	      var m43 = a[14];
	      var m44 = a[15];
	      m.m11 = m11;
	      m.a = m11;
	      m.m21 = m21;
	      m.c = m21;
	      m.m31 = m31;
	      m.m41 = m41;
	      m.e = m41;
	      m.m12 = m12;
	      m.b = m12;
	      m.m22 = m22;
	      m.d = m22;
	      m.m32 = m32;
	      m.m42 = m42;
	      m.f = m42;
	      m.m13 = m13;
	      m.m23 = m23;
	      m.m33 = m33;
	      m.m43 = m43;
	      m.m14 = m14;
	      m.m24 = m24;
	      m.m34 = m34;
	      m.m44 = m44;
	    } else if (a.length === 6) {
	      var M11 = a[0];
	      var M12 = a[1];
	      var M21 = a[2];
	      var M22 = a[3];
	      var M41 = a[4];
	      var M42 = a[5];
	      m.m11 = M11;
	      m.a = M11;
	      m.m12 = M12;
	      m.b = M12;
	      m.m21 = M21;
	      m.c = M21;
	      m.m22 = M22;
	      m.d = M22;
	      m.m41 = M41;
	      m.e = M41;
	      m.m42 = M42;
	      m.f = M42;
	    } else {
	      throw new TypeError('CSSMatrix: expecting an Array of 6/16 values.');
	    }

	    return m;
	  }

	  function fromMatrix(m) {
	    var keys = Object.keys(new CSSMatrix());

	    if (_typeof(m) === 'object' && keys.every(function (k) {
	      return k in m;
	    })) {
	      return fromArray([m.m11, m.m12, m.m13, m.m14, m.m21, m.m22, m.m23, m.m24, m.m31, m.m32, m.m33, m.m34, m.m41, m.m42, m.m43, m.m44]);
	    }

	    throw TypeError("CSSMatrix: \"" + m + "\" is not a DOMMatrix / CSSMatrix / JSON compatible object.");
	  }

	  function fromString(source) {
	    if (typeof source !== 'string') {
	      throw TypeError("CSSMatrix: \"" + source + "\" is not a string.");
	    }

	    var str = String(source).replace(/\s/g, '');
	    var m = new CSSMatrix();
	    var invalidStringError = "CSSMatrix: invalid transform string \"" + source + "\"";
	    str.split(')').filter(function (f) {
	      return f;
	    }).forEach(function (tf) {
	      var ref = tf.split('(');
	      var prop = ref[0];
	      var value = ref[1];

	      if (!value) {
	        throw TypeError(invalidStringError);
	      }

	      var components = value.split(',').map(function (n) {
	        return n.includes('rad') ? parseFloat(n) * (180 / Math.PI) : parseFloat(n);
	      });
	      var x = components[0];
	      var y = components[1];
	      var z = components[2];
	      var a = components[3];
	      var xyz = [x, y, z];
	      var xyza = [x, y, z, a];

	      if (prop === 'perspective' && x && [y, z].every(function (n) {
	        return n === undefined;
	      })) {
	        m.m34 = -1 / x;
	      } else if (prop.includes('matrix') && [6, 16].includes(components.length) && components.every(function (n) {
	        return !Number.isNaN(+n);
	      })) {
	        var values = components.map(function (n) {
	          return Math.abs(n) < 1e-6 ? 0 : n;
	        });
	        m = m.multiply(fromArray(values));
	      } else if (prop === 'translate3d' && xyz.every(function (n) {
	        return !Number.isNaN(+n);
	      })) {
	        m = m.translate(x, y, z);
	      } else if (prop === 'translate' && x && z === undefined) {
	        m = m.translate(x, y || 0, 0);
	      } else if (prop === 'rotate3d' && xyza.every(function (n) {
	        return !Number.isNaN(+n);
	      }) && a) {
	        m = m.rotateAxisAngle(x, y, z, a);
	      } else if (prop === 'rotate' && x && [y, z].every(function (n) {
	        return n === undefined;
	      })) {
	        m = m.rotate(0, 0, x);
	      } else if (prop === 'scale3d' && xyz.every(function (n) {
	        return !Number.isNaN(+n);
	      }) && xyz.some(function (n) {
	        return n !== 1;
	      })) {
	        m = m.scale(x, y, z);
	      } else if (prop === 'scale' && !Number.isNaN(x) && x !== 1 && z === undefined) {
	        var nosy = Number.isNaN(+y);
	        var sy = nosy ? x : y;
	        m = m.scale(x, sy, 1);
	      } else if (prop === 'skew' && x && z === undefined) {
	        m = m.skewX(x);
	        m = y ? m.skewY(y) : m;
	      } else if (/[XYZ]/.test(prop) && x && [y, z].every(function (n) {
	        return n === undefined;
	      }) && ['translate', 'rotate', 'scale', 'skew'].some(function (p) {
	        return prop.includes(p);
	      })) {
	        if (['skewX', 'skewY'].includes(prop)) {
	          m = m[prop](x);
	        } else {
	          var fn = prop.replace(/[XYZ]/, '');
	          var axis = prop.replace(fn, '');
	          var idx = ['X', 'Y', 'Z'].indexOf(axis);
	          var axeValues = [idx === 0 ? x : 0, idx === 1 ? x : 0, idx === 2 ? x : 0];
	          m = m[fn].apply(m, axeValues);
	        }
	      } else {
	        throw TypeError(invalidStringError);
	      }
	    });
	    return m;
	  }

	  function Translate(x, y, z) {
	    var m = new CSSMatrix();
	    m.m41 = x;
	    m.e = x;
	    m.m42 = y;
	    m.f = y;
	    m.m43 = z;
	    return m;
	  }

	  function Rotate(rx, ry, rz) {
	    var m = new CSSMatrix();
	    var degToRad = Math.PI / 180;
	    var radX = rx * degToRad;
	    var radY = ry * degToRad;
	    var radZ = rz * degToRad;
	    var cosx = Math.cos(radX);
	    var sinx = -Math.sin(radX);
	    var cosy = Math.cos(radY);
	    var siny = -Math.sin(radY);
	    var cosz = Math.cos(radZ);
	    var sinz = -Math.sin(radZ);
	    var m11 = cosy * cosz;
	    var m12 = -cosy * sinz;
	    m.m11 = m11;
	    m.a = m11;
	    m.m12 = m12;
	    m.b = m12;
	    m.m13 = siny;
	    var m21 = sinx * siny * cosz + cosx * sinz;
	    m.m21 = m21;
	    m.c = m21;
	    var m22 = cosx * cosz - sinx * siny * sinz;
	    m.m22 = m22;
	    m.d = m22;
	    m.m23 = -sinx * cosy;
	    m.m31 = sinx * sinz - cosx * siny * cosz;
	    m.m32 = sinx * cosz + cosx * siny * sinz;
	    m.m33 = cosx * cosy;
	    return m;
	  }

	  function RotateAxisAngle(x, y, z, alpha) {
	    var m = new CSSMatrix();
	    var angle = alpha * (Math.PI / 360);
	    var sinA = Math.sin(angle);
	    var cosA = Math.cos(angle);
	    var sinA2 = sinA * sinA;
	    var length = Math.sqrt(x * x + y * y + z * z);
	    var X = x;
	    var Y = y;
	    var Z = z;

	    if (length === 0) {
	      X = 0;
	      Y = 0;
	      Z = 1;
	    } else {
	      X /= length;
	      Y /= length;
	      Z /= length;
	    }

	    var x2 = X * X;
	    var y2 = Y * Y;
	    var z2 = Z * Z;
	    var m11 = 1 - 2 * (y2 + z2) * sinA2;
	    m.m11 = m11;
	    m.a = m11;
	    var m12 = 2 * (X * Y * sinA2 + Z * sinA * cosA);
	    m.m12 = m12;
	    m.b = m12;
	    m.m13 = 2 * (X * Z * sinA2 - Y * sinA * cosA);
	    var m21 = 2 * (Y * X * sinA2 - Z * sinA * cosA);
	    m.m21 = m21;
	    m.c = m21;
	    var m22 = 1 - 2 * (z2 + x2) * sinA2;
	    m.m22 = m22;
	    m.d = m22;
	    m.m23 = 2 * (Y * Z * sinA2 + X * sinA * cosA);
	    m.m31 = 2 * (Z * X * sinA2 + Y * sinA * cosA);
	    m.m32 = 2 * (Z * Y * sinA2 - X * sinA * cosA);
	    m.m33 = 1 - 2 * (x2 + y2) * sinA2;
	    return m;
	  }

	  function Scale(x, y, z) {
	    var m = new CSSMatrix();
	    m.m11 = x;
	    m.a = x;
	    m.m22 = y;
	    m.d = y;
	    m.m33 = z;
	    return m;
	  }

	  function SkewX(angle) {
	    var m = new CSSMatrix();
	    var radA = angle * Math.PI / 180;
	    var t = Math.tan(radA);
	    m.m21 = t;
	    m.c = t;
	    return m;
	  }

	  function SkewY(angle) {
	    var m = new CSSMatrix();
	    var radA = angle * Math.PI / 180;
	    var t = Math.tan(radA);
	    m.m12 = t;
	    m.b = t;
	    return m;
	  }

	  function Multiply(m1, m2) {
	    var m11 = m2.m11 * m1.m11 + m2.m12 * m1.m21 + m2.m13 * m1.m31 + m2.m14 * m1.m41;
	    var m12 = m2.m11 * m1.m12 + m2.m12 * m1.m22 + m2.m13 * m1.m32 + m2.m14 * m1.m42;
	    var m13 = m2.m11 * m1.m13 + m2.m12 * m1.m23 + m2.m13 * m1.m33 + m2.m14 * m1.m43;
	    var m14 = m2.m11 * m1.m14 + m2.m12 * m1.m24 + m2.m13 * m1.m34 + m2.m14 * m1.m44;
	    var m21 = m2.m21 * m1.m11 + m2.m22 * m1.m21 + m2.m23 * m1.m31 + m2.m24 * m1.m41;
	    var m22 = m2.m21 * m1.m12 + m2.m22 * m1.m22 + m2.m23 * m1.m32 + m2.m24 * m1.m42;
	    var m23 = m2.m21 * m1.m13 + m2.m22 * m1.m23 + m2.m23 * m1.m33 + m2.m24 * m1.m43;
	    var m24 = m2.m21 * m1.m14 + m2.m22 * m1.m24 + m2.m23 * m1.m34 + m2.m24 * m1.m44;
	    var m31 = m2.m31 * m1.m11 + m2.m32 * m1.m21 + m2.m33 * m1.m31 + m2.m34 * m1.m41;
	    var m32 = m2.m31 * m1.m12 + m2.m32 * m1.m22 + m2.m33 * m1.m32 + m2.m34 * m1.m42;
	    var m33 = m2.m31 * m1.m13 + m2.m32 * m1.m23 + m2.m33 * m1.m33 + m2.m34 * m1.m43;
	    var m34 = m2.m31 * m1.m14 + m2.m32 * m1.m24 + m2.m33 * m1.m34 + m2.m34 * m1.m44;
	    var m41 = m2.m41 * m1.m11 + m2.m42 * m1.m21 + m2.m43 * m1.m31 + m2.m44 * m1.m41;
	    var m42 = m2.m41 * m1.m12 + m2.m42 * m1.m22 + m2.m43 * m1.m32 + m2.m44 * m1.m42;
	    var m43 = m2.m41 * m1.m13 + m2.m42 * m1.m23 + m2.m43 * m1.m33 + m2.m44 * m1.m43;
	    var m44 = m2.m41 * m1.m14 + m2.m42 * m1.m24 + m2.m43 * m1.m34 + m2.m44 * m1.m44;
	    return fromArray([m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44]);
	  }

	  var CSSMatrix = function CSSMatrix() {
	    var args = [],
	        len = arguments.length;

	    while (len--) {
	      args[len] = arguments[len];
	    }

	    var m = this;
	    m.a = 1;
	    m.b = 0;
	    m.c = 0;
	    m.d = 1;
	    m.e = 0;
	    m.f = 0;
	    m.m11 = 1;
	    m.m12 = 0;
	    m.m13 = 0;
	    m.m14 = 0;
	    m.m21 = 0;
	    m.m22 = 1;
	    m.m23 = 0;
	    m.m24 = 0;
	    m.m31 = 0;
	    m.m32 = 0;
	    m.m33 = 1;
	    m.m34 = 0;
	    m.m41 = 0;
	    m.m42 = 0;
	    m.m43 = 0;
	    m.m44 = 1;

	    if (args && args.length) {
	      var ARGS = [16, 6].some(function (l) {
	        return l === args.length;
	      }) ? args : args[0];
	      return m.setMatrixValue(ARGS);
	    }

	    return m;
	  };

	  var prototypeAccessors = {
	    isIdentity: {
	      configurable: true
	    },
	    is2D: {
	      configurable: true
	    }
	  };

	  prototypeAccessors.isIdentity.set = function (value) {
	    this.isIdentity = value;
	  };

	  prototypeAccessors.isIdentity.get = function () {
	    var m = this;
	    return m.m11 === 1 && m.m12 === 0 && m.m13 === 0 && m.m14 === 0 && m.m21 === 0 && m.m22 === 1 && m.m23 === 0 && m.m24 === 0 && m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m41 === 0 && m.m42 === 0 && m.m43 === 0 && m.m44 === 1;
	  };

	  prototypeAccessors.is2D.get = function () {
	    var m = this;
	    return m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m43 === 0 && m.m44 === 1;
	  };

	  prototypeAccessors.is2D.set = function (value) {
	    this.is2D = value;
	  };

	  CSSMatrix.prototype.setMatrixValue = function setMatrixValue(source) {
	    var m = this;

	    if ([Array, Float64Array, Float32Array].some(function (a) {
	      return source instanceof a;
	    })) {
	      return fromArray(source);
	    }

	    if (typeof source === 'string' && source.length && source !== 'none') {
	      return fromString(source);
	    }

	    if (_typeof(source) === 'object') {
	      return fromMatrix(source);
	    }

	    return m;
	  };

	  CSSMatrix.prototype.toArray = function toArray() {
	    var m = this;
	    var pow = Math.pow(10, 6);
	    var result;

	    if (m.is2D) {
	      result = [m.a, m.b, m.c, m.d, m.e, m.f];
	    } else {
	      result = [m.m11, m.m12, m.m13, m.m14, m.m21, m.m22, m.m23, m.m24, m.m31, m.m32, m.m33, m.m34, m.m41, m.m42, m.m43, m.m44];
	    }

	    return result.map(function (n) {
	      return Math.abs(n) < 1e-6 ? 0 : (n * pow >> 0) / pow;
	    });
	  };

	  CSSMatrix.prototype.toString = function toString() {
	    var m = this;
	    var values = m.toArray();
	    var type = m.is2D ? 'matrix' : 'matrix3d';
	    return type + "(" + values + ")";
	  };

	  CSSMatrix.prototype.toJSON = function toJSON() {
	    var m = this;
	    var is2D = m.is2D;
	    var isIdentity = m.isIdentity;
	    return Object.assign({}, m, {
	      is2D: is2D,
	      isIdentity: isIdentity
	    });
	  };

	  CSSMatrix.prototype.multiply = function multiply(m2) {
	    return Multiply(this, m2);
	  };

	  CSSMatrix.prototype.translate = function translate(x, y, z) {
	    var X = x;
	    var Y = y;
	    var Z = z;

	    if (Z === undefined) {
	      Z = 0;
	    }

	    if (Y === undefined) {
	      Y = 0;
	    }

	    return Multiply(this, Translate(X, Y, Z));
	  };

	  CSSMatrix.prototype.scale = function scale(x, y, z) {
	    var X = x;
	    var Y = y;
	    var Z = z;

	    if (Y === undefined) {
	      Y = x;
	    }

	    if (Z === undefined) {
	      Z = 1;
	    }

	    return Multiply(this, Scale(X, Y, Z));
	  };

	  CSSMatrix.prototype.rotate = function rotate(rx, ry, rz) {
	    var RX = rx;
	    var RY = ry;
	    var RZ = rz;

	    if (RY === undefined) {
	      RY = 0;
	    }

	    if (RZ === undefined) {
	      RZ = RX;
	      RX = 0;
	    }

	    return Multiply(this, Rotate(RX, RY, RZ));
	  };

	  CSSMatrix.prototype.rotateAxisAngle = function rotateAxisAngle(x, y, z, angle) {
	    if ([x, y, z, angle].some(function (n) {
	      return Number.isNaN(n);
	    })) {
	      throw new TypeError('CSSMatrix: expecting 4 values');
	    }

	    return Multiply(this, RotateAxisAngle(x, y, z, angle));
	  };

	  CSSMatrix.prototype.skewX = function skewX(angle) {
	    return Multiply(this, SkewX(angle));
	  };

	  CSSMatrix.prototype.skewY = function skewY(angle) {
	    return Multiply(this, SkewY(angle));
	  };

	  CSSMatrix.prototype.transformPoint = function transformPoint(v) {
	    var M = this;
	    var m = Translate(v.x, v.y, v.z);
	    m.m44 = v.w || 1;
	    m = M.multiply(m);
	    return {
	      x: m.m41,
	      y: m.m42,
	      z: m.m43,
	      w: m.m44
	    };
	  };

	  CSSMatrix.prototype.transform = function transform(t) {
	    var m = this;
	    var x = m.m11 * t.x + m.m12 * t.y + m.m13 * t.z + m.m14 * t.w;
	    var y = m.m21 * t.x + m.m22 * t.y + m.m23 * t.z + m.m24 * t.w;
	    var z = m.m31 * t.x + m.m32 * t.y + m.m33 * t.z + m.m34 * t.w;
	    var w = m.m41 * t.x + m.m42 * t.y + m.m43 * t.z + m.m44 * t.w;
	    return {
	      x: x / w,
	      y: y / w,
	      z: z / w,
	      w: w
	    };
	  };

	  Object.defineProperties(CSSMatrix.prototype, prototypeAccessors);
	  Object.assign(CSSMatrix, {
	    Translate: Translate,
	    Rotate: Rotate,
	    RotateAxisAngle: RotateAxisAngle,
	    Scale: Scale,
	    SkewX: SkewX,
	    SkewY: SkewY,
	    Multiply: Multiply,
	    fromArray: fromArray,
	    fromMatrix: fromMatrix,
	    fromString: fromString
	  });
	  var version = "0.0.24";
	  var Version = version;
	  Object.assign(CSSMatrix, {
	    Version: Version
	  });
	  return CSSMatrix;
	});

	/***/ }),
	/* 70 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	__w_pdfjs_require__(71);
	__w_pdfjs_require__(86);
	var path = __w_pdfjs_require__(96);
	module.exports = path.Object.fromEntries;

	/***/ }),
	/* 71 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toIndexedObject = __w_pdfjs_require__(17);
	var addToUnscopables = __w_pdfjs_require__(72);
	var Iterators = __w_pdfjs_require__(77);
	var InternalStateModule = __w_pdfjs_require__(52);
	var defineIterator = __w_pdfjs_require__(78);
	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState = InternalStateModule.set;
	var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
	module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
	 setInternalState(this, {
	  type: ARRAY_ITERATOR,
	  target: toIndexedObject(iterated),
	  index: 0,
	  kind: kind
	 });
	}, function () {
	 var state = getInternalState(this);
	 var target = state.target;
	 var kind = state.kind;
	 var index = state.index++;
	 if (!target || index >= target.length) {
	  state.target = undefined;
	  return {
	   value: undefined,
	   done: true
	  };
	 }
	 if (kind == 'keys')
	  return {
	   value: index,
	   done: false
	  };
	 if (kind == 'values')
	  return {
	   value: target[index],
	   done: false
	  };
	 return {
	  value: [
	   index,
	   target[index]
	  ],
	  done: false
	 };
	}, 'values');
	Iterators.Arguments = Iterators.Array;
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	/***/ }),
	/* 72 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var wellKnownSymbol = __w_pdfjs_require__(37);
	var create = __w_pdfjs_require__(73);
	var definePropertyModule = __w_pdfjs_require__(48);
	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype = Array.prototype;
	if (ArrayPrototype[UNSCOPABLES] == undefined) {
	 definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
	  configurable: true,
	  value: create(null)
	 });
	}
	module.exports = function (key) {
	 ArrayPrototype[UNSCOPABLES][key] = true;
	};

	/***/ }),
	/* 73 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var anObject = __w_pdfjs_require__(49);
	var defineProperties = __w_pdfjs_require__(74);
	var enumBugKeys = __w_pdfjs_require__(66);
	var hiddenKeys = __w_pdfjs_require__(55);
	var html = __w_pdfjs_require__(76);
	var documentCreateElement = __w_pdfjs_require__(46);
	var sharedKey = __w_pdfjs_require__(54);
	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');
	var EmptyConstructor = function () {
	};
	var scriptTag = function (content) {
	 return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	 activeXDocument.write(scriptTag(''));
	 activeXDocument.close();
	 var temp = activeXDocument.parentWindow.Object;
	 activeXDocument = null;
	 return temp;
	};
	var NullProtoObjectViaIFrame = function () {
	 var iframe = documentCreateElement('iframe');
	 var JS = 'java' + SCRIPT + ':';
	 var iframeDocument;
	 iframe.style.display = 'none';
	 html.appendChild(iframe);
	 iframe.src = String(JS);
	 iframeDocument = iframe.contentWindow.document;
	 iframeDocument.open();
	 iframeDocument.write(scriptTag('document.F=Object'));
	 iframeDocument.close();
	 return iframeDocument.F;
	};
	var activeXDocument;
	var NullProtoObject = function () {
	 try {
	  activeXDocument = new ActiveXObject('htmlfile');
	 } catch (error) {
	 }
	 NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
	 var length = enumBugKeys.length;
	 while (length--)
	  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	 return NullProtoObject();
	};
	hiddenKeys[IE_PROTO] = true;
	module.exports = Object.create || function create(O, Properties) {
	 var result;
	 if (O !== null) {
	  EmptyConstructor[PROTOTYPE] = anObject(O);
	  result = new EmptyConstructor();
	  EmptyConstructor[PROTOTYPE] = null;
	  result[IE_PROTO] = O;
	 } else
	  result = NullProtoObject();
	 return Properties === undefined ? result : defineProperties(result, Properties);
	};

	/***/ }),
	/* 74 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var DESCRIPTORS = __w_pdfjs_require__(12);
	var definePropertyModule = __w_pdfjs_require__(48);
	var anObject = __w_pdfjs_require__(49);
	var toIndexedObject = __w_pdfjs_require__(17);
	var objectKeys = __w_pdfjs_require__(75);
	module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
	 anObject(O);
	 var props = toIndexedObject(Properties);
	 var keys = objectKeys(Properties);
	 var length = keys.length;
	 var index = 0;
	 var key;
	 while (length > index)
	  definePropertyModule.f(O, key = keys[index++], props[key]);
	 return O;
	};

	/***/ }),
	/* 75 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var internalObjectKeys = __w_pdfjs_require__(60);
	var enumBugKeys = __w_pdfjs_require__(66);
	module.exports = Object.keys || function keys(O) {
	 return internalObjectKeys(O, enumBugKeys);
	};

	/***/ }),
	/* 76 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var getBuiltIn = __w_pdfjs_require__(27);
	module.exports = getBuiltIn('document', 'documentElement');

	/***/ }),
	/* 77 */
	/***/ ((module) => {

	module.exports = {};

	/***/ }),
	/* 78 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var call = __w_pdfjs_require__(14);
	var IS_PURE = __w_pdfjs_require__(39);
	var FunctionName = __w_pdfjs_require__(56);
	var isCallable = __w_pdfjs_require__(25);
	var createIteratorConstructor = __w_pdfjs_require__(79);
	var getPrototypeOf = __w_pdfjs_require__(81);
	var setPrototypeOf = __w_pdfjs_require__(84);
	var setToStringTag = __w_pdfjs_require__(83);
	var createNonEnumerableProperty = __w_pdfjs_require__(47);
	var redefine = __w_pdfjs_require__(50);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var Iterators = __w_pdfjs_require__(77);
	var IteratorsCore = __w_pdfjs_require__(80);
	var PROPER_FUNCTION_NAME = FunctionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
	var IteratorPrototype = IteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';
	var returnThis = function () {
	 return this;
	};
	module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	 createIteratorConstructor(IteratorConstructor, NAME, next);
	 var getIterationMethod = function (KIND) {
	  if (KIND === DEFAULT && defaultIterator)
	   return defaultIterator;
	  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
	   return IterablePrototype[KIND];
	  switch (KIND) {
	  case KEYS:
	   return function keys() {
	    return new IteratorConstructor(this, KIND);
	   };
	  case VALUES:
	   return function values() {
	    return new IteratorConstructor(this, KIND);
	   };
	  case ENTRIES:
	   return function entries() {
	    return new IteratorConstructor(this, KIND);
	   };
	  }
	  return function () {
	   return new IteratorConstructor(this);
	  };
	 };
	 var TO_STRING_TAG = NAME + ' Iterator';
	 var INCORRECT_VALUES_NAME = false;
	 var IterablePrototype = Iterable.prototype;
	 var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
	 var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	 var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	 var CurrentIteratorPrototype, methods, KEY;
	 if (anyNativeIterator) {
	  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
	  if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	   if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
	    if (setPrototypeOf) {
	     setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
	    } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
	     redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
	    }
	   }
	   setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	   if (IS_PURE)
	    Iterators[TO_STRING_TAG] = returnThis;
	  }
	 }
	 if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	  if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
	   createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
	  } else {
	   INCORRECT_VALUES_NAME = true;
	   defaultIterator = function values() {
	    return call(nativeIterator, this);
	   };
	  }
	 }
	 if (DEFAULT) {
	  methods = {
	   values: getIterationMethod(VALUES),
	   keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	   entries: getIterationMethod(ENTRIES)
	  };
	  if (FORCED)
	   for (KEY in methods) {
	    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	     redefine(IterablePrototype, KEY, methods[KEY]);
	    }
	   }
	  else
	   $({
	    target: NAME,
	    proto: true,
	    forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
	   }, methods);
	 }
	 if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
	  redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
	 }
	 Iterators[NAME] = defaultIterator;
	 return methods;
	};

	/***/ }),
	/* 79 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var IteratorPrototype = (__w_pdfjs_require__(80).IteratorPrototype);
	var create = __w_pdfjs_require__(73);
	var createPropertyDescriptor = __w_pdfjs_require__(16);
	var setToStringTag = __w_pdfjs_require__(83);
	var Iterators = __w_pdfjs_require__(77);
	var returnThis = function () {
	 return this;
	};
	module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
	 var TO_STRING_TAG = NAME + ' Iterator';
	 IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
	 setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
	 Iterators[TO_STRING_TAG] = returnThis;
	 return IteratorConstructor;
	};

	/***/ }),
	/* 80 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var fails = __w_pdfjs_require__(13);
	var isCallable = __w_pdfjs_require__(25);
	var create = __w_pdfjs_require__(73);
	var getPrototypeOf = __w_pdfjs_require__(81);
	var redefine = __w_pdfjs_require__(50);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var IS_PURE = __w_pdfjs_require__(39);
	var ITERATOR = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
	if ([].keys) {
	 arrayIterator = [].keys();
	 if (!('next' in arrayIterator))
	  BUGGY_SAFARI_ITERATORS = true;
	 else {
	  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
	  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
	   IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	 }
	}
	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
	 var test = {};
	 return IteratorPrototype[ITERATOR].call(test) !== test;
	});
	if (NEW_ITERATOR_PROTOTYPE)
	 IteratorPrototype = {};
	else if (IS_PURE)
	 IteratorPrototype = create(IteratorPrototype);
	if (!isCallable(IteratorPrototype[ITERATOR])) {
	 redefine(IteratorPrototype, ITERATOR, function () {
	  return this;
	 });
	}
	module.exports = {
	 IteratorPrototype: IteratorPrototype,
	 BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	/***/ }),
	/* 81 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var hasOwn = __w_pdfjs_require__(42);
	var isCallable = __w_pdfjs_require__(25);
	var toObject = __w_pdfjs_require__(43);
	var sharedKey = __w_pdfjs_require__(54);
	var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(82);
	var IE_PROTO = sharedKey('IE_PROTO');
	var Object = global.Object;
	var ObjectPrototype = Object.prototype;
	module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
	 var object = toObject(O);
	 if (hasOwn(object, IE_PROTO))
	  return object[IE_PROTO];
	 var constructor = object.constructor;
	 if (isCallable(constructor) && object instanceof constructor) {
	  return constructor.prototype;
	 }
	 return object instanceof Object ? ObjectPrototype : null;
	};

	/***/ }),
	/* 82 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var fails = __w_pdfjs_require__(13);
	module.exports = !fails(function () {
	 function F() {
	 }
	 F.prototype.constructor = null;
	 return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	/***/ }),
	/* 83 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var defineProperty = (__w_pdfjs_require__(48).f);
	var hasOwn = __w_pdfjs_require__(42);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	module.exports = function (it, TAG, STATIC) {
	 if (it && !hasOwn(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	  defineProperty(it, TO_STRING_TAG, {
	   configurable: true,
	   value: TAG
	  });
	 }
	};

	/***/ }),
	/* 84 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var anObject = __w_pdfjs_require__(49);
	var aPossiblePrototype = __w_pdfjs_require__(85);
	module.exports = Object.setPrototypeOf || ('__proto__' in {} ? (function () {
	 var CORRECT_SETTER = false;
	 var test = {};
	 var setter;
	 try {
	  setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
	  setter(test, []);
	  CORRECT_SETTER = test instanceof Array;
	 } catch (error) {
	 }
	 return function setPrototypeOf(O, proto) {
	  anObject(O);
	  aPossiblePrototype(proto);
	  if (CORRECT_SETTER)
	   setter(O, proto);
	  else
	   O.__proto__ = proto;
	  return O;
	 };
	}()) : undefined);

	/***/ }),
	/* 85 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isCallable = __w_pdfjs_require__(25);
	var String = global.String;
	var TypeError = global.TypeError;
	module.exports = function (argument) {
	 if (typeof argument == 'object' || isCallable(argument))
	  return argument;
	 throw TypeError("Can't set " + String(argument) + ' as a prototype');
	};

	/***/ }),
	/* 86 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var iterate = __w_pdfjs_require__(87);
	var createProperty = __w_pdfjs_require__(95);
	$({
	 target: 'Object',
	 stat: true
	}, {
	 fromEntries: function fromEntries(iterable) {
	  var obj = {};
	  iterate(iterable, function (k, v) {
	   createProperty(obj, k, v);
	  }, { AS_ENTRIES: true });
	  return obj;
	 }
	});

	/***/ }),
	/* 87 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var bind = __w_pdfjs_require__(88);
	var call = __w_pdfjs_require__(14);
	var anObject = __w_pdfjs_require__(49);
	var tryToString = __w_pdfjs_require__(35);
	var isArrayIteratorMethod = __w_pdfjs_require__(89);
	var lengthOfArrayLike = __w_pdfjs_require__(64);
	var isPrototypeOf = __w_pdfjs_require__(28);
	var getIterator = __w_pdfjs_require__(90);
	var getIteratorMethod = __w_pdfjs_require__(91);
	var iteratorClose = __w_pdfjs_require__(94);
	var TypeError = global.TypeError;
	var Result = function (stopped, result) {
	 this.stopped = stopped;
	 this.result = result;
	};
	var ResultPrototype = Result.prototype;
	module.exports = function (iterable, unboundFunction, options) {
	 var that = options && options.that;
	 var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	 var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	 var INTERRUPTED = !!(options && options.INTERRUPTED);
	 var fn = bind(unboundFunction, that);
	 var iterator, iterFn, index, length, result, next, step;
	 var stop = function (condition) {
	  if (iterator)
	   iteratorClose(iterator, 'normal', condition);
	  return new Result(true, condition);
	 };
	 var callFn = function (value) {
	  if (AS_ENTRIES) {
	   anObject(value);
	   return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	  }
	  return INTERRUPTED ? fn(value, stop) : fn(value);
	 };
	 if (IS_ITERATOR) {
	  iterator = iterable;
	 } else {
	  iterFn = getIteratorMethod(iterable);
	  if (!iterFn)
	   throw TypeError(tryToString(iterable) + ' is not iterable');
	  if (isArrayIteratorMethod(iterFn)) {
	   for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
	    result = callFn(iterable[index]);
	    if (result && isPrototypeOf(ResultPrototype, result))
	     return result;
	   }
	   return new Result(false);
	  }
	  iterator = getIterator(iterable, iterFn);
	 }
	 next = iterator.next;
	 while (!(step = call(next, iterator)).done) {
	  try {
	   result = callFn(step.value);
	  } catch (error) {
	   iteratorClose(iterator, 'throw', error);
	  }
	  if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result))
	   return result;
	 }
	 return new Result(false);
	};

	/***/ }),
	/* 88 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var aCallable = __w_pdfjs_require__(34);
	var bind = uncurryThis(uncurryThis.bind);
	module.exports = function (fn, that) {
	 aCallable(fn);
	 return that === undefined ? fn : bind ? bind(fn, that) : function () {
	  return fn.apply(that, arguments);
	 };
	};

	/***/ }),
	/* 89 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var wellKnownSymbol = __w_pdfjs_require__(37);
	var Iterators = __w_pdfjs_require__(77);
	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;
	module.exports = function (it) {
	 return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	/***/ }),
	/* 90 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var call = __w_pdfjs_require__(14);
	var aCallable = __w_pdfjs_require__(34);
	var anObject = __w_pdfjs_require__(49);
	var tryToString = __w_pdfjs_require__(35);
	var getIteratorMethod = __w_pdfjs_require__(91);
	var TypeError = global.TypeError;
	module.exports = function (argument, usingIterator) {
	 var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
	 if (aCallable(iteratorMethod))
	  return anObject(call(iteratorMethod, argument));
	 throw TypeError(tryToString(argument) + ' is not iterable');
	};

	/***/ }),
	/* 91 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var classof = __w_pdfjs_require__(92);
	var getMethod = __w_pdfjs_require__(33);
	var Iterators = __w_pdfjs_require__(77);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var ITERATOR = wellKnownSymbol('iterator');
	module.exports = function (it) {
	 if (it != undefined)
	  return getMethod(it, ITERATOR) || getMethod(it, '@@iterator') || Iterators[classof(it)];
	};

	/***/ }),
	/* 92 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(93);
	var isCallable = __w_pdfjs_require__(25);
	var classofRaw = __w_pdfjs_require__(20);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var Object = global.Object;
	var CORRECT_ARGUMENTS = classofRaw((function () {
	 return arguments;
	}())) == 'Arguments';
	var tryGet = function (it, key) {
	 try {
	  return it[key];
	 } catch (error) {
	 }
	};
	module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
	 var O, tag, result;
	 return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
	};

	/***/ }),
	/* 93 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var wellKnownSymbol = __w_pdfjs_require__(37);
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var test = {};
	test[TO_STRING_TAG] = 'z';
	module.exports = String(test) === '[object z]';

	/***/ }),
	/* 94 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var call = __w_pdfjs_require__(14);
	var anObject = __w_pdfjs_require__(49);
	var getMethod = __w_pdfjs_require__(33);
	module.exports = function (iterator, kind, value) {
	 var innerResult, innerError;
	 anObject(iterator);
	 try {
	  innerResult = getMethod(iterator, 'return');
	  if (!innerResult) {
	   if (kind === 'throw')
	    throw value;
	   return value;
	  }
	  innerResult = call(innerResult, iterator);
	 } catch (error) {
	  innerError = true;
	  innerResult = error;
	 }
	 if (kind === 'throw')
	  throw value;
	 if (innerError)
	  throw innerResult;
	 anObject(innerResult);
	 return value;
	};

	/***/ }),
	/* 95 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toPropertyKey = __w_pdfjs_require__(22);
	var definePropertyModule = __w_pdfjs_require__(48);
	var createPropertyDescriptor = __w_pdfjs_require__(16);
	module.exports = function (object, key, value) {
	 var propertyKey = toPropertyKey(key);
	 if (propertyKey in object)
	  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
	 else
	  object[propertyKey] = value;
	};

	/***/ }),
	/* 96 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	module.exports = global;

	/***/ }),
	/* 97 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	__w_pdfjs_require__(98);
	__w_pdfjs_require__(71);
	__w_pdfjs_require__(105);
	__w_pdfjs_require__(107);
	__w_pdfjs_require__(129);
	__w_pdfjs_require__(130);
	__w_pdfjs_require__(131);
	__w_pdfjs_require__(132);
	var path = __w_pdfjs_require__(96);
	module.exports = path.Promise;

	/***/ }),
	/* 98 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var global = __w_pdfjs_require__(10);
	var isPrototypeOf = __w_pdfjs_require__(28);
	var getPrototypeOf = __w_pdfjs_require__(81);
	var setPrototypeOf = __w_pdfjs_require__(84);
	var copyConstructorProperties = __w_pdfjs_require__(57);
	var create = __w_pdfjs_require__(73);
	var createNonEnumerableProperty = __w_pdfjs_require__(47);
	var createPropertyDescriptor = __w_pdfjs_require__(16);
	var clearErrorStack = __w_pdfjs_require__(99);
	var installErrorCause = __w_pdfjs_require__(101);
	var iterate = __w_pdfjs_require__(87);
	var normalizeStringArgument = __w_pdfjs_require__(102);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var ERROR_STACK_INSTALLABLE = __w_pdfjs_require__(104);
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var Error = global.Error;
	var push = [].push;
	var $AggregateError = function AggregateError(errors, message) {
	 var options = arguments.length > 2 ? arguments[2] : undefined;
	 var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
	 var that;
	 if (setPrototypeOf) {
	  that = setPrototypeOf(new Error(undefined), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
	 } else {
	  that = isInstance ? this : create(AggregateErrorPrototype);
	  createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
	 }
	 createNonEnumerableProperty(that, 'message', normalizeStringArgument(message, ''));
	 if (ERROR_STACK_INSTALLABLE)
	  createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
	 installErrorCause(that, options);
	 var errorsArray = [];
	 iterate(errors, push, { that: errorsArray });
	 createNonEnumerableProperty(that, 'errors', errorsArray);
	 return that;
	};
	if (setPrototypeOf)
	 setPrototypeOf($AggregateError, Error);
	else
	 copyConstructorProperties($AggregateError, Error);
	var AggregateErrorPrototype = $AggregateError.prototype = create(Error.prototype, {
	 constructor: createPropertyDescriptor(1, $AggregateError),
	 message: createPropertyDescriptor(1, ''),
	 name: createPropertyDescriptor(1, 'AggregateError')
	});
	$({ global: true }, { AggregateError: $AggregateError });

	/***/ }),
	/* 99 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var arraySlice = __w_pdfjs_require__(100);
	var replace = uncurryThis(''.replace);
	var split = uncurryThis(''.split);
	var join = uncurryThis([].join);
	var TEST = function (arg) {
	 return String(Error(arg).stack);
	}('zxcasd');
	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
	var IS_FIREFOX_OR_SAFARI_STACK = /@[^\n]*\n/.test(TEST) && !/zxcasd/.test(TEST);
	module.exports = function (stack, dropEntries) {
	 if (typeof stack != 'string')
	  return stack;
	 if (IS_V8_OR_CHAKRA_STACK) {
	  while (dropEntries--)
	   stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
	 } else if (IS_FIREFOX_OR_SAFARI_STACK) {
	  return join(arraySlice(split(stack, '\n'), dropEntries), '\n');
	 }
	 return stack;
	};

	/***/ }),
	/* 100 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var toAbsoluteIndex = __w_pdfjs_require__(62);
	var lengthOfArrayLike = __w_pdfjs_require__(64);
	var createProperty = __w_pdfjs_require__(95);
	var Array = global.Array;
	var max = Math.max;
	module.exports = function (O, start, end) {
	 var length = lengthOfArrayLike(O);
	 var k = toAbsoluteIndex(start, length);
	 var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	 var result = Array(max(fin - k, 0));
	 for (var n = 0; k < fin; k++, n++)
	  createProperty(result, n, O[k]);
	 result.length = n;
	 return result;
	};

	/***/ }),
	/* 101 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var isObject = __w_pdfjs_require__(24);
	var createNonEnumerableProperty = __w_pdfjs_require__(47);
	module.exports = function (O, options) {
	 if (isObject(options) && 'cause' in options) {
	  createNonEnumerableProperty(O, 'cause', options.cause);
	 }
	};

	/***/ }),
	/* 102 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var toString = __w_pdfjs_require__(103);
	module.exports = function (argument, $default) {
	 return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
	};

	/***/ }),
	/* 103 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var classof = __w_pdfjs_require__(92);
	var String = global.String;
	module.exports = function (argument) {
	 if (classof(argument) === 'Symbol')
	  throw TypeError('Cannot convert a Symbol value to a string');
	 return String(argument);
	};

	/***/ }),
	/* 104 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var fails = __w_pdfjs_require__(13);
	var createPropertyDescriptor = __w_pdfjs_require__(16);
	module.exports = !fails(function () {
	 var error = Error('a');
	 if (!('stack' in error))
	  return true;
	 Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
	 return error.stack !== 7;
	});

	/***/ }),
	/* 105 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(93);
	var redefine = __w_pdfjs_require__(50);
	var toString = __w_pdfjs_require__(106);
	if (!TO_STRING_TAG_SUPPORT) {
	 redefine(Object.prototype, 'toString', toString, { unsafe: true });
	}

	/***/ }),
	/* 106 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(93);
	var classof = __w_pdfjs_require__(92);
	module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
	 return '[object ' + classof(this) + ']';
	};

	/***/ }),
	/* 107 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var IS_PURE = __w_pdfjs_require__(39);
	var global = __w_pdfjs_require__(10);
	var getBuiltIn = __w_pdfjs_require__(27);
	var call = __w_pdfjs_require__(14);
	var NativePromise = __w_pdfjs_require__(108);
	var redefine = __w_pdfjs_require__(50);
	var redefineAll = __w_pdfjs_require__(109);
	var setPrototypeOf = __w_pdfjs_require__(84);
	var setToStringTag = __w_pdfjs_require__(83);
	var setSpecies = __w_pdfjs_require__(110);
	var aCallable = __w_pdfjs_require__(34);
	var isCallable = __w_pdfjs_require__(25);
	var isObject = __w_pdfjs_require__(24);
	var anInstance = __w_pdfjs_require__(111);
	var inspectSource = __w_pdfjs_require__(51);
	var iterate = __w_pdfjs_require__(87);
	var checkCorrectnessOfIteration = __w_pdfjs_require__(112);
	var speciesConstructor = __w_pdfjs_require__(113);
	var task = (__w_pdfjs_require__(116).set);
	var microtask = __w_pdfjs_require__(121);
	var promiseResolve = __w_pdfjs_require__(124);
	var hostReportErrors = __w_pdfjs_require__(126);
	var newPromiseCapabilityModule = __w_pdfjs_require__(125);
	var perform = __w_pdfjs_require__(127);
	var InternalStateModule = __w_pdfjs_require__(52);
	var isForced = __w_pdfjs_require__(68);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var IS_BROWSER = __w_pdfjs_require__(128);
	var IS_NODE = __w_pdfjs_require__(120);
	var V8_VERSION = __w_pdfjs_require__(31);
	var SPECIES = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState = InternalStateModule.getterFor(PROMISE);
	var setInternalState = InternalStateModule.set;
	var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
	var NativePromisePrototype = NativePromise && NativePromise.prototype;
	var PromiseConstructor = NativePromise;
	var PromisePrototype = NativePromisePrototype;
	var TypeError = global.TypeError;
	var document = global.document;
	var process = global.process;
	var newPromiseCapability = newPromiseCapabilityModule.f;
	var newGenericPromiseCapability = newPromiseCapability;
	var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
	var NATIVE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var SUBCLASSING = false;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
	var FORCED = isForced(PROMISE, function () {
	 var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
	 var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
	 if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
	  return true;
	 if (IS_PURE && !PromisePrototype['finally'])
	  return true;
	 if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
	  return false;
	 var promise = new PromiseConstructor(function (resolve) {
	  resolve(1);
	 });
	 var FakePromise = function (exec) {
	  exec(function () {
	  }, function () {
	  });
	 };
	 var constructor = promise.constructor = {};
	 constructor[SPECIES] = FakePromise;
	 SUBCLASSING = promise.then(function () {
	 }) instanceof FakePromise;
	 if (!SUBCLASSING)
	  return true;
	 return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
	});
	var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
	 PromiseConstructor.all(iterable)['catch'](function () {
	 });
	});
	var isThenable = function (it) {
	 var then;
	 return isObject(it) && isCallable(then = it.then) ? then : false;
	};
	var notify = function (state, isReject) {
	 if (state.notified)
	  return;
	 state.notified = true;
	 var chain = state.reactions;
	 microtask(function () {
	  var value = state.value;
	  var ok = state.state == FULFILLED;
	  var index = 0;
	  while (chain.length > index) {
	   var reaction = chain[index++];
	   var handler = ok ? reaction.ok : reaction.fail;
	   var resolve = reaction.resolve;
	   var reject = reaction.reject;
	   var domain = reaction.domain;
	   var result, then, exited;
	   try {
	    if (handler) {
	     if (!ok) {
	      if (state.rejection === UNHANDLED)
	       onHandleUnhandled(state);
	      state.rejection = HANDLED;
	     }
	     if (handler === true)
	      result = value;
	     else {
	      if (domain)
	       domain.enter();
	      result = handler(value);
	      if (domain) {
	       domain.exit();
	       exited = true;
	      }
	     }
	     if (result === reaction.promise) {
	      reject(TypeError('Promise-chain cycle'));
	     } else if (then = isThenable(result)) {
	      call(then, result, resolve, reject);
	     } else
	      resolve(result);
	    } else
	     reject(value);
	   } catch (error) {
	    if (domain && !exited)
	     domain.exit();
	    reject(error);
	   }
	  }
	  state.reactions = [];
	  state.notified = false;
	  if (isReject && !state.rejection)
	   onUnhandled(state);
	 });
	};
	var dispatchEvent = function (name, promise, reason) {
	 var event, handler;
	 if (DISPATCH_EVENT) {
	  event = document.createEvent('Event');
	  event.promise = promise;
	  event.reason = reason;
	  event.initEvent(name, false, true);
	  global.dispatchEvent(event);
	 } else
	  event = {
	   promise: promise,
	   reason: reason
	  };
	 if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name]))
	  handler(event);
	 else if (name === UNHANDLED_REJECTION)
	  hostReportErrors('Unhandled promise rejection', reason);
	};
	var onUnhandled = function (state) {
	 call(task, global, function () {
	  var promise = state.facade;
	  var value = state.value;
	  var IS_UNHANDLED = isUnhandled(state);
	  var result;
	  if (IS_UNHANDLED) {
	   result = perform(function () {
	    if (IS_NODE) {
	     process.emit('unhandledRejection', value, promise);
	    } else
	     dispatchEvent(UNHANDLED_REJECTION, promise, value);
	   });
	   state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
	   if (result.error)
	    throw result.value;
	  }
	 });
	};
	var isUnhandled = function (state) {
	 return state.rejection !== HANDLED && !state.parent;
	};
	var onHandleUnhandled = function (state) {
	 call(task, global, function () {
	  var promise = state.facade;
	  if (IS_NODE) {
	   process.emit('rejectionHandled', promise);
	  } else
	   dispatchEvent(REJECTION_HANDLED, promise, state.value);
	 });
	};
	var bind = function (fn, state, unwrap) {
	 return function (value) {
	  fn(state, value, unwrap);
	 };
	};
	var internalReject = function (state, value, unwrap) {
	 if (state.done)
	  return;
	 state.done = true;
	 if (unwrap)
	  state = unwrap;
	 state.value = value;
	 state.state = REJECTED;
	 notify(state, true);
	};
	var internalResolve = function (state, value, unwrap) {
	 if (state.done)
	  return;
	 state.done = true;
	 if (unwrap)
	  state = unwrap;
	 try {
	  if (state.facade === value)
	   throw TypeError("Promise can't be resolved itself");
	  var then = isThenable(value);
	  if (then) {
	   microtask(function () {
	    var wrapper = { done: false };
	    try {
	     call(then, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
	    } catch (error) {
	     internalReject(wrapper, error, state);
	    }
	   });
	  } else {
	   state.value = value;
	   state.state = FULFILLED;
	   notify(state, false);
	  }
	 } catch (error) {
	  internalReject({ done: false }, error, state);
	 }
	};
	if (FORCED) {
	 PromiseConstructor = function Promise(executor) {
	  anInstance(this, PromisePrototype);
	  aCallable(executor);
	  call(Internal, this);
	  var state = getInternalState(this);
	  try {
	   executor(bind(internalResolve, state), bind(internalReject, state));
	  } catch (error) {
	   internalReject(state, error);
	  }
	 };
	 PromisePrototype = PromiseConstructor.prototype;
	 Internal = function Promise(executor) {
	  setInternalState(this, {
	   type: PROMISE,
	   done: false,
	   notified: false,
	   parent: false,
	   reactions: [],
	   rejection: false,
	   state: PENDING,
	   value: undefined
	  });
	 };
	 Internal.prototype = redefineAll(PromisePrototype, {
	  then: function then(onFulfilled, onRejected) {
	   var state = getInternalPromiseState(this);
	   var reactions = state.reactions;
	   var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
	   reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
	   reaction.fail = isCallable(onRejected) && onRejected;
	   reaction.domain = IS_NODE ? process.domain : undefined;
	   state.parent = true;
	   reactions[reactions.length] = reaction;
	   if (state.state != PENDING)
	    notify(state, false);
	   return reaction.promise;
	  },
	  'catch': function (onRejected) {
	   return this.then(undefined, onRejected);
	  }
	 });
	 OwnPromiseCapability = function () {
	  var promise = new Internal();
	  var state = getInternalState(promise);
	  this.promise = promise;
	  this.resolve = bind(internalResolve, state);
	  this.reject = bind(internalReject, state);
	 };
	 newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	  return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
	 };
	 if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
	  nativeThen = NativePromisePrototype.then;
	  if (!SUBCLASSING) {
	   redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
	    var that = this;
	    return new PromiseConstructor(function (resolve, reject) {
	     call(nativeThen, that, resolve, reject);
	    }).then(onFulfilled, onRejected);
	   }, { unsafe: true });
	   redefine(NativePromisePrototype, 'catch', PromisePrototype['catch'], { unsafe: true });
	  }
	  try {
	   delete NativePromisePrototype.constructor;
	  } catch (error) {
	  }
	  if (setPrototypeOf) {
	   setPrototypeOf(NativePromisePrototype, PromisePrototype);
	  }
	 }
	}
	$({
	 global: true,
	 wrap: true,
	 forced: FORCED
	}, { Promise: PromiseConstructor });
	setToStringTag(PromiseConstructor, PROMISE, false, true);
	setSpecies(PROMISE);
	PromiseWrapper = getBuiltIn(PROMISE);
	$({
	 target: PROMISE,
	 stat: true,
	 forced: FORCED
	}, {
	 reject: function reject(r) {
	  var capability = newPromiseCapability(this);
	  call(capability.reject, undefined, r);
	  return capability.promise;
	 }
	});
	$({
	 target: PROMISE,
	 stat: true,
	 forced: IS_PURE || FORCED
	}, {
	 resolve: function resolve(x) {
	  return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
	 }
	});
	$({
	 target: PROMISE,
	 stat: true,
	 forced: INCORRECT_ITERATION
	}, {
	 all: function all(iterable) {
	  var C = this;
	  var capability = newPromiseCapability(C);
	  var resolve = capability.resolve;
	  var reject = capability.reject;
	  var result = perform(function () {
	   var $promiseResolve = aCallable(C.resolve);
	   var values = [];
	   var counter = 0;
	   var remaining = 1;
	   iterate(iterable, function (promise) {
	    var index = counter++;
	    var alreadyCalled = false;
	    remaining++;
	    call($promiseResolve, C, promise).then(function (value) {
	     if (alreadyCalled)
	      return;
	     alreadyCalled = true;
	     values[index] = value;
	     --remaining || resolve(values);
	    }, reject);
	   });
	   --remaining || resolve(values);
	  });
	  if (result.error)
	   reject(result.value);
	  return capability.promise;
	 },
	 race: function race(iterable) {
	  var C = this;
	  var capability = newPromiseCapability(C);
	  var reject = capability.reject;
	  var result = perform(function () {
	   var $promiseResolve = aCallable(C.resolve);
	   iterate(iterable, function (promise) {
	    call($promiseResolve, C, promise).then(capability.resolve, reject);
	   });
	  });
	  if (result.error)
	   reject(result.value);
	  return capability.promise;
	 }
	});

	/***/ }),
	/* 108 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	module.exports = global.Promise;

	/***/ }),
	/* 109 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var redefine = __w_pdfjs_require__(50);
	module.exports = function (target, src, options) {
	 for (var key in src)
	  redefine(target, key, src[key], options);
	 return target;
	};

	/***/ }),
	/* 110 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var getBuiltIn = __w_pdfjs_require__(27);
	var definePropertyModule = __w_pdfjs_require__(48);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var DESCRIPTORS = __w_pdfjs_require__(12);
	var SPECIES = wellKnownSymbol('species');
	module.exports = function (CONSTRUCTOR_NAME) {
	 var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	 var defineProperty = definePropertyModule.f;
	 if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
	  defineProperty(Constructor, SPECIES, {
	   configurable: true,
	   get: function () {
	    return this;
	   }
	  });
	 }
	};

	/***/ }),
	/* 111 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isPrototypeOf = __w_pdfjs_require__(28);
	var TypeError = global.TypeError;
	module.exports = function (it, Prototype) {
	 if (isPrototypeOf(Prototype, it))
	  return it;
	 throw TypeError('Incorrect invocation');
	};

	/***/ }),
	/* 112 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var wellKnownSymbol = __w_pdfjs_require__(37);
	var ITERATOR = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;
	try {
	 var called = 0;
	 var iteratorWithReturn = {
	  next: function () {
	   return { done: !!called++ };
	  },
	  'return': function () {
	   SAFE_CLOSING = true;
	  }
	 };
	 iteratorWithReturn[ITERATOR] = function () {
	  return this;
	 };
	 Array.from(iteratorWithReturn, function () {
	  throw 2;
	 });
	} catch (error) {
	}
	module.exports = function (exec, SKIP_CLOSING) {
	 if (!SKIP_CLOSING && !SAFE_CLOSING)
	  return false;
	 var ITERATION_SUPPORT = false;
	 try {
	  var object = {};
	  object[ITERATOR] = function () {
	   return {
	    next: function () {
	     return { done: ITERATION_SUPPORT = true };
	    }
	   };
	  };
	  exec(object);
	 } catch (error) {
	 }
	 return ITERATION_SUPPORT;
	};

	/***/ }),
	/* 113 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var anObject = __w_pdfjs_require__(49);
	var aConstructor = __w_pdfjs_require__(114);
	var wellKnownSymbol = __w_pdfjs_require__(37);
	var SPECIES = wellKnownSymbol('species');
	module.exports = function (O, defaultConstructor) {
	 var C = anObject(O).constructor;
	 var S;
	 return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
	};

	/***/ }),
	/* 114 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var isConstructor = __w_pdfjs_require__(115);
	var tryToString = __w_pdfjs_require__(35);
	var TypeError = global.TypeError;
	module.exports = function (argument) {
	 if (isConstructor(argument))
	  return argument;
	 throw TypeError(tryToString(argument) + ' is not a constructor');
	};

	/***/ }),
	/* 115 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var fails = __w_pdfjs_require__(13);
	var isCallable = __w_pdfjs_require__(25);
	var classof = __w_pdfjs_require__(92);
	var getBuiltIn = __w_pdfjs_require__(27);
	var inspectSource = __w_pdfjs_require__(51);
	var noop = function () {
	};
	var empty = [];
	var construct = getBuiltIn('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec = uncurryThis(constructorRegExp.exec);
	var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
	var isConstructorModern = function (argument) {
	 if (!isCallable(argument))
	  return false;
	 try {
	  construct(noop, empty, argument);
	  return true;
	 } catch (error) {
	  return false;
	 }
	};
	var isConstructorLegacy = function (argument) {
	 if (!isCallable(argument))
	  return false;
	 switch (classof(argument)) {
	 case 'AsyncFunction':
	 case 'GeneratorFunction':
	 case 'AsyncGeneratorFunction':
	  return false;
	 }
	 return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
	};
	module.exports = !construct || fails(function () {
	 var called;
	 return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
	  called = true;
	 }) || called;
	}) ? isConstructorLegacy : isConstructorModern;

	/***/ }),
	/* 116 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var apply = __w_pdfjs_require__(117);
	var bind = __w_pdfjs_require__(88);
	var isCallable = __w_pdfjs_require__(25);
	var hasOwn = __w_pdfjs_require__(42);
	var fails = __w_pdfjs_require__(13);
	var html = __w_pdfjs_require__(76);
	var arraySlice = __w_pdfjs_require__(118);
	var createElement = __w_pdfjs_require__(46);
	var IS_IOS = __w_pdfjs_require__(119);
	var IS_NODE = __w_pdfjs_require__(120);
	var set = global.setImmediate;
	var clear = global.clearImmediate;
	var process = global.process;
	var Dispatch = global.Dispatch;
	var Function = global.Function;
	var MessageChannel = global.MessageChannel;
	var String = global.String;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var location, defer, channel, port;
	try {
	 location = global.location;
	} catch (error) {
	}
	var run = function (id) {
	 if (hasOwn(queue, id)) {
	  var fn = queue[id];
	  delete queue[id];
	  fn();
	 }
	};
	var runner = function (id) {
	 return function () {
	  run(id);
	 };
	};
	var listener = function (event) {
	 run(event.data);
	};
	var post = function (id) {
	 global.postMessage(String(id), location.protocol + '//' + location.host);
	};
	if (!set || !clear) {
	 set = function setImmediate(fn) {
	  var args = arraySlice(arguments, 1);
	  queue[++counter] = function () {
	   apply(isCallable(fn) ? fn : Function(fn), undefined, args);
	  };
	  defer(counter);
	  return counter;
	 };
	 clear = function clearImmediate(id) {
	  delete queue[id];
	 };
	 if (IS_NODE) {
	  defer = function (id) {
	   process.nextTick(runner(id));
	  };
	 } else if (Dispatch && Dispatch.now) {
	  defer = function (id) {
	   Dispatch.now(runner(id));
	  };
	 } else if (MessageChannel && !IS_IOS) {
	  channel = new MessageChannel();
	  port = channel.port2;
	  channel.port1.onmessage = listener;
	  defer = bind(port.postMessage, port);
	 } else if (global.addEventListener && isCallable(global.postMessage) && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) {
	  defer = post;
	  global.addEventListener('message', listener, false);
	 } else if (ONREADYSTATECHANGE in createElement('script')) {
	  defer = function (id) {
	   html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
	    html.removeChild(this);
	    run(id);
	   };
	  };
	 } else {
	  defer = function (id) {
	   setTimeout(runner(id), 0);
	  };
	 }
	}
	module.exports = {
	 set: set,
	 clear: clear
	};

	/***/ }),
	/* 117 */
	/***/ ((module) => {

	var FunctionPrototype = Function.prototype;
	var apply = FunctionPrototype.apply;
	var bind = FunctionPrototype.bind;
	var call = FunctionPrototype.call;
	module.exports = typeof Reflect == 'object' && Reflect.apply || (bind ? call.bind(apply) : function () {
	 return call.apply(apply, arguments);
	});

	/***/ }),
	/* 118 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	module.exports = uncurryThis([].slice);

	/***/ }),
	/* 119 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var userAgent = __w_pdfjs_require__(32);
	module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

	/***/ }),
	/* 120 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var classof = __w_pdfjs_require__(20);
	var global = __w_pdfjs_require__(10);
	module.exports = classof(global.process) == 'process';

	/***/ }),
	/* 121 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	var bind = __w_pdfjs_require__(88);
	var getOwnPropertyDescriptor = (__w_pdfjs_require__(11).f);
	var macrotask = (__w_pdfjs_require__(116).set);
	var IS_IOS = __w_pdfjs_require__(119);
	var IS_IOS_PEBBLE = __w_pdfjs_require__(122);
	var IS_WEBOS_WEBKIT = __w_pdfjs_require__(123);
	var IS_NODE = __w_pdfjs_require__(120);
	var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
	var document = global.document;
	var process = global.process;
	var Promise = global.Promise;
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
	var flush, head, last, notify, toggle, node, promise, then;
	if (!queueMicrotask) {
	 flush = function () {
	  var parent, fn;
	  if (IS_NODE && (parent = process.domain))
	   parent.exit();
	  while (head) {
	   fn = head.fn;
	   head = head.next;
	   try {
	    fn();
	   } catch (error) {
	    if (head)
	     notify();
	    else
	     last = undefined;
	    throw error;
	   }
	  }
	  last = undefined;
	  if (parent)
	   parent.enter();
	 };
	 if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
	  toggle = true;
	  node = document.createTextNode('');
	  new MutationObserver(flush).observe(node, { characterData: true });
	  notify = function () {
	   node.data = toggle = !toggle;
	  };
	 } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
	  promise = Promise.resolve(undefined);
	  promise.constructor = Promise;
	  then = bind(promise.then, promise);
	  notify = function () {
	   then(flush);
	  };
	 } else if (IS_NODE) {
	  notify = function () {
	   process.nextTick(flush);
	  };
	 } else {
	  macrotask = bind(macrotask, global);
	  notify = function () {
	   macrotask(flush);
	  };
	 }
	}
	module.exports = queueMicrotask || function (fn) {
	 var task = {
	  fn: fn,
	  next: undefined
	 };
	 if (last)
	  last.next = task;
	 if (!head) {
	  head = task;
	  notify();
	 }
	 last = task;
	};

	/***/ }),
	/* 122 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var userAgent = __w_pdfjs_require__(32);
	var global = __w_pdfjs_require__(10);
	module.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== undefined;

	/***/ }),
	/* 123 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var userAgent = __w_pdfjs_require__(32);
	module.exports = /web0s(?!.*chrome)/i.test(userAgent);

	/***/ }),
	/* 124 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var anObject = __w_pdfjs_require__(49);
	var isObject = __w_pdfjs_require__(24);
	var newPromiseCapability = __w_pdfjs_require__(125);
	module.exports = function (C, x) {
	 anObject(C);
	 if (isObject(x) && x.constructor === C)
	  return x;
	 var promiseCapability = newPromiseCapability.f(C);
	 var resolve = promiseCapability.resolve;
	 resolve(x);
	 return promiseCapability.promise;
	};

	/***/ }),
	/* 125 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var aCallable = __w_pdfjs_require__(34);
	var PromiseCapability = function (C) {
	 var resolve, reject;
	 this.promise = new C(function ($$resolve, $$reject) {
	  if (resolve !== undefined || reject !== undefined)
	   throw TypeError('Bad Promise constructor');
	  resolve = $$resolve;
	  reject = $$reject;
	 });
	 this.resolve = aCallable(resolve);
	 this.reject = aCallable(reject);
	};
	module.exports.f = function (C) {
	 return new PromiseCapability(C);
	};

	/***/ }),
	/* 126 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var global = __w_pdfjs_require__(10);
	module.exports = function (a, b) {
	 var console = global.console;
	 if (console && console.error) {
	  arguments.length == 1 ? console.error(a) : console.error(a, b);
	 }
	};

	/***/ }),
	/* 127 */
	/***/ ((module) => {

	module.exports = function (exec) {
	 try {
	  return {
	   error: false,
	   value: exec()
	  };
	 } catch (error) {
	  return {
	   error: true,
	   value: error
	  };
	 }
	};

	/***/ }),
	/* 128 */
	/***/ ((module) => {

	module.exports = typeof window == 'object';

	/***/ }),
	/* 129 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var call = __w_pdfjs_require__(14);
	var aCallable = __w_pdfjs_require__(34);
	var newPromiseCapabilityModule = __w_pdfjs_require__(125);
	var perform = __w_pdfjs_require__(127);
	var iterate = __w_pdfjs_require__(87);
	$({
	 target: 'Promise',
	 stat: true
	}, {
	 allSettled: function allSettled(iterable) {
	  var C = this;
	  var capability = newPromiseCapabilityModule.f(C);
	  var resolve = capability.resolve;
	  var reject = capability.reject;
	  var result = perform(function () {
	   var promiseResolve = aCallable(C.resolve);
	   var values = [];
	   var counter = 0;
	   var remaining = 1;
	   iterate(iterable, function (promise) {
	    var index = counter++;
	    var alreadyCalled = false;
	    remaining++;
	    call(promiseResolve, C, promise).then(function (value) {
	     if (alreadyCalled)
	      return;
	     alreadyCalled = true;
	     values[index] = {
	      status: 'fulfilled',
	      value: value
	     };
	     --remaining || resolve(values);
	    }, function (error) {
	     if (alreadyCalled)
	      return;
	     alreadyCalled = true;
	     values[index] = {
	      status: 'rejected',
	      reason: error
	     };
	     --remaining || resolve(values);
	    });
	   });
	   --remaining || resolve(values);
	  });
	  if (result.error)
	   reject(result.value);
	  return capability.promise;
	 }
	});

	/***/ }),
	/* 130 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var aCallable = __w_pdfjs_require__(34);
	var getBuiltIn = __w_pdfjs_require__(27);
	var call = __w_pdfjs_require__(14);
	var newPromiseCapabilityModule = __w_pdfjs_require__(125);
	var perform = __w_pdfjs_require__(127);
	var iterate = __w_pdfjs_require__(87);
	var PROMISE_ANY_ERROR = 'No one promise resolved';
	$({
	 target: 'Promise',
	 stat: true
	}, {
	 any: function any(iterable) {
	  var C = this;
	  var AggregateError = getBuiltIn('AggregateError');
	  var capability = newPromiseCapabilityModule.f(C);
	  var resolve = capability.resolve;
	  var reject = capability.reject;
	  var result = perform(function () {
	   var promiseResolve = aCallable(C.resolve);
	   var errors = [];
	   var counter = 0;
	   var remaining = 1;
	   var alreadyResolved = false;
	   iterate(iterable, function (promise) {
	    var index = counter++;
	    var alreadyRejected = false;
	    remaining++;
	    call(promiseResolve, C, promise).then(function (value) {
	     if (alreadyRejected || alreadyResolved)
	      return;
	     alreadyResolved = true;
	     resolve(value);
	    }, function (error) {
	     if (alreadyRejected || alreadyResolved)
	      return;
	     alreadyRejected = true;
	     errors[index] = error;
	     --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	    });
	   });
	   --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	  });
	  if (result.error)
	   reject(result.value);
	  return capability.promise;
	 }
	});

	/***/ }),
	/* 131 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var $ = __w_pdfjs_require__(9);
	var IS_PURE = __w_pdfjs_require__(39);
	var NativePromise = __w_pdfjs_require__(108);
	var fails = __w_pdfjs_require__(13);
	var getBuiltIn = __w_pdfjs_require__(27);
	var isCallable = __w_pdfjs_require__(25);
	var speciesConstructor = __w_pdfjs_require__(113);
	var promiseResolve = __w_pdfjs_require__(124);
	var redefine = __w_pdfjs_require__(50);
	var NON_GENERIC = !!NativePromise && fails(function () {
	 NativePromise.prototype['finally'].call({
	  then: function () {
	  }
	 }, function () {
	 });
	});
	$({
	 target: 'Promise',
	 proto: true,
	 real: true,
	 forced: NON_GENERIC
	}, {
	 'finally': function (onFinally) {
	  var C = speciesConstructor(this, getBuiltIn('Promise'));
	  var isFunction = isCallable(onFinally);
	  return this.then(isFunction ? function (x) {
	   return promiseResolve(C, onFinally()).then(function () {
	    return x;
	   });
	  } : onFinally, isFunction ? function (e) {
	   return promiseResolve(C, onFinally()).then(function () {
	    throw e;
	   });
	  } : onFinally);
	 }
	});
	if (!IS_PURE && isCallable(NativePromise)) {
	 var method = getBuiltIn('Promise').prototype['finally'];
	 if (NativePromise.prototype['finally'] !== method) {
	  redefine(NativePromise.prototype, 'finally', method, { unsafe: true });
	 }
	}

	/***/ }),
	/* 132 */
	/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var charAt = (__w_pdfjs_require__(133).charAt);
	var toString = __w_pdfjs_require__(103);
	var InternalStateModule = __w_pdfjs_require__(52);
	var defineIterator = __w_pdfjs_require__(78);
	var STRING_ITERATOR = 'String Iterator';
	var setInternalState = InternalStateModule.set;
	var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
	defineIterator(String, 'String', function (iterated) {
	 setInternalState(this, {
	  type: STRING_ITERATOR,
	  string: toString(iterated),
	  index: 0
	 });
	}, function next() {
	 var state = getInternalState(this);
	 var string = state.string;
	 var index = state.index;
	 var point;
	 if (index >= string.length)
	  return {
	   value: undefined,
	   done: true
	  };
	 point = charAt(string, index);
	 state.index += point.length;
	 return {
	  value: point,
	  done: false
	 };
	});

	/***/ }),
	/* 133 */
	/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

	var uncurryThis = __w_pdfjs_require__(19);
	var toIntegerOrInfinity = __w_pdfjs_require__(63);
	var toString = __w_pdfjs_require__(103);
	var requireObjectCoercible = __w_pdfjs_require__(21);
	var charAt = uncurryThis(''.charAt);
	var charCodeAt = uncurryThis(''.charCodeAt);
	var stringSlice = uncurryThis(''.slice);
	var createMethod = function (CONVERT_TO_STRING) {
	 return function ($this, pos) {
	  var S = toString(requireObjectCoercible($this));
	  var position = toIntegerOrInfinity(pos);
	  var size = S.length;
	  var first, second;
	  if (position < 0 || position >= size)
	   return CONVERT_TO_STRING ? '' : undefined;
	  first = charCodeAt(S, position);
	  return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	 };
	};
	module.exports = {
	 codeAt: createMethod(false),
	 charAt: createMethod(true)
	};

	/***/ }),
	/* 134 */
	/***/ (function(__unused_webpack_module, exports) {

	(function (global, factory) {
	  factory(exports) ;
	}(this, function (exports) {
	 var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {
	  return "Symbol(" + description + ")";
	 };
	 function noop() {
	  return undefined;
	 }
	 function getGlobals() {
	  if (typeof self !== 'undefined') {
	   return self;
	  } else if (typeof window !== 'undefined') {
	   return window;
	  } else if (typeof commonjsGlobal !== 'undefined') {
	   return commonjsGlobal;
	  }
	  return undefined;
	 }
	 var globals = getGlobals();
	 function typeIsObject(x) {
	  return typeof x === 'object' && x !== null || typeof x === 'function';
	 }
	 var rethrowAssertionErrorRejection = noop;
	 var originalPromise = Promise;
	 var originalPromiseThen = Promise.prototype.then;
	 var originalPromiseResolve = Promise.resolve.bind(originalPromise);
	 var originalPromiseReject = Promise.reject.bind(originalPromise);
	 function newPromise(executor) {
	  return new originalPromise(executor);
	 }
	 function promiseResolvedWith(value) {
	  return originalPromiseResolve(value);
	 }
	 function promiseRejectedWith(reason) {
	  return originalPromiseReject(reason);
	 }
	 function PerformPromiseThen(promise, onFulfilled, onRejected) {
	  return originalPromiseThen.call(promise, onFulfilled, onRejected);
	 }
	 function uponPromise(promise, onFulfilled, onRejected) {
	  PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
	 }
	 function uponFulfillment(promise, onFulfilled) {
	  uponPromise(promise, onFulfilled);
	 }
	 function uponRejection(promise, onRejected) {
	  uponPromise(promise, undefined, onRejected);
	 }
	 function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
	  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
	 }
	 function setPromiseIsHandledToTrue(promise) {
	  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
	 }
	 var queueMicrotask = (function () {
	  var globalQueueMicrotask = globals && globals.queueMicrotask;
	  if (typeof globalQueueMicrotask === 'function') {
	   return globalQueueMicrotask;
	  }
	  var resolvedPromise = promiseResolvedWith(undefined);
	  return function (fn) {
	   return PerformPromiseThen(resolvedPromise, fn);
	  };
	 }());
	 function reflectCall(F, V, args) {
	  if (typeof F !== 'function') {
	   throw new TypeError('Argument is not a function');
	  }
	  return Function.prototype.apply.call(F, V, args);
	 }
	 function promiseCall(F, V, args) {
	  try {
	   return promiseResolvedWith(reflectCall(F, V, args));
	  } catch (value) {
	   return promiseRejectedWith(value);
	  }
	 }
	 var QUEUE_MAX_ARRAY_SIZE = 16384;
	 var SimpleQueue = (function () {
	  function SimpleQueue() {
	   this._cursor = 0;
	   this._size = 0;
	   this._front = {
	    _elements: [],
	    _next: undefined
	   };
	   this._back = this._front;
	   this._cursor = 0;
	   this._size = 0;
	  }
	  Object.defineProperty(SimpleQueue.prototype, "length", {
	   get: function () {
	    return this._size;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  SimpleQueue.prototype.push = function (element) {
	   var oldBack = this._back;
	   var newBack = oldBack;
	   if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
	    newBack = {
	     _elements: [],
	     _next: undefined
	    };
	   }
	   oldBack._elements.push(element);
	   if (newBack !== oldBack) {
	    this._back = newBack;
	    oldBack._next = newBack;
	   }
	   ++this._size;
	  };
	  SimpleQueue.prototype.shift = function () {
	   var oldFront = this._front;
	   var newFront = oldFront;
	   var oldCursor = this._cursor;
	   var newCursor = oldCursor + 1;
	   var elements = oldFront._elements;
	   var element = elements[oldCursor];
	   if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
	    newFront = oldFront._next;
	    newCursor = 0;
	   }
	   --this._size;
	   this._cursor = newCursor;
	   if (oldFront !== newFront) {
	    this._front = newFront;
	   }
	   elements[oldCursor] = undefined;
	   return element;
	  };
	  SimpleQueue.prototype.forEach = function (callback) {
	   var i = this._cursor;
	   var node = this._front;
	   var elements = node._elements;
	   while (i !== elements.length || node._next !== undefined) {
	    if (i === elements.length) {
	     node = node._next;
	     elements = node._elements;
	     i = 0;
	     if (elements.length === 0) {
	      break;
	     }
	    }
	    callback(elements[i]);
	    ++i;
	   }
	  };
	  SimpleQueue.prototype.peek = function () {
	   var front = this._front;
	   var cursor = this._cursor;
	   return front._elements[cursor];
	  };
	  return SimpleQueue;
	 }());
	 function ReadableStreamReaderGenericInitialize(reader, stream) {
	  reader._ownerReadableStream = stream;
	  stream._reader = reader;
	  if (stream._state === 'readable') {
	   defaultReaderClosedPromiseInitialize(reader);
	  } else if (stream._state === 'closed') {
	   defaultReaderClosedPromiseInitializeAsResolved(reader);
	  } else {
	   defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
	  }
	 }
	 function ReadableStreamReaderGenericCancel(reader, reason) {
	  var stream = reader._ownerReadableStream;
	  return ReadableStreamCancel(stream, reason);
	 }
	 function ReadableStreamReaderGenericRelease(reader) {
	  if (reader._ownerReadableStream._state === 'readable') {
	   defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
	  } else {
	   defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
	  }
	  reader._ownerReadableStream._reader = undefined;
	  reader._ownerReadableStream = undefined;
	 }
	 function readerLockException(name) {
	  return new TypeError('Cannot ' + name + ' a stream using a released reader');
	 }
	 function defaultReaderClosedPromiseInitialize(reader) {
	  reader._closedPromise = newPromise(function (resolve, reject) {
	   reader._closedPromise_resolve = resolve;
	   reader._closedPromise_reject = reject;
	  });
	 }
	 function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
	  defaultReaderClosedPromiseInitialize(reader);
	  defaultReaderClosedPromiseReject(reader, reason);
	 }
	 function defaultReaderClosedPromiseInitializeAsResolved(reader) {
	  defaultReaderClosedPromiseInitialize(reader);
	  defaultReaderClosedPromiseResolve(reader);
	 }
	 function defaultReaderClosedPromiseReject(reader, reason) {
	  if (reader._closedPromise_reject === undefined) {
	   return;
	  }
	  setPromiseIsHandledToTrue(reader._closedPromise);
	  reader._closedPromise_reject(reason);
	  reader._closedPromise_resolve = undefined;
	  reader._closedPromise_reject = undefined;
	 }
	 function defaultReaderClosedPromiseResetToRejected(reader, reason) {
	  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
	 }
	 function defaultReaderClosedPromiseResolve(reader) {
	  if (reader._closedPromise_resolve === undefined) {
	   return;
	  }
	  reader._closedPromise_resolve(undefined);
	  reader._closedPromise_resolve = undefined;
	  reader._closedPromise_reject = undefined;
	 }
	 var AbortSteps = SymbolPolyfill('[[AbortSteps]]');
	 var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
	 var CancelSteps = SymbolPolyfill('[[CancelSteps]]');
	 var PullSteps = SymbolPolyfill('[[PullSteps]]');
	 var NumberIsFinite = Number.isFinite || function (x) {
	  return typeof x === 'number' && isFinite(x);
	 };
	 var MathTrunc = Math.trunc || function (v) {
	  return v < 0 ? Math.ceil(v) : Math.floor(v);
	 };
	 function isDictionary(x) {
	  return typeof x === 'object' || typeof x === 'function';
	 }
	 function assertDictionary(obj, context) {
	  if (obj !== undefined && !isDictionary(obj)) {
	   throw new TypeError(context + " is not an object.");
	  }
	 }
	 function assertFunction(x, context) {
	  if (typeof x !== 'function') {
	   throw new TypeError(context + " is not a function.");
	  }
	 }
	 function isObject(x) {
	  return typeof x === 'object' && x !== null || typeof x === 'function';
	 }
	 function assertObject(x, context) {
	  if (!isObject(x)) {
	   throw new TypeError(context + " is not an object.");
	  }
	 }
	 function assertRequiredArgument(x, position, context) {
	  if (x === undefined) {
	   throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
	  }
	 }
	 function assertRequiredField(x, field, context) {
	  if (x === undefined) {
	   throw new TypeError(field + " is required in '" + context + "'.");
	  }
	 }
	 function convertUnrestrictedDouble(value) {
	  return Number(value);
	 }
	 function censorNegativeZero(x) {
	  return x === 0 ? 0 : x;
	 }
	 function integerPart(x) {
	  return censorNegativeZero(MathTrunc(x));
	 }
	 function convertUnsignedLongLongWithEnforceRange(value, context) {
	  var lowerBound = 0;
	  var upperBound = Number.MAX_SAFE_INTEGER;
	  var x = Number(value);
	  x = censorNegativeZero(x);
	  if (!NumberIsFinite(x)) {
	   throw new TypeError(context + " is not a finite number");
	  }
	  x = integerPart(x);
	  if (x < lowerBound || x > upperBound) {
	   throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
	  }
	  if (!NumberIsFinite(x) || x === 0) {
	   return 0;
	  }
	  return x;
	 }
	 function assertReadableStream(x, context) {
	  if (!IsReadableStream(x)) {
	   throw new TypeError(context + " is not a ReadableStream.");
	  }
	 }
	 function AcquireReadableStreamDefaultReader(stream) {
	  return new ReadableStreamDefaultReader(stream);
	 }
	 function ReadableStreamAddReadRequest(stream, readRequest) {
	  stream._reader._readRequests.push(readRequest);
	 }
	 function ReadableStreamFulfillReadRequest(stream, chunk, done) {
	  var reader = stream._reader;
	  var readRequest = reader._readRequests.shift();
	  if (done) {
	   readRequest._closeSteps();
	  } else {
	   readRequest._chunkSteps(chunk);
	  }
	 }
	 function ReadableStreamGetNumReadRequests(stream) {
	  return stream._reader._readRequests.length;
	 }
	 function ReadableStreamHasDefaultReader(stream) {
	  var reader = stream._reader;
	  if (reader === undefined) {
	   return false;
	  }
	  if (!IsReadableStreamDefaultReader(reader)) {
	   return false;
	  }
	  return true;
	 }
	 var ReadableStreamDefaultReader = (function () {
	  function ReadableStreamDefaultReader(stream) {
	   assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
	   assertReadableStream(stream, 'First parameter');
	   if (IsReadableStreamLocked(stream)) {
	    throw new TypeError('This stream has already been locked for exclusive reading by another reader');
	   }
	   ReadableStreamReaderGenericInitialize(this, stream);
	   this._readRequests = new SimpleQueue();
	  }
	  Object.defineProperty(ReadableStreamDefaultReader.prototype, "closed", {
	   get: function () {
	    if (!IsReadableStreamDefaultReader(this)) {
	     return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
	    }
	    return this._closedPromise;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  ReadableStreamDefaultReader.prototype.cancel = function (reason) {
	   if (reason === void 0) {
	    reason = undefined;
	   }
	   if (!IsReadableStreamDefaultReader(this)) {
	    return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
	   }
	   if (this._ownerReadableStream === undefined) {
	    return promiseRejectedWith(readerLockException('cancel'));
	   }
	   return ReadableStreamReaderGenericCancel(this, reason);
	  };
	  ReadableStreamDefaultReader.prototype.read = function () {
	   if (!IsReadableStreamDefaultReader(this)) {
	    return promiseRejectedWith(defaultReaderBrandCheckException('read'));
	   }
	   if (this._ownerReadableStream === undefined) {
	    return promiseRejectedWith(readerLockException('read from'));
	   }
	   var resolvePromise;
	   var rejectPromise;
	   var promise = newPromise(function (resolve, reject) {
	    resolvePromise = resolve;
	    rejectPromise = reject;
	   });
	   var readRequest = {
	    _chunkSteps: function (chunk) {
	     return resolvePromise({
	      value: chunk,
	      done: false
	     });
	    },
	    _closeSteps: function () {
	     return resolvePromise({
	      value: undefined,
	      done: true
	     });
	    },
	    _errorSteps: function (e) {
	     return rejectPromise(e);
	    }
	   };
	   ReadableStreamDefaultReaderRead(this, readRequest);
	   return promise;
	  };
	  ReadableStreamDefaultReader.prototype.releaseLock = function () {
	   if (!IsReadableStreamDefaultReader(this)) {
	    throw defaultReaderBrandCheckException('releaseLock');
	   }
	   if (this._ownerReadableStream === undefined) {
	    return;
	   }
	   if (this._readRequests.length > 0) {
	    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
	   }
	   ReadableStreamReaderGenericRelease(this);
	  };
	  return ReadableStreamDefaultReader;
	 }());
	 Object.defineProperties(ReadableStreamDefaultReader.prototype, {
	  cancel: { enumerable: true },
	  read: { enumerable: true },
	  releaseLock: { enumerable: true },
	  closed: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ReadableStreamDefaultReader',
	   configurable: true
	  });
	 }
	 function IsReadableStreamDefaultReader(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
	   return false;
	  }
	  return x instanceof ReadableStreamDefaultReader;
	 }
	 function ReadableStreamDefaultReaderRead(reader, readRequest) {
	  var stream = reader._ownerReadableStream;
	  stream._disturbed = true;
	  if (stream._state === 'closed') {
	   readRequest._closeSteps();
	  } else if (stream._state === 'errored') {
	   readRequest._errorSteps(stream._storedError);
	  } else {
	   stream._readableStreamController[PullSteps](readRequest);
	  }
	 }
	 function defaultReaderBrandCheckException(name) {
	  return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
	 }
	 var _a;
	 var AsyncIteratorPrototype;
	 if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
	  AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function () {
	   return this;
	  }, _a);
	  Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
	 }
	 var ReadableStreamAsyncIteratorImpl = (function () {
	  function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {
	   this._ongoingPromise = undefined;
	   this._isFinished = false;
	   this._reader = reader;
	   this._preventCancel = preventCancel;
	  }
	  ReadableStreamAsyncIteratorImpl.prototype.next = function () {
	   var _this = this;
	   var nextSteps = function () {
	    return _this._nextSteps();
	   };
	   this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
	   return this._ongoingPromise;
	  };
	  ReadableStreamAsyncIteratorImpl.prototype.return = function (value) {
	   var _this = this;
	   var returnSteps = function () {
	    return _this._returnSteps(value);
	   };
	   return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
	  };
	  ReadableStreamAsyncIteratorImpl.prototype._nextSteps = function () {
	   var _this = this;
	   if (this._isFinished) {
	    return Promise.resolve({
	     value: undefined,
	     done: true
	    });
	   }
	   var reader = this._reader;
	   if (reader._ownerReadableStream === undefined) {
	    return promiseRejectedWith(readerLockException('iterate'));
	   }
	   var resolvePromise;
	   var rejectPromise;
	   var promise = newPromise(function (resolve, reject) {
	    resolvePromise = resolve;
	    rejectPromise = reject;
	   });
	   var readRequest = {
	    _chunkSteps: function (chunk) {
	     _this._ongoingPromise = undefined;
	     queueMicrotask(function () {
	      return resolvePromise({
	       value: chunk,
	       done: false
	      });
	     });
	    },
	    _closeSteps: function () {
	     _this._ongoingPromise = undefined;
	     _this._isFinished = true;
	     ReadableStreamReaderGenericRelease(reader);
	     resolvePromise({
	      value: undefined,
	      done: true
	     });
	    },
	    _errorSteps: function (reason) {
	     _this._ongoingPromise = undefined;
	     _this._isFinished = true;
	     ReadableStreamReaderGenericRelease(reader);
	     rejectPromise(reason);
	    }
	   };
	   ReadableStreamDefaultReaderRead(reader, readRequest);
	   return promise;
	  };
	  ReadableStreamAsyncIteratorImpl.prototype._returnSteps = function (value) {
	   if (this._isFinished) {
	    return Promise.resolve({
	     value: value,
	     done: true
	    });
	   }
	   this._isFinished = true;
	   var reader = this._reader;
	   if (reader._ownerReadableStream === undefined) {
	    return promiseRejectedWith(readerLockException('finish iterating'));
	   }
	   if (!this._preventCancel) {
	    var result = ReadableStreamReaderGenericCancel(reader, value);
	    ReadableStreamReaderGenericRelease(reader);
	    return transformPromiseWith(result, function () {
	     return {
	      value: value,
	      done: true
	     };
	    });
	   }
	   ReadableStreamReaderGenericRelease(reader);
	   return promiseResolvedWith({
	    value: value,
	    done: true
	   });
	  };
	  return ReadableStreamAsyncIteratorImpl;
	 }());
	 var ReadableStreamAsyncIteratorPrototype = {
	  next: function () {
	   if (!IsReadableStreamAsyncIterator(this)) {
	    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
	   }
	   return this._asyncIteratorImpl.next();
	  },
	  return: function (value) {
	   if (!IsReadableStreamAsyncIterator(this)) {
	    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
	   }
	   return this._asyncIteratorImpl.return(value);
	  }
	 };
	 if (AsyncIteratorPrototype !== undefined) {
	  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
	 }
	 function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
	  var reader = AcquireReadableStreamDefaultReader(stream);
	  var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
	  iterator._asyncIteratorImpl = impl;
	  return iterator;
	 }
	 function IsReadableStreamAsyncIterator(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
	   return false;
	  }
	  try {
	   return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
	  } catch (_a) {
	   return false;
	  }
	 }
	 function streamAsyncIteratorBrandCheckException(name) {
	  return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
	 }
	 var NumberIsNaN = Number.isNaN || function (x) {
	  return x !== x;
	 };
	 function CreateArrayFromList(elements) {
	  return elements.slice();
	 }
	 function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
	  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
	 }
	 function TransferArrayBuffer(O) {
	  return O;
	 }
	 function IsDetachedBuffer(O) {
	  return false;
	 }
	 function ArrayBufferSlice(buffer, begin, end) {
	  if (buffer.slice) {
	   return buffer.slice(begin, end);
	  }
	  var length = end - begin;
	  var slice = new ArrayBuffer(length);
	  CopyDataBlockBytes(slice, 0, buffer, begin, length);
	  return slice;
	 }
	 function IsNonNegativeNumber(v) {
	  if (typeof v !== 'number') {
	   return false;
	  }
	  if (NumberIsNaN(v)) {
	   return false;
	  }
	  if (v < 0) {
	   return false;
	  }
	  return true;
	 }
	 function CloneAsUint8Array(O) {
	  var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
	  return new Uint8Array(buffer);
	 }
	 function DequeueValue(container) {
	  var pair = container._queue.shift();
	  container._queueTotalSize -= pair.size;
	  if (container._queueTotalSize < 0) {
	   container._queueTotalSize = 0;
	  }
	  return pair.value;
	 }
	 function EnqueueValueWithSize(container, value, size) {
	  if (!IsNonNegativeNumber(size) || size === Infinity) {
	   throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
	  }
	  container._queue.push({
	   value: value,
	   size: size
	  });
	  container._queueTotalSize += size;
	 }
	 function PeekQueueValue(container) {
	  var pair = container._queue.peek();
	  return pair.value;
	 }
	 function ResetQueue(container) {
	  container._queue = new SimpleQueue();
	  container._queueTotalSize = 0;
	 }
	 var ReadableStreamBYOBRequest = (function () {
	  function ReadableStreamBYOBRequest() {
	   throw new TypeError('Illegal constructor');
	  }
	  Object.defineProperty(ReadableStreamBYOBRequest.prototype, "view", {
	   get: function () {
	    if (!IsReadableStreamBYOBRequest(this)) {
	     throw byobRequestBrandCheckException('view');
	    }
	    return this._view;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) {
	   if (!IsReadableStreamBYOBRequest(this)) {
	    throw byobRequestBrandCheckException('respond');
	   }
	   assertRequiredArgument(bytesWritten, 1, 'respond');
	   bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
	   if (this._associatedReadableByteStreamController === undefined) {
	    throw new TypeError('This BYOB request has been invalidated');
	   }
	   if (IsDetachedBuffer(this._view.buffer));
	   ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
	  };
	  ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) {
	   if (!IsReadableStreamBYOBRequest(this)) {
	    throw byobRequestBrandCheckException('respondWithNewView');
	   }
	   assertRequiredArgument(view, 1, 'respondWithNewView');
	   if (!ArrayBuffer.isView(view)) {
	    throw new TypeError('You can only respond with array buffer views');
	   }
	   if (this._associatedReadableByteStreamController === undefined) {
	    throw new TypeError('This BYOB request has been invalidated');
	   }
	   if (IsDetachedBuffer(view.buffer));
	   ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
	  };
	  return ReadableStreamBYOBRequest;
	 }());
	 Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
	  respond: { enumerable: true },
	  respondWithNewView: { enumerable: true },
	  view: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ReadableStreamBYOBRequest',
	   configurable: true
	  });
	 }
	 var ReadableByteStreamController = (function () {
	  function ReadableByteStreamController() {
	   throw new TypeError('Illegal constructor');
	  }
	  Object.defineProperty(ReadableByteStreamController.prototype, "byobRequest", {
	   get: function () {
	    if (!IsReadableByteStreamController(this)) {
	     throw byteStreamControllerBrandCheckException('byobRequest');
	    }
	    return ReadableByteStreamControllerGetBYOBRequest(this);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(ReadableByteStreamController.prototype, "desiredSize", {
	   get: function () {
	    if (!IsReadableByteStreamController(this)) {
	     throw byteStreamControllerBrandCheckException('desiredSize');
	    }
	    return ReadableByteStreamControllerGetDesiredSize(this);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  ReadableByteStreamController.prototype.close = function () {
	   if (!IsReadableByteStreamController(this)) {
	    throw byteStreamControllerBrandCheckException('close');
	   }
	   if (this._closeRequested) {
	    throw new TypeError('The stream has already been closed; do not close it again!');
	   }
	   var state = this._controlledReadableByteStream._state;
	   if (state !== 'readable') {
	    throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
	   }
	   ReadableByteStreamControllerClose(this);
	  };
	  ReadableByteStreamController.prototype.enqueue = function (chunk) {
	   if (!IsReadableByteStreamController(this)) {
	    throw byteStreamControllerBrandCheckException('enqueue');
	   }
	   assertRequiredArgument(chunk, 1, 'enqueue');
	   if (!ArrayBuffer.isView(chunk)) {
	    throw new TypeError('chunk must be an array buffer view');
	   }
	   if (chunk.byteLength === 0) {
	    throw new TypeError('chunk must have non-zero byteLength');
	   }
	   if (chunk.buffer.byteLength === 0) {
	    throw new TypeError("chunk's buffer must have non-zero byteLength");
	   }
	   if (this._closeRequested) {
	    throw new TypeError('stream is closed or draining');
	   }
	   var state = this._controlledReadableByteStream._state;
	   if (state !== 'readable') {
	    throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
	   }
	   ReadableByteStreamControllerEnqueue(this, chunk);
	  };
	  ReadableByteStreamController.prototype.error = function (e) {
	   if (e === void 0) {
	    e = undefined;
	   }
	   if (!IsReadableByteStreamController(this)) {
	    throw byteStreamControllerBrandCheckException('error');
	   }
	   ReadableByteStreamControllerError(this, e);
	  };
	  ReadableByteStreamController.prototype[CancelSteps] = function (reason) {
	   ReadableByteStreamControllerClearPendingPullIntos(this);
	   ResetQueue(this);
	   var result = this._cancelAlgorithm(reason);
	   ReadableByteStreamControllerClearAlgorithms(this);
	   return result;
	  };
	  ReadableByteStreamController.prototype[PullSteps] = function (readRequest) {
	   var stream = this._controlledReadableByteStream;
	   if (this._queueTotalSize > 0) {
	    var entry = this._queue.shift();
	    this._queueTotalSize -= entry.byteLength;
	    ReadableByteStreamControllerHandleQueueDrain(this);
	    var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
	    readRequest._chunkSteps(view);
	    return;
	   }
	   var autoAllocateChunkSize = this._autoAllocateChunkSize;
	   if (autoAllocateChunkSize !== undefined) {
	    var buffer = void 0;
	    try {
	     buffer = new ArrayBuffer(autoAllocateChunkSize);
	    } catch (bufferE) {
	     readRequest._errorSteps(bufferE);
	     return;
	    }
	    var pullIntoDescriptor = {
	     buffer: buffer,
	     bufferByteLength: autoAllocateChunkSize,
	     byteOffset: 0,
	     byteLength: autoAllocateChunkSize,
	     bytesFilled: 0,
	     elementSize: 1,
	     viewConstructor: Uint8Array,
	     readerType: 'default'
	    };
	    this._pendingPullIntos.push(pullIntoDescriptor);
	   }
	   ReadableStreamAddReadRequest(stream, readRequest);
	   ReadableByteStreamControllerCallPullIfNeeded(this);
	  };
	  return ReadableByteStreamController;
	 }());
	 Object.defineProperties(ReadableByteStreamController.prototype, {
	  close: { enumerable: true },
	  enqueue: { enumerable: true },
	  error: { enumerable: true },
	  byobRequest: { enumerable: true },
	  desiredSize: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ReadableByteStreamController',
	   configurable: true
	  });
	 }
	 function IsReadableByteStreamController(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
	   return false;
	  }
	  return x instanceof ReadableByteStreamController;
	 }
	 function IsReadableStreamBYOBRequest(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
	   return false;
	  }
	  return x instanceof ReadableStreamBYOBRequest;
	 }
	 function ReadableByteStreamControllerCallPullIfNeeded(controller) {
	  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
	  if (!shouldPull) {
	   return;
	  }
	  if (controller._pulling) {
	   controller._pullAgain = true;
	   return;
	  }
	  controller._pulling = true;
	  var pullPromise = controller._pullAlgorithm();
	  uponPromise(pullPromise, function () {
	   controller._pulling = false;
	   if (controller._pullAgain) {
	    controller._pullAgain = false;
	    ReadableByteStreamControllerCallPullIfNeeded(controller);
	   }
	  }, function (e) {
	   ReadableByteStreamControllerError(controller, e);
	  });
	 }
	 function ReadableByteStreamControllerClearPendingPullIntos(controller) {
	  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
	  controller._pendingPullIntos = new SimpleQueue();
	 }
	 function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
	  var done = false;
	  if (stream._state === 'closed') {
	   done = true;
	  }
	  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
	  if (pullIntoDescriptor.readerType === 'default') {
	   ReadableStreamFulfillReadRequest(stream, filledView, done);
	  } else {
	   ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
	  }
	 }
	 function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
	  var bytesFilled = pullIntoDescriptor.bytesFilled;
	  var elementSize = pullIntoDescriptor.elementSize;
	  return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
	 }
	 function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
	  controller._queue.push({
	   buffer: buffer,
	   byteOffset: byteOffset,
	   byteLength: byteLength
	  });
	  controller._queueTotalSize += byteLength;
	 }
	 function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
	  var elementSize = pullIntoDescriptor.elementSize;
	  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
	  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
	  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
	  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
	  var totalBytesToCopyRemaining = maxBytesToCopy;
	  var ready = false;
	  if (maxAlignedBytes > currentAlignedBytes) {
	   totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
	   ready = true;
	  }
	  var queue = controller._queue;
	  while (totalBytesToCopyRemaining > 0) {
	   var headOfQueue = queue.peek();
	   var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
	   var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
	   CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
	   if (headOfQueue.byteLength === bytesToCopy) {
	    queue.shift();
	   } else {
	    headOfQueue.byteOffset += bytesToCopy;
	    headOfQueue.byteLength -= bytesToCopy;
	   }
	   controller._queueTotalSize -= bytesToCopy;
	   ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
	   totalBytesToCopyRemaining -= bytesToCopy;
	  }
	  return ready;
	 }
	 function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
	  pullIntoDescriptor.bytesFilled += size;
	 }
	 function ReadableByteStreamControllerHandleQueueDrain(controller) {
	  if (controller._queueTotalSize === 0 && controller._closeRequested) {
	   ReadableByteStreamControllerClearAlgorithms(controller);
	   ReadableStreamClose(controller._controlledReadableByteStream);
	  } else {
	   ReadableByteStreamControllerCallPullIfNeeded(controller);
	  }
	 }
	 function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
	  if (controller._byobRequest === null) {
	   return;
	  }
	  controller._byobRequest._associatedReadableByteStreamController = undefined;
	  controller._byobRequest._view = null;
	  controller._byobRequest = null;
	 }
	 function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
	  while (controller._pendingPullIntos.length > 0) {
	   if (controller._queueTotalSize === 0) {
	    return;
	   }
	   var pullIntoDescriptor = controller._pendingPullIntos.peek();
	   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
	    ReadableByteStreamControllerShiftPendingPullInto(controller);
	    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
	   }
	  }
	 }
	 function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
	  var stream = controller._controlledReadableByteStream;
	  var elementSize = 1;
	  if (view.constructor !== DataView) {
	   elementSize = view.constructor.BYTES_PER_ELEMENT;
	  }
	  var ctor = view.constructor;
	  var buffer = TransferArrayBuffer(view.buffer);
	  var pullIntoDescriptor = {
	   buffer: buffer,
	   bufferByteLength: buffer.byteLength,
	   byteOffset: view.byteOffset,
	   byteLength: view.byteLength,
	   bytesFilled: 0,
	   elementSize: elementSize,
	   viewConstructor: ctor,
	   readerType: 'byob'
	  };
	  if (controller._pendingPullIntos.length > 0) {
	   controller._pendingPullIntos.push(pullIntoDescriptor);
	   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
	   return;
	  }
	  if (stream._state === 'closed') {
	   var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
	   readIntoRequest._closeSteps(emptyView);
	   return;
	  }
	  if (controller._queueTotalSize > 0) {
	   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
	    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
	    ReadableByteStreamControllerHandleQueueDrain(controller);
	    readIntoRequest._chunkSteps(filledView);
	    return;
	   }
	   if (controller._closeRequested) {
	    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
	    ReadableByteStreamControllerError(controller, e);
	    readIntoRequest._errorSteps(e);
	    return;
	   }
	  }
	  controller._pendingPullIntos.push(pullIntoDescriptor);
	  ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
	  ReadableByteStreamControllerCallPullIfNeeded(controller);
	 }
	 function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
	  var stream = controller._controlledReadableByteStream;
	  if (ReadableStreamHasBYOBReader(stream)) {
	   while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
	    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
	    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
	   }
	  }
	 }
	 function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
	  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
	  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
	   return;
	  }
	  ReadableByteStreamControllerShiftPendingPullInto(controller);
	  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
	  if (remainderSize > 0) {
	   var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
	   var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
	   ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
	  }
	  pullIntoDescriptor.bytesFilled -= remainderSize;
	  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
	  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
	 }
	 function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
	  var firstDescriptor = controller._pendingPullIntos.peek();
	  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
	  var state = controller._controlledReadableByteStream._state;
	  if (state === 'closed') {
	   ReadableByteStreamControllerRespondInClosedState(controller);
	  } else {
	   ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
	  }
	  ReadableByteStreamControllerCallPullIfNeeded(controller);
	 }
	 function ReadableByteStreamControllerShiftPendingPullInto(controller) {
	  var descriptor = controller._pendingPullIntos.shift();
	  return descriptor;
	 }
	 function ReadableByteStreamControllerShouldCallPull(controller) {
	  var stream = controller._controlledReadableByteStream;
	  if (stream._state !== 'readable') {
	   return false;
	  }
	  if (controller._closeRequested) {
	   return false;
	  }
	  if (!controller._started) {
	   return false;
	  }
	  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
	   return true;
	  }
	  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
	   return true;
	  }
	  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
	  if (desiredSize > 0) {
	   return true;
	  }
	  return false;
	 }
	 function ReadableByteStreamControllerClearAlgorithms(controller) {
	  controller._pullAlgorithm = undefined;
	  controller._cancelAlgorithm = undefined;
	 }
	 function ReadableByteStreamControllerClose(controller) {
	  var stream = controller._controlledReadableByteStream;
	  if (controller._closeRequested || stream._state !== 'readable') {
	   return;
	  }
	  if (controller._queueTotalSize > 0) {
	   controller._closeRequested = true;
	   return;
	  }
	  if (controller._pendingPullIntos.length > 0) {
	   var firstPendingPullInto = controller._pendingPullIntos.peek();
	   if (firstPendingPullInto.bytesFilled > 0) {
	    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
	    ReadableByteStreamControllerError(controller, e);
	    throw e;
	   }
	  }
	  ReadableByteStreamControllerClearAlgorithms(controller);
	  ReadableStreamClose(stream);
	 }
	 function ReadableByteStreamControllerEnqueue(controller, chunk) {
	  var stream = controller._controlledReadableByteStream;
	  if (controller._closeRequested || stream._state !== 'readable') {
	   return;
	  }
	  var buffer = chunk.buffer;
	  var byteOffset = chunk.byteOffset;
	  var byteLength = chunk.byteLength;
	  var transferredBuffer = TransferArrayBuffer(buffer);
	  if (controller._pendingPullIntos.length > 0) {
	   var firstPendingPullInto = controller._pendingPullIntos.peek();
	   if (IsDetachedBuffer(firstPendingPullInto.buffer));
	   firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
	  }
	  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
	  if (ReadableStreamHasDefaultReader(stream)) {
	   if (ReadableStreamGetNumReadRequests(stream) === 0) {
	    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	   } else {
	    if (controller._pendingPullIntos.length > 0) {
	     ReadableByteStreamControllerShiftPendingPullInto(controller);
	    }
	    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
	    ReadableStreamFulfillReadRequest(stream, transferredView, false);
	   }
	  } else if (ReadableStreamHasBYOBReader(stream)) {
	   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	   ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
	  } else {
	   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	  }
	  ReadableByteStreamControllerCallPullIfNeeded(controller);
	 }
	 function ReadableByteStreamControllerError(controller, e) {
	  var stream = controller._controlledReadableByteStream;
	  if (stream._state !== 'readable') {
	   return;
	  }
	  ReadableByteStreamControllerClearPendingPullIntos(controller);
	  ResetQueue(controller);
	  ReadableByteStreamControllerClearAlgorithms(controller);
	  ReadableStreamError(stream, e);
	 }
	 function ReadableByteStreamControllerGetBYOBRequest(controller) {
	  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
	   var firstDescriptor = controller._pendingPullIntos.peek();
	   var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
	   var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
	   SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
	   controller._byobRequest = byobRequest;
	  }
	  return controller._byobRequest;
	 }
	 function ReadableByteStreamControllerGetDesiredSize(controller) {
	  var state = controller._controlledReadableByteStream._state;
	  if (state === 'errored') {
	   return null;
	  }
	  if (state === 'closed') {
	   return 0;
	  }
	  return controller._strategyHWM - controller._queueTotalSize;
	 }
	 function ReadableByteStreamControllerRespond(controller, bytesWritten) {
	  var firstDescriptor = controller._pendingPullIntos.peek();
	  var state = controller._controlledReadableByteStream._state;
	  if (state === 'closed') {
	   if (bytesWritten !== 0) {
	    throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
	   }
	  } else {
	   if (bytesWritten === 0) {
	    throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
	   }
	   if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
	    throw new RangeError('bytesWritten out of range');
	   }
	  }
	  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
	  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
	 }
	 function ReadableByteStreamControllerRespondWithNewView(controller, view) {
	  var firstDescriptor = controller._pendingPullIntos.peek();
	  var state = controller._controlledReadableByteStream._state;
	  if (state === 'closed') {
	   if (view.byteLength !== 0) {
	    throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
	   }
	  } else {
	   if (view.byteLength === 0) {
	    throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
	   }
	  }
	  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
	   throw new RangeError('The region specified by view does not match byobRequest');
	  }
	  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
	   throw new RangeError('The buffer of view has different capacity than byobRequest');
	  }
	  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
	   throw new RangeError('The region specified by view is larger than byobRequest');
	  }
	  var viewByteLength = view.byteLength;
	  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
	  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
	 }
	 function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
	  controller._controlledReadableByteStream = stream;
	  controller._pullAgain = false;
	  controller._pulling = false;
	  controller._byobRequest = null;
	  controller._queue = controller._queueTotalSize = undefined;
	  ResetQueue(controller);
	  controller._closeRequested = false;
	  controller._started = false;
	  controller._strategyHWM = highWaterMark;
	  controller._pullAlgorithm = pullAlgorithm;
	  controller._cancelAlgorithm = cancelAlgorithm;
	  controller._autoAllocateChunkSize = autoAllocateChunkSize;
	  controller._pendingPullIntos = new SimpleQueue();
	  stream._readableStreamController = controller;
	  var startResult = startAlgorithm();
	  uponPromise(promiseResolvedWith(startResult), function () {
	   controller._started = true;
	   ReadableByteStreamControllerCallPullIfNeeded(controller);
	  }, function (r) {
	   ReadableByteStreamControllerError(controller, r);
	  });
	 }
	 function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
	  var controller = Object.create(ReadableByteStreamController.prototype);
	  var startAlgorithm = function () {
	   return undefined;
	  };
	  var pullAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  var cancelAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  if (underlyingByteSource.start !== undefined) {
	   startAlgorithm = function () {
	    return underlyingByteSource.start(controller);
	   };
	  }
	  if (underlyingByteSource.pull !== undefined) {
	   pullAlgorithm = function () {
	    return underlyingByteSource.pull(controller);
	   };
	  }
	  if (underlyingByteSource.cancel !== undefined) {
	   cancelAlgorithm = function (reason) {
	    return underlyingByteSource.cancel(reason);
	   };
	  }
	  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
	  if (autoAllocateChunkSize === 0) {
	   throw new TypeError('autoAllocateChunkSize must be greater than 0');
	  }
	  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
	 }
	 function SetUpReadableStreamBYOBRequest(request, controller, view) {
	  request._associatedReadableByteStreamController = controller;
	  request._view = view;
	 }
	 function byobRequestBrandCheckException(name) {
	  return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
	 }
	 function byteStreamControllerBrandCheckException(name) {
	  return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
	 }
	 function AcquireReadableStreamBYOBReader(stream) {
	  return new ReadableStreamBYOBReader(stream);
	 }
	 function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
	  stream._reader._readIntoRequests.push(readIntoRequest);
	 }
	 function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
	  var reader = stream._reader;
	  var readIntoRequest = reader._readIntoRequests.shift();
	  if (done) {
	   readIntoRequest._closeSteps(chunk);
	  } else {
	   readIntoRequest._chunkSteps(chunk);
	  }
	 }
	 function ReadableStreamGetNumReadIntoRequests(stream) {
	  return stream._reader._readIntoRequests.length;
	 }
	 function ReadableStreamHasBYOBReader(stream) {
	  var reader = stream._reader;
	  if (reader === undefined) {
	   return false;
	  }
	  if (!IsReadableStreamBYOBReader(reader)) {
	   return false;
	  }
	  return true;
	 }
	 var ReadableStreamBYOBReader = (function () {
	  function ReadableStreamBYOBReader(stream) {
	   assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
	   assertReadableStream(stream, 'First parameter');
	   if (IsReadableStreamLocked(stream)) {
	    throw new TypeError('This stream has already been locked for exclusive reading by another reader');
	   }
	   if (!IsReadableByteStreamController(stream._readableStreamController)) {
	    throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
	   }
	   ReadableStreamReaderGenericInitialize(this, stream);
	   this._readIntoRequests = new SimpleQueue();
	  }
	  Object.defineProperty(ReadableStreamBYOBReader.prototype, "closed", {
	   get: function () {
	    if (!IsReadableStreamBYOBReader(this)) {
	     return promiseRejectedWith(byobReaderBrandCheckException('closed'));
	    }
	    return this._closedPromise;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  ReadableStreamBYOBReader.prototype.cancel = function (reason) {
	   if (reason === void 0) {
	    reason = undefined;
	   }
	   if (!IsReadableStreamBYOBReader(this)) {
	    return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
	   }
	   if (this._ownerReadableStream === undefined) {
	    return promiseRejectedWith(readerLockException('cancel'));
	   }
	   return ReadableStreamReaderGenericCancel(this, reason);
	  };
	  ReadableStreamBYOBReader.prototype.read = function (view) {
	   if (!IsReadableStreamBYOBReader(this)) {
	    return promiseRejectedWith(byobReaderBrandCheckException('read'));
	   }
	   if (!ArrayBuffer.isView(view)) {
	    return promiseRejectedWith(new TypeError('view must be an array buffer view'));
	   }
	   if (view.byteLength === 0) {
	    return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
	   }
	   if (view.buffer.byteLength === 0) {
	    return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
	   }
	   if (IsDetachedBuffer(view.buffer));
	   if (this._ownerReadableStream === undefined) {
	    return promiseRejectedWith(readerLockException('read from'));
	   }
	   var resolvePromise;
	   var rejectPromise;
	   var promise = newPromise(function (resolve, reject) {
	    resolvePromise = resolve;
	    rejectPromise = reject;
	   });
	   var readIntoRequest = {
	    _chunkSteps: function (chunk) {
	     return resolvePromise({
	      value: chunk,
	      done: false
	     });
	    },
	    _closeSteps: function (chunk) {
	     return resolvePromise({
	      value: chunk,
	      done: true
	     });
	    },
	    _errorSteps: function (e) {
	     return rejectPromise(e);
	    }
	   };
	   ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
	   return promise;
	  };
	  ReadableStreamBYOBReader.prototype.releaseLock = function () {
	   if (!IsReadableStreamBYOBReader(this)) {
	    throw byobReaderBrandCheckException('releaseLock');
	   }
	   if (this._ownerReadableStream === undefined) {
	    return;
	   }
	   if (this._readIntoRequests.length > 0) {
	    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
	   }
	   ReadableStreamReaderGenericRelease(this);
	  };
	  return ReadableStreamBYOBReader;
	 }());
	 Object.defineProperties(ReadableStreamBYOBReader.prototype, {
	  cancel: { enumerable: true },
	  read: { enumerable: true },
	  releaseLock: { enumerable: true },
	  closed: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ReadableStreamBYOBReader',
	   configurable: true
	  });
	 }
	 function IsReadableStreamBYOBReader(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
	   return false;
	  }
	  return x instanceof ReadableStreamBYOBReader;
	 }
	 function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
	  var stream = reader._ownerReadableStream;
	  stream._disturbed = true;
	  if (stream._state === 'errored') {
	   readIntoRequest._errorSteps(stream._storedError);
	  } else {
	   ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
	  }
	 }
	 function byobReaderBrandCheckException(name) {
	  return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
	 }
	 function ExtractHighWaterMark(strategy, defaultHWM) {
	  var highWaterMark = strategy.highWaterMark;
	  if (highWaterMark === undefined) {
	   return defaultHWM;
	  }
	  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
	   throw new RangeError('Invalid highWaterMark');
	  }
	  return highWaterMark;
	 }
	 function ExtractSizeAlgorithm(strategy) {
	  var size = strategy.size;
	  if (!size) {
	   return function () {
	    return 1;
	   };
	  }
	  return size;
	 }
	 function convertQueuingStrategy(init, context) {
	  assertDictionary(init, context);
	  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
	  var size = init === null || init === void 0 ? void 0 : init.size;
	  return {
	   highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
	   size: size === undefined ? undefined : convertQueuingStrategySize(size, context + " has member 'size' that")
	  };
	 }
	 function convertQueuingStrategySize(fn, context) {
	  assertFunction(fn, context);
	  return function (chunk) {
	   return convertUnrestrictedDouble(fn(chunk));
	  };
	 }
	 function convertUnderlyingSink(original, context) {
	  assertDictionary(original, context);
	  var abort = original === null || original === void 0 ? void 0 : original.abort;
	  var close = original === null || original === void 0 ? void 0 : original.close;
	  var start = original === null || original === void 0 ? void 0 : original.start;
	  var type = original === null || original === void 0 ? void 0 : original.type;
	  var write = original === null || original === void 0 ? void 0 : original.write;
	  return {
	   abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
	   close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
	   start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
	   write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
	   type: type
	  };
	 }
	 function convertUnderlyingSinkAbortCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (reason) {
	   return promiseCall(fn, original, [reason]);
	  };
	 }
	 function convertUnderlyingSinkCloseCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function () {
	   return promiseCall(fn, original, []);
	  };
	 }
	 function convertUnderlyingSinkStartCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (controller) {
	   return reflectCall(fn, original, [controller]);
	  };
	 }
	 function convertUnderlyingSinkWriteCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (chunk, controller) {
	   return promiseCall(fn, original, [
	    chunk,
	    controller
	   ]);
	  };
	 }
	 function assertWritableStream(x, context) {
	  if (!IsWritableStream(x)) {
	   throw new TypeError(context + " is not a WritableStream.");
	  }
	 }
	 function isAbortSignal(value) {
	  if (typeof value !== 'object' || value === null) {
	   return false;
	  }
	  try {
	   return typeof value.aborted === 'boolean';
	  } catch (_a) {
	   return false;
	  }
	 }
	 var supportsAbortController = typeof AbortController === 'function';
	 function createAbortController() {
	  if (supportsAbortController) {
	   return new AbortController();
	  }
	  return undefined;
	 }
	 var WritableStream = (function () {
	  function WritableStream(rawUnderlyingSink, rawStrategy) {
	   if (rawUnderlyingSink === void 0) {
	    rawUnderlyingSink = {};
	   }
	   if (rawStrategy === void 0) {
	    rawStrategy = {};
	   }
	   if (rawUnderlyingSink === undefined) {
	    rawUnderlyingSink = null;
	   } else {
	    assertObject(rawUnderlyingSink, 'First parameter');
	   }
	   var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
	   var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
	   InitializeWritableStream(this);
	   var type = underlyingSink.type;
	   if (type !== undefined) {
	    throw new RangeError('Invalid type is specified');
	   }
	   var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
	   var highWaterMark = ExtractHighWaterMark(strategy, 1);
	   SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
	  }
	  Object.defineProperty(WritableStream.prototype, "locked", {
	   get: function () {
	    if (!IsWritableStream(this)) {
	     throw streamBrandCheckException$2('locked');
	    }
	    return IsWritableStreamLocked(this);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  WritableStream.prototype.abort = function (reason) {
	   if (reason === void 0) {
	    reason = undefined;
	   }
	   if (!IsWritableStream(this)) {
	    return promiseRejectedWith(streamBrandCheckException$2('abort'));
	   }
	   if (IsWritableStreamLocked(this)) {
	    return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
	   }
	   return WritableStreamAbort(this, reason);
	  };
	  WritableStream.prototype.close = function () {
	   if (!IsWritableStream(this)) {
	    return promiseRejectedWith(streamBrandCheckException$2('close'));
	   }
	   if (IsWritableStreamLocked(this)) {
	    return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
	   }
	   if (WritableStreamCloseQueuedOrInFlight(this)) {
	    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
	   }
	   return WritableStreamClose(this);
	  };
	  WritableStream.prototype.getWriter = function () {
	   if (!IsWritableStream(this)) {
	    throw streamBrandCheckException$2('getWriter');
	   }
	   return AcquireWritableStreamDefaultWriter(this);
	  };
	  return WritableStream;
	 }());
	 Object.defineProperties(WritableStream.prototype, {
	  abort: { enumerable: true },
	  close: { enumerable: true },
	  getWriter: { enumerable: true },
	  locked: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
	   value: 'WritableStream',
	   configurable: true
	  });
	 }
	 function AcquireWritableStreamDefaultWriter(stream) {
	  return new WritableStreamDefaultWriter(stream);
	 }
	 function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
	  if (highWaterMark === void 0) {
	   highWaterMark = 1;
	  }
	  if (sizeAlgorithm === void 0) {
	   sizeAlgorithm = function () {
	    return 1;
	   };
	  }
	  var stream = Object.create(WritableStream.prototype);
	  InitializeWritableStream(stream);
	  var controller = Object.create(WritableStreamDefaultController.prototype);
	  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
	  return stream;
	 }
	 function InitializeWritableStream(stream) {
	  stream._state = 'writable';
	  stream._storedError = undefined;
	  stream._writer = undefined;
	  stream._writableStreamController = undefined;
	  stream._writeRequests = new SimpleQueue();
	  stream._inFlightWriteRequest = undefined;
	  stream._closeRequest = undefined;
	  stream._inFlightCloseRequest = undefined;
	  stream._pendingAbortRequest = undefined;
	  stream._backpressure = false;
	 }
	 function IsWritableStream(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
	   return false;
	  }
	  return x instanceof WritableStream;
	 }
	 function IsWritableStreamLocked(stream) {
	  if (stream._writer === undefined) {
	   return false;
	  }
	  return true;
	 }
	 function WritableStreamAbort(stream, reason) {
	  var _a;
	  if (stream._state === 'closed' || stream._state === 'errored') {
	   return promiseResolvedWith(undefined);
	  }
	  stream._writableStreamController._abortReason = reason;
	  (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
	  var state = stream._state;
	  if (state === 'closed' || state === 'errored') {
	   return promiseResolvedWith(undefined);
	  }
	  if (stream._pendingAbortRequest !== undefined) {
	   return stream._pendingAbortRequest._promise;
	  }
	  var wasAlreadyErroring = false;
	  if (state === 'erroring') {
	   wasAlreadyErroring = true;
	   reason = undefined;
	  }
	  var promise = newPromise(function (resolve, reject) {
	   stream._pendingAbortRequest = {
	    _promise: undefined,
	    _resolve: resolve,
	    _reject: reject,
	    _reason: reason,
	    _wasAlreadyErroring: wasAlreadyErroring
	   };
	  });
	  stream._pendingAbortRequest._promise = promise;
	  if (!wasAlreadyErroring) {
	   WritableStreamStartErroring(stream, reason);
	  }
	  return promise;
	 }
	 function WritableStreamClose(stream) {
	  var state = stream._state;
	  if (state === 'closed' || state === 'errored') {
	   return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
	  }
	  var promise = newPromise(function (resolve, reject) {
	   var closeRequest = {
	    _resolve: resolve,
	    _reject: reject
	   };
	   stream._closeRequest = closeRequest;
	  });
	  var writer = stream._writer;
	  if (writer !== undefined && stream._backpressure && state === 'writable') {
	   defaultWriterReadyPromiseResolve(writer);
	  }
	  WritableStreamDefaultControllerClose(stream._writableStreamController);
	  return promise;
	 }
	 function WritableStreamAddWriteRequest(stream) {
	  var promise = newPromise(function (resolve, reject) {
	   var writeRequest = {
	    _resolve: resolve,
	    _reject: reject
	   };
	   stream._writeRequests.push(writeRequest);
	  });
	  return promise;
	 }
	 function WritableStreamDealWithRejection(stream, error) {
	  var state = stream._state;
	  if (state === 'writable') {
	   WritableStreamStartErroring(stream, error);
	   return;
	  }
	  WritableStreamFinishErroring(stream);
	 }
	 function WritableStreamStartErroring(stream, reason) {
	  var controller = stream._writableStreamController;
	  stream._state = 'erroring';
	  stream._storedError = reason;
	  var writer = stream._writer;
	  if (writer !== undefined) {
	   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
	  }
	  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
	   WritableStreamFinishErroring(stream);
	  }
	 }
	 function WritableStreamFinishErroring(stream) {
	  stream._state = 'errored';
	  stream._writableStreamController[ErrorSteps]();
	  var storedError = stream._storedError;
	  stream._writeRequests.forEach(function (writeRequest) {
	   writeRequest._reject(storedError);
	  });
	  stream._writeRequests = new SimpleQueue();
	  if (stream._pendingAbortRequest === undefined) {
	   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	   return;
	  }
	  var abortRequest = stream._pendingAbortRequest;
	  stream._pendingAbortRequest = undefined;
	  if (abortRequest._wasAlreadyErroring) {
	   abortRequest._reject(storedError);
	   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	   return;
	  }
	  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
	  uponPromise(promise, function () {
	   abortRequest._resolve();
	   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	  }, function (reason) {
	   abortRequest._reject(reason);
	   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	  });
	 }
	 function WritableStreamFinishInFlightWrite(stream) {
	  stream._inFlightWriteRequest._resolve(undefined);
	  stream._inFlightWriteRequest = undefined;
	 }
	 function WritableStreamFinishInFlightWriteWithError(stream, error) {
	  stream._inFlightWriteRequest._reject(error);
	  stream._inFlightWriteRequest = undefined;
	  WritableStreamDealWithRejection(stream, error);
	 }
	 function WritableStreamFinishInFlightClose(stream) {
	  stream._inFlightCloseRequest._resolve(undefined);
	  stream._inFlightCloseRequest = undefined;
	  var state = stream._state;
	  if (state === 'erroring') {
	   stream._storedError = undefined;
	   if (stream._pendingAbortRequest !== undefined) {
	    stream._pendingAbortRequest._resolve();
	    stream._pendingAbortRequest = undefined;
	   }
	  }
	  stream._state = 'closed';
	  var writer = stream._writer;
	  if (writer !== undefined) {
	   defaultWriterClosedPromiseResolve(writer);
	  }
	 }
	 function WritableStreamFinishInFlightCloseWithError(stream, error) {
	  stream._inFlightCloseRequest._reject(error);
	  stream._inFlightCloseRequest = undefined;
	  if (stream._pendingAbortRequest !== undefined) {
	   stream._pendingAbortRequest._reject(error);
	   stream._pendingAbortRequest = undefined;
	  }
	  WritableStreamDealWithRejection(stream, error);
	 }
	 function WritableStreamCloseQueuedOrInFlight(stream) {
	  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
	   return false;
	  }
	  return true;
	 }
	 function WritableStreamHasOperationMarkedInFlight(stream) {
	  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
	   return false;
	  }
	  return true;
	 }
	 function WritableStreamMarkCloseRequestInFlight(stream) {
	  stream._inFlightCloseRequest = stream._closeRequest;
	  stream._closeRequest = undefined;
	 }
	 function WritableStreamMarkFirstWriteRequestInFlight(stream) {
	  stream._inFlightWriteRequest = stream._writeRequests.shift();
	 }
	 function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
	  if (stream._closeRequest !== undefined) {
	   stream._closeRequest._reject(stream._storedError);
	   stream._closeRequest = undefined;
	  }
	  var writer = stream._writer;
	  if (writer !== undefined) {
	   defaultWriterClosedPromiseReject(writer, stream._storedError);
	  }
	 }
	 function WritableStreamUpdateBackpressure(stream, backpressure) {
	  var writer = stream._writer;
	  if (writer !== undefined && backpressure !== stream._backpressure) {
	   if (backpressure) {
	    defaultWriterReadyPromiseReset(writer);
	   } else {
	    defaultWriterReadyPromiseResolve(writer);
	   }
	  }
	  stream._backpressure = backpressure;
	 }
	 var WritableStreamDefaultWriter = (function () {
	  function WritableStreamDefaultWriter(stream) {
	   assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
	   assertWritableStream(stream, 'First parameter');
	   if (IsWritableStreamLocked(stream)) {
	    throw new TypeError('This stream has already been locked for exclusive writing by another writer');
	   }
	   this._ownerWritableStream = stream;
	   stream._writer = this;
	   var state = stream._state;
	   if (state === 'writable') {
	    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
	     defaultWriterReadyPromiseInitialize(this);
	    } else {
	     defaultWriterReadyPromiseInitializeAsResolved(this);
	    }
	    defaultWriterClosedPromiseInitialize(this);
	   } else if (state === 'erroring') {
	    defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
	    defaultWriterClosedPromiseInitialize(this);
	   } else if (state === 'closed') {
	    defaultWriterReadyPromiseInitializeAsResolved(this);
	    defaultWriterClosedPromiseInitializeAsResolved(this);
	   } else {
	    var storedError = stream._storedError;
	    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
	    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
	   }
	  }
	  Object.defineProperty(WritableStreamDefaultWriter.prototype, "closed", {
	   get: function () {
	    if (!IsWritableStreamDefaultWriter(this)) {
	     return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
	    }
	    return this._closedPromise;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(WritableStreamDefaultWriter.prototype, "desiredSize", {
	   get: function () {
	    if (!IsWritableStreamDefaultWriter(this)) {
	     throw defaultWriterBrandCheckException('desiredSize');
	    }
	    if (this._ownerWritableStream === undefined) {
	     throw defaultWriterLockException('desiredSize');
	    }
	    return WritableStreamDefaultWriterGetDesiredSize(this);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(WritableStreamDefaultWriter.prototype, "ready", {
	   get: function () {
	    if (!IsWritableStreamDefaultWriter(this)) {
	     return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
	    }
	    return this._readyPromise;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  WritableStreamDefaultWriter.prototype.abort = function (reason) {
	   if (reason === void 0) {
	    reason = undefined;
	   }
	   if (!IsWritableStreamDefaultWriter(this)) {
	    return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
	   }
	   if (this._ownerWritableStream === undefined) {
	    return promiseRejectedWith(defaultWriterLockException('abort'));
	   }
	   return WritableStreamDefaultWriterAbort(this, reason);
	  };
	  WritableStreamDefaultWriter.prototype.close = function () {
	   if (!IsWritableStreamDefaultWriter(this)) {
	    return promiseRejectedWith(defaultWriterBrandCheckException('close'));
	   }
	   var stream = this._ownerWritableStream;
	   if (stream === undefined) {
	    return promiseRejectedWith(defaultWriterLockException('close'));
	   }
	   if (WritableStreamCloseQueuedOrInFlight(stream)) {
	    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
	   }
	   return WritableStreamDefaultWriterClose(this);
	  };
	  WritableStreamDefaultWriter.prototype.releaseLock = function () {
	   if (!IsWritableStreamDefaultWriter(this)) {
	    throw defaultWriterBrandCheckException('releaseLock');
	   }
	   var stream = this._ownerWritableStream;
	   if (stream === undefined) {
	    return;
	   }
	   WritableStreamDefaultWriterRelease(this);
	  };
	  WritableStreamDefaultWriter.prototype.write = function (chunk) {
	   if (chunk === void 0) {
	    chunk = undefined;
	   }
	   if (!IsWritableStreamDefaultWriter(this)) {
	    return promiseRejectedWith(defaultWriterBrandCheckException('write'));
	   }
	   if (this._ownerWritableStream === undefined) {
	    return promiseRejectedWith(defaultWriterLockException('write to'));
	   }
	   return WritableStreamDefaultWriterWrite(this, chunk);
	  };
	  return WritableStreamDefaultWriter;
	 }());
	 Object.defineProperties(WritableStreamDefaultWriter.prototype, {
	  abort: { enumerable: true },
	  close: { enumerable: true },
	  releaseLock: { enumerable: true },
	  write: { enumerable: true },
	  closed: { enumerable: true },
	  desiredSize: { enumerable: true },
	  ready: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
	   value: 'WritableStreamDefaultWriter',
	   configurable: true
	  });
	 }
	 function IsWritableStreamDefaultWriter(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
	   return false;
	  }
	  return x instanceof WritableStreamDefaultWriter;
	 }
	 function WritableStreamDefaultWriterAbort(writer, reason) {
	  var stream = writer._ownerWritableStream;
	  return WritableStreamAbort(stream, reason);
	 }
	 function WritableStreamDefaultWriterClose(writer) {
	  var stream = writer._ownerWritableStream;
	  return WritableStreamClose(stream);
	 }
	 function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
	  var stream = writer._ownerWritableStream;
	  var state = stream._state;
	  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
	   return promiseResolvedWith(undefined);
	  }
	  if (state === 'errored') {
	   return promiseRejectedWith(stream._storedError);
	  }
	  return WritableStreamDefaultWriterClose(writer);
	 }
	 function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
	  if (writer._closedPromiseState === 'pending') {
	   defaultWriterClosedPromiseReject(writer, error);
	  } else {
	   defaultWriterClosedPromiseResetToRejected(writer, error);
	  }
	 }
	 function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
	  if (writer._readyPromiseState === 'pending') {
	   defaultWriterReadyPromiseReject(writer, error);
	  } else {
	   defaultWriterReadyPromiseResetToRejected(writer, error);
	  }
	 }
	 function WritableStreamDefaultWriterGetDesiredSize(writer) {
	  var stream = writer._ownerWritableStream;
	  var state = stream._state;
	  if (state === 'errored' || state === 'erroring') {
	   return null;
	  }
	  if (state === 'closed') {
	   return 0;
	  }
	  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
	 }
	 function WritableStreamDefaultWriterRelease(writer) {
	  var stream = writer._ownerWritableStream;
	  var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
	  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
	  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
	  stream._writer = undefined;
	  writer._ownerWritableStream = undefined;
	 }
	 function WritableStreamDefaultWriterWrite(writer, chunk) {
	  var stream = writer._ownerWritableStream;
	  var controller = stream._writableStreamController;
	  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
	  if (stream !== writer._ownerWritableStream) {
	   return promiseRejectedWith(defaultWriterLockException('write to'));
	  }
	  var state = stream._state;
	  if (state === 'errored') {
	   return promiseRejectedWith(stream._storedError);
	  }
	  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
	   return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
	  }
	  if (state === 'erroring') {
	   return promiseRejectedWith(stream._storedError);
	  }
	  var promise = WritableStreamAddWriteRequest(stream);
	  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
	  return promise;
	 }
	 var closeSentinel = {};
	 var WritableStreamDefaultController = (function () {
	  function WritableStreamDefaultController() {
	   throw new TypeError('Illegal constructor');
	  }
	  Object.defineProperty(WritableStreamDefaultController.prototype, "abortReason", {
	   get: function () {
	    if (!IsWritableStreamDefaultController(this)) {
	     throw defaultControllerBrandCheckException$2('abortReason');
	    }
	    return this._abortReason;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(WritableStreamDefaultController.prototype, "signal", {
	   get: function () {
	    if (!IsWritableStreamDefaultController(this)) {
	     throw defaultControllerBrandCheckException$2('signal');
	    }
	    if (this._abortController === undefined) {
	     throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
	    }
	    return this._abortController.signal;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  WritableStreamDefaultController.prototype.error = function (e) {
	   if (e === void 0) {
	    e = undefined;
	   }
	   if (!IsWritableStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException$2('error');
	   }
	   var state = this._controlledWritableStream._state;
	   if (state !== 'writable') {
	    return;
	   }
	   WritableStreamDefaultControllerError(this, e);
	  };
	  WritableStreamDefaultController.prototype[AbortSteps] = function (reason) {
	   var result = this._abortAlgorithm(reason);
	   WritableStreamDefaultControllerClearAlgorithms(this);
	   return result;
	  };
	  WritableStreamDefaultController.prototype[ErrorSteps] = function () {
	   ResetQueue(this);
	  };
	  return WritableStreamDefaultController;
	 }());
	 Object.defineProperties(WritableStreamDefaultController.prototype, {
	  abortReason: { enumerable: true },
	  signal: { enumerable: true },
	  error: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
	   value: 'WritableStreamDefaultController',
	   configurable: true
	  });
	 }
	 function IsWritableStreamDefaultController(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
	   return false;
	  }
	  return x instanceof WritableStreamDefaultController;
	 }
	 function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
	  controller._controlledWritableStream = stream;
	  stream._writableStreamController = controller;
	  controller._queue = undefined;
	  controller._queueTotalSize = undefined;
	  ResetQueue(controller);
	  controller._abortReason = undefined;
	  controller._abortController = createAbortController();
	  controller._started = false;
	  controller._strategySizeAlgorithm = sizeAlgorithm;
	  controller._strategyHWM = highWaterMark;
	  controller._writeAlgorithm = writeAlgorithm;
	  controller._closeAlgorithm = closeAlgorithm;
	  controller._abortAlgorithm = abortAlgorithm;
	  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
	  WritableStreamUpdateBackpressure(stream, backpressure);
	  var startResult = startAlgorithm();
	  var startPromise = promiseResolvedWith(startResult);
	  uponPromise(startPromise, function () {
	   controller._started = true;
	   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	  }, function (r) {
	   controller._started = true;
	   WritableStreamDealWithRejection(stream, r);
	  });
	 }
	 function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
	  var controller = Object.create(WritableStreamDefaultController.prototype);
	  var startAlgorithm = function () {
	   return undefined;
	  };
	  var writeAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  var closeAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  var abortAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  if (underlyingSink.start !== undefined) {
	   startAlgorithm = function () {
	    return underlyingSink.start(controller);
	   };
	  }
	  if (underlyingSink.write !== undefined) {
	   writeAlgorithm = function (chunk) {
	    return underlyingSink.write(chunk, controller);
	   };
	  }
	  if (underlyingSink.close !== undefined) {
	   closeAlgorithm = function () {
	    return underlyingSink.close();
	   };
	  }
	  if (underlyingSink.abort !== undefined) {
	   abortAlgorithm = function (reason) {
	    return underlyingSink.abort(reason);
	   };
	  }
	  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
	 }
	 function WritableStreamDefaultControllerClearAlgorithms(controller) {
	  controller._writeAlgorithm = undefined;
	  controller._closeAlgorithm = undefined;
	  controller._abortAlgorithm = undefined;
	  controller._strategySizeAlgorithm = undefined;
	 }
	 function WritableStreamDefaultControllerClose(controller) {
	  EnqueueValueWithSize(controller, closeSentinel, 0);
	  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	 }
	 function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
	  try {
	   return controller._strategySizeAlgorithm(chunk);
	  } catch (chunkSizeE) {
	   WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
	   return 1;
	  }
	 }
	 function WritableStreamDefaultControllerGetDesiredSize(controller) {
	  return controller._strategyHWM - controller._queueTotalSize;
	 }
	 function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
	  try {
	   EnqueueValueWithSize(controller, chunk, chunkSize);
	  } catch (enqueueE) {
	   WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
	   return;
	  }
	  var stream = controller._controlledWritableStream;
	  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
	   var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
	   WritableStreamUpdateBackpressure(stream, backpressure);
	  }
	  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	 }
	 function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
	  var stream = controller._controlledWritableStream;
	  if (!controller._started) {
	   return;
	  }
	  if (stream._inFlightWriteRequest !== undefined) {
	   return;
	  }
	  var state = stream._state;
	  if (state === 'erroring') {
	   WritableStreamFinishErroring(stream);
	   return;
	  }
	  if (controller._queue.length === 0) {
	   return;
	  }
	  var value = PeekQueueValue(controller);
	  if (value === closeSentinel) {
	   WritableStreamDefaultControllerProcessClose(controller);
	  } else {
	   WritableStreamDefaultControllerProcessWrite(controller, value);
	  }
	 }
	 function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
	  if (controller._controlledWritableStream._state === 'writable') {
	   WritableStreamDefaultControllerError(controller, error);
	  }
	 }
	 function WritableStreamDefaultControllerProcessClose(controller) {
	  var stream = controller._controlledWritableStream;
	  WritableStreamMarkCloseRequestInFlight(stream);
	  DequeueValue(controller);
	  var sinkClosePromise = controller._closeAlgorithm();
	  WritableStreamDefaultControllerClearAlgorithms(controller);
	  uponPromise(sinkClosePromise, function () {
	   WritableStreamFinishInFlightClose(stream);
	  }, function (reason) {
	   WritableStreamFinishInFlightCloseWithError(stream, reason);
	  });
	 }
	 function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
	  var stream = controller._controlledWritableStream;
	  WritableStreamMarkFirstWriteRequestInFlight(stream);
	  var sinkWritePromise = controller._writeAlgorithm(chunk);
	  uponPromise(sinkWritePromise, function () {
	   WritableStreamFinishInFlightWrite(stream);
	   var state = stream._state;
	   DequeueValue(controller);
	   if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
	    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
	    WritableStreamUpdateBackpressure(stream, backpressure);
	   }
	   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	  }, function (reason) {
	   if (stream._state === 'writable') {
	    WritableStreamDefaultControllerClearAlgorithms(controller);
	   }
	   WritableStreamFinishInFlightWriteWithError(stream, reason);
	  });
	 }
	 function WritableStreamDefaultControllerGetBackpressure(controller) {
	  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
	  return desiredSize <= 0;
	 }
	 function WritableStreamDefaultControllerError(controller, error) {
	  var stream = controller._controlledWritableStream;
	  WritableStreamDefaultControllerClearAlgorithms(controller);
	  WritableStreamStartErroring(stream, error);
	 }
	 function streamBrandCheckException$2(name) {
	  return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
	 }
	 function defaultControllerBrandCheckException$2(name) {
	  return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
	 }
	 function defaultWriterBrandCheckException(name) {
	  return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
	 }
	 function defaultWriterLockException(name) {
	  return new TypeError('Cannot ' + name + ' a stream using a released writer');
	 }
	 function defaultWriterClosedPromiseInitialize(writer) {
	  writer._closedPromise = newPromise(function (resolve, reject) {
	   writer._closedPromise_resolve = resolve;
	   writer._closedPromise_reject = reject;
	   writer._closedPromiseState = 'pending';
	  });
	 }
	 function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
	  defaultWriterClosedPromiseInitialize(writer);
	  defaultWriterClosedPromiseReject(writer, reason);
	 }
	 function defaultWriterClosedPromiseInitializeAsResolved(writer) {
	  defaultWriterClosedPromiseInitialize(writer);
	  defaultWriterClosedPromiseResolve(writer);
	 }
	 function defaultWriterClosedPromiseReject(writer, reason) {
	  if (writer._closedPromise_reject === undefined) {
	   return;
	  }
	  setPromiseIsHandledToTrue(writer._closedPromise);
	  writer._closedPromise_reject(reason);
	  writer._closedPromise_resolve = undefined;
	  writer._closedPromise_reject = undefined;
	  writer._closedPromiseState = 'rejected';
	 }
	 function defaultWriterClosedPromiseResetToRejected(writer, reason) {
	  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
	 }
	 function defaultWriterClosedPromiseResolve(writer) {
	  if (writer._closedPromise_resolve === undefined) {
	   return;
	  }
	  writer._closedPromise_resolve(undefined);
	  writer._closedPromise_resolve = undefined;
	  writer._closedPromise_reject = undefined;
	  writer._closedPromiseState = 'resolved';
	 }
	 function defaultWriterReadyPromiseInitialize(writer) {
	  writer._readyPromise = newPromise(function (resolve, reject) {
	   writer._readyPromise_resolve = resolve;
	   writer._readyPromise_reject = reject;
	  });
	  writer._readyPromiseState = 'pending';
	 }
	 function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
	  defaultWriterReadyPromiseInitialize(writer);
	  defaultWriterReadyPromiseReject(writer, reason);
	 }
	 function defaultWriterReadyPromiseInitializeAsResolved(writer) {
	  defaultWriterReadyPromiseInitialize(writer);
	  defaultWriterReadyPromiseResolve(writer);
	 }
	 function defaultWriterReadyPromiseReject(writer, reason) {
	  if (writer._readyPromise_reject === undefined) {
	   return;
	  }
	  setPromiseIsHandledToTrue(writer._readyPromise);
	  writer._readyPromise_reject(reason);
	  writer._readyPromise_resolve = undefined;
	  writer._readyPromise_reject = undefined;
	  writer._readyPromiseState = 'rejected';
	 }
	 function defaultWriterReadyPromiseReset(writer) {
	  defaultWriterReadyPromiseInitialize(writer);
	 }
	 function defaultWriterReadyPromiseResetToRejected(writer, reason) {
	  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
	 }
	 function defaultWriterReadyPromiseResolve(writer) {
	  if (writer._readyPromise_resolve === undefined) {
	   return;
	  }
	  writer._readyPromise_resolve(undefined);
	  writer._readyPromise_resolve = undefined;
	  writer._readyPromise_reject = undefined;
	  writer._readyPromiseState = 'fulfilled';
	 }
	 var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;
	 function isDOMExceptionConstructor(ctor) {
	  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
	   return false;
	  }
	  try {
	   new ctor();
	   return true;
	  } catch (_a) {
	   return false;
	  }
	 }
	 function createDOMExceptionPolyfill() {
	  var ctor = function DOMException(message, name) {
	   this.message = message || '';
	   this.name = name || 'Error';
	   if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	   }
	  };
	  ctor.prototype = Object.create(Error.prototype);
	  Object.defineProperty(ctor.prototype, 'constructor', {
	   value: ctor,
	   writable: true,
	   configurable: true
	  });
	  return ctor;
	 }
	 var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
	 function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
	  var reader = AcquireReadableStreamDefaultReader(source);
	  var writer = AcquireWritableStreamDefaultWriter(dest);
	  source._disturbed = true;
	  var shuttingDown = false;
	  var currentWrite = promiseResolvedWith(undefined);
	  return newPromise(function (resolve, reject) {
	   var abortAlgorithm;
	   if (signal !== undefined) {
	    abortAlgorithm = function () {
	     var error = new DOMException$1('Aborted', 'AbortError');
	     var actions = [];
	     if (!preventAbort) {
	      actions.push(function () {
	       if (dest._state === 'writable') {
	        return WritableStreamAbort(dest, error);
	       }
	       return promiseResolvedWith(undefined);
	      });
	     }
	     if (!preventCancel) {
	      actions.push(function () {
	       if (source._state === 'readable') {
	        return ReadableStreamCancel(source, error);
	       }
	       return promiseResolvedWith(undefined);
	      });
	     }
	     shutdownWithAction(function () {
	      return Promise.all(actions.map(function (action) {
	       return action();
	      }));
	     }, true, error);
	    };
	    if (signal.aborted) {
	     abortAlgorithm();
	     return;
	    }
	    signal.addEventListener('abort', abortAlgorithm);
	   }
	   function pipeLoop() {
	    return newPromise(function (resolveLoop, rejectLoop) {
	     function next(done) {
	      if (done) {
	       resolveLoop();
	      } else {
	       PerformPromiseThen(pipeStep(), next, rejectLoop);
	      }
	     }
	     next(false);
	    });
	   }
	   function pipeStep() {
	    if (shuttingDown) {
	     return promiseResolvedWith(true);
	    }
	    return PerformPromiseThen(writer._readyPromise, function () {
	     return newPromise(function (resolveRead, rejectRead) {
	      ReadableStreamDefaultReaderRead(reader, {
	       _chunkSteps: function (chunk) {
	        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
	        resolveRead(false);
	       },
	       _closeSteps: function () {
	        return resolveRead(true);
	       },
	       _errorSteps: rejectRead
	      });
	     });
	    });
	   }
	   isOrBecomesErrored(source, reader._closedPromise, function (storedError) {
	    if (!preventAbort) {
	     shutdownWithAction(function () {
	      return WritableStreamAbort(dest, storedError);
	     }, true, storedError);
	    } else {
	     shutdown(true, storedError);
	    }
	   });
	   isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
	    if (!preventCancel) {
	     shutdownWithAction(function () {
	      return ReadableStreamCancel(source, storedError);
	     }, true, storedError);
	    } else {
	     shutdown(true, storedError);
	    }
	   });
	   isOrBecomesClosed(source, reader._closedPromise, function () {
	    if (!preventClose) {
	     shutdownWithAction(function () {
	      return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
	     });
	    } else {
	     shutdown();
	    }
	   });
	   if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
	    var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it');
	    if (!preventCancel) {
	     shutdownWithAction(function () {
	      return ReadableStreamCancel(source, destClosed_1);
	     }, true, destClosed_1);
	    } else {
	     shutdown(true, destClosed_1);
	    }
	   }
	   setPromiseIsHandledToTrue(pipeLoop());
	   function waitForWritesToFinish() {
	    var oldCurrentWrite = currentWrite;
	    return PerformPromiseThen(currentWrite, function () {
	     return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
	    });
	   }
	   function isOrBecomesErrored(stream, promise, action) {
	    if (stream._state === 'errored') {
	     action(stream._storedError);
	    } else {
	     uponRejection(promise, action);
	    }
	   }
	   function isOrBecomesClosed(stream, promise, action) {
	    if (stream._state === 'closed') {
	     action();
	    } else {
	     uponFulfillment(promise, action);
	    }
	   }
	   function shutdownWithAction(action, originalIsError, originalError) {
	    if (shuttingDown) {
	     return;
	    }
	    shuttingDown = true;
	    if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
	     uponFulfillment(waitForWritesToFinish(), doTheRest);
	    } else {
	     doTheRest();
	    }
	    function doTheRest() {
	     uponPromise(action(), function () {
	      return finalize(originalIsError, originalError);
	     }, function (newError) {
	      return finalize(true, newError);
	     });
	    }
	   }
	   function shutdown(isError, error) {
	    if (shuttingDown) {
	     return;
	    }
	    shuttingDown = true;
	    if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
	     uponFulfillment(waitForWritesToFinish(), function () {
	      return finalize(isError, error);
	     });
	    } else {
	     finalize(isError, error);
	    }
	   }
	   function finalize(isError, error) {
	    WritableStreamDefaultWriterRelease(writer);
	    ReadableStreamReaderGenericRelease(reader);
	    if (signal !== undefined) {
	     signal.removeEventListener('abort', abortAlgorithm);
	    }
	    if (isError) {
	     reject(error);
	    } else {
	     resolve(undefined);
	    }
	   }
	  });
	 }
	 var ReadableStreamDefaultController = (function () {
	  function ReadableStreamDefaultController() {
	   throw new TypeError('Illegal constructor');
	  }
	  Object.defineProperty(ReadableStreamDefaultController.prototype, "desiredSize", {
	   get: function () {
	    if (!IsReadableStreamDefaultController(this)) {
	     throw defaultControllerBrandCheckException$1('desiredSize');
	    }
	    return ReadableStreamDefaultControllerGetDesiredSize(this);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  ReadableStreamDefaultController.prototype.close = function () {
	   if (!IsReadableStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException$1('close');
	   }
	   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
	    throw new TypeError('The stream is not in a state that permits close');
	   }
	   ReadableStreamDefaultControllerClose(this);
	  };
	  ReadableStreamDefaultController.prototype.enqueue = function (chunk) {
	   if (chunk === void 0) {
	    chunk = undefined;
	   }
	   if (!IsReadableStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException$1('enqueue');
	   }
	   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
	    throw new TypeError('The stream is not in a state that permits enqueue');
	   }
	   return ReadableStreamDefaultControllerEnqueue(this, chunk);
	  };
	  ReadableStreamDefaultController.prototype.error = function (e) {
	   if (e === void 0) {
	    e = undefined;
	   }
	   if (!IsReadableStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException$1('error');
	   }
	   ReadableStreamDefaultControllerError(this, e);
	  };
	  ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) {
	   ResetQueue(this);
	   var result = this._cancelAlgorithm(reason);
	   ReadableStreamDefaultControllerClearAlgorithms(this);
	   return result;
	  };
	  ReadableStreamDefaultController.prototype[PullSteps] = function (readRequest) {
	   var stream = this._controlledReadableStream;
	   if (this._queue.length > 0) {
	    var chunk = DequeueValue(this);
	    if (this._closeRequested && this._queue.length === 0) {
	     ReadableStreamDefaultControllerClearAlgorithms(this);
	     ReadableStreamClose(stream);
	    } else {
	     ReadableStreamDefaultControllerCallPullIfNeeded(this);
	    }
	    readRequest._chunkSteps(chunk);
	   } else {
	    ReadableStreamAddReadRequest(stream, readRequest);
	    ReadableStreamDefaultControllerCallPullIfNeeded(this);
	   }
	  };
	  return ReadableStreamDefaultController;
	 }());
	 Object.defineProperties(ReadableStreamDefaultController.prototype, {
	  close: { enumerable: true },
	  enqueue: { enumerable: true },
	  error: { enumerable: true },
	  desiredSize: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ReadableStreamDefaultController',
	   configurable: true
	  });
	 }
	 function IsReadableStreamDefaultController(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
	   return false;
	  }
	  return x instanceof ReadableStreamDefaultController;
	 }
	 function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
	  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
	  if (!shouldPull) {
	   return;
	  }
	  if (controller._pulling) {
	   controller._pullAgain = true;
	   return;
	  }
	  controller._pulling = true;
	  var pullPromise = controller._pullAlgorithm();
	  uponPromise(pullPromise, function () {
	   controller._pulling = false;
	   if (controller._pullAgain) {
	    controller._pullAgain = false;
	    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
	   }
	  }, function (e) {
	   ReadableStreamDefaultControllerError(controller, e);
	  });
	 }
	 function ReadableStreamDefaultControllerShouldCallPull(controller) {
	  var stream = controller._controlledReadableStream;
	  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
	   return false;
	  }
	  if (!controller._started) {
	   return false;
	  }
	  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
	   return true;
	  }
	  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
	  if (desiredSize > 0) {
	   return true;
	  }
	  return false;
	 }
	 function ReadableStreamDefaultControllerClearAlgorithms(controller) {
	  controller._pullAlgorithm = undefined;
	  controller._cancelAlgorithm = undefined;
	  controller._strategySizeAlgorithm = undefined;
	 }
	 function ReadableStreamDefaultControllerClose(controller) {
	  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
	   return;
	  }
	  var stream = controller._controlledReadableStream;
	  controller._closeRequested = true;
	  if (controller._queue.length === 0) {
	   ReadableStreamDefaultControllerClearAlgorithms(controller);
	   ReadableStreamClose(stream);
	  }
	 }
	 function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
	  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
	   return;
	  }
	  var stream = controller._controlledReadableStream;
	  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
	   ReadableStreamFulfillReadRequest(stream, chunk, false);
	  } else {
	   var chunkSize = void 0;
	   try {
	    chunkSize = controller._strategySizeAlgorithm(chunk);
	   } catch (chunkSizeE) {
	    ReadableStreamDefaultControllerError(controller, chunkSizeE);
	    throw chunkSizeE;
	   }
	   try {
	    EnqueueValueWithSize(controller, chunk, chunkSize);
	   } catch (enqueueE) {
	    ReadableStreamDefaultControllerError(controller, enqueueE);
	    throw enqueueE;
	   }
	  }
	  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
	 }
	 function ReadableStreamDefaultControllerError(controller, e) {
	  var stream = controller._controlledReadableStream;
	  if (stream._state !== 'readable') {
	   return;
	  }
	  ResetQueue(controller);
	  ReadableStreamDefaultControllerClearAlgorithms(controller);
	  ReadableStreamError(stream, e);
	 }
	 function ReadableStreamDefaultControllerGetDesiredSize(controller) {
	  var state = controller._controlledReadableStream._state;
	  if (state === 'errored') {
	   return null;
	  }
	  if (state === 'closed') {
	   return 0;
	  }
	  return controller._strategyHWM - controller._queueTotalSize;
	 }
	 function ReadableStreamDefaultControllerHasBackpressure(controller) {
	  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
	   return false;
	  }
	  return true;
	 }
	 function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
	  var state = controller._controlledReadableStream._state;
	  if (!controller._closeRequested && state === 'readable') {
	   return true;
	  }
	  return false;
	 }
	 function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
	  controller._controlledReadableStream = stream;
	  controller._queue = undefined;
	  controller._queueTotalSize = undefined;
	  ResetQueue(controller);
	  controller._started = false;
	  controller._closeRequested = false;
	  controller._pullAgain = false;
	  controller._pulling = false;
	  controller._strategySizeAlgorithm = sizeAlgorithm;
	  controller._strategyHWM = highWaterMark;
	  controller._pullAlgorithm = pullAlgorithm;
	  controller._cancelAlgorithm = cancelAlgorithm;
	  stream._readableStreamController = controller;
	  var startResult = startAlgorithm();
	  uponPromise(promiseResolvedWith(startResult), function () {
	   controller._started = true;
	   ReadableStreamDefaultControllerCallPullIfNeeded(controller);
	  }, function (r) {
	   ReadableStreamDefaultControllerError(controller, r);
	  });
	 }
	 function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
	  var controller = Object.create(ReadableStreamDefaultController.prototype);
	  var startAlgorithm = function () {
	   return undefined;
	  };
	  var pullAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  var cancelAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  if (underlyingSource.start !== undefined) {
	   startAlgorithm = function () {
	    return underlyingSource.start(controller);
	   };
	  }
	  if (underlyingSource.pull !== undefined) {
	   pullAlgorithm = function () {
	    return underlyingSource.pull(controller);
	   };
	  }
	  if (underlyingSource.cancel !== undefined) {
	   cancelAlgorithm = function (reason) {
	    return underlyingSource.cancel(reason);
	   };
	  }
	  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
	 }
	 function defaultControllerBrandCheckException$1(name) {
	  return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
	 }
	 function ReadableStreamTee(stream, cloneForBranch2) {
	  if (IsReadableByteStreamController(stream._readableStreamController)) {
	   return ReadableByteStreamTee(stream);
	  }
	  return ReadableStreamDefaultTee(stream);
	 }
	 function ReadableStreamDefaultTee(stream, cloneForBranch2) {
	  var reader = AcquireReadableStreamDefaultReader(stream);
	  var reading = false;
	  var readAgain = false;
	  var canceled1 = false;
	  var canceled2 = false;
	  var reason1;
	  var reason2;
	  var branch1;
	  var branch2;
	  var resolveCancelPromise;
	  var cancelPromise = newPromise(function (resolve) {
	   resolveCancelPromise = resolve;
	  });
	  function pullAlgorithm() {
	   if (reading) {
	    readAgain = true;
	    return promiseResolvedWith(undefined);
	   }
	   reading = true;
	   var readRequest = {
	    _chunkSteps: function (chunk) {
	     queueMicrotask(function () {
	      readAgain = false;
	      var chunk1 = chunk;
	      var chunk2 = chunk;
	      if (!canceled1) {
	       ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
	      }
	      if (!canceled2) {
	       ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
	      }
	      reading = false;
	      if (readAgain) {
	       pullAlgorithm();
	      }
	     });
	    },
	    _closeSteps: function () {
	     reading = false;
	     if (!canceled1) {
	      ReadableStreamDefaultControllerClose(branch1._readableStreamController);
	     }
	     if (!canceled2) {
	      ReadableStreamDefaultControllerClose(branch2._readableStreamController);
	     }
	     if (!canceled1 || !canceled2) {
	      resolveCancelPromise(undefined);
	     }
	    },
	    _errorSteps: function () {
	     reading = false;
	    }
	   };
	   ReadableStreamDefaultReaderRead(reader, readRequest);
	   return promiseResolvedWith(undefined);
	  }
	  function cancel1Algorithm(reason) {
	   canceled1 = true;
	   reason1 = reason;
	   if (canceled2) {
	    var compositeReason = CreateArrayFromList([
	     reason1,
	     reason2
	    ]);
	    var cancelResult = ReadableStreamCancel(stream, compositeReason);
	    resolveCancelPromise(cancelResult);
	   }
	   return cancelPromise;
	  }
	  function cancel2Algorithm(reason) {
	   canceled2 = true;
	   reason2 = reason;
	   if (canceled1) {
	    var compositeReason = CreateArrayFromList([
	     reason1,
	     reason2
	    ]);
	    var cancelResult = ReadableStreamCancel(stream, compositeReason);
	    resolveCancelPromise(cancelResult);
	   }
	   return cancelPromise;
	  }
	  function startAlgorithm() {
	  }
	  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
	  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
	  uponRejection(reader._closedPromise, function (r) {
	   ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
	   ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
	   if (!canceled1 || !canceled2) {
	    resolveCancelPromise(undefined);
	   }
	  });
	  return [
	   branch1,
	   branch2
	  ];
	 }
	 function ReadableByteStreamTee(stream) {
	  var reader = AcquireReadableStreamDefaultReader(stream);
	  var reading = false;
	  var readAgainForBranch1 = false;
	  var readAgainForBranch2 = false;
	  var canceled1 = false;
	  var canceled2 = false;
	  var reason1;
	  var reason2;
	  var branch1;
	  var branch2;
	  var resolveCancelPromise;
	  var cancelPromise = newPromise(function (resolve) {
	   resolveCancelPromise = resolve;
	  });
	  function forwardReaderError(thisReader) {
	   uponRejection(thisReader._closedPromise, function (r) {
	    if (thisReader !== reader) {
	     return;
	    }
	    ReadableByteStreamControllerError(branch1._readableStreamController, r);
	    ReadableByteStreamControllerError(branch2._readableStreamController, r);
	    if (!canceled1 || !canceled2) {
	     resolveCancelPromise(undefined);
	    }
	   });
	  }
	  function pullWithDefaultReader() {
	   if (IsReadableStreamBYOBReader(reader)) {
	    ReadableStreamReaderGenericRelease(reader);
	    reader = AcquireReadableStreamDefaultReader(stream);
	    forwardReaderError(reader);
	   }
	   var readRequest = {
	    _chunkSteps: function (chunk) {
	     queueMicrotask(function () {
	      readAgainForBranch1 = false;
	      readAgainForBranch2 = false;
	      var chunk1 = chunk;
	      var chunk2 = chunk;
	      if (!canceled1 && !canceled2) {
	       try {
	        chunk2 = CloneAsUint8Array(chunk);
	       } catch (cloneE) {
	        ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
	        ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
	        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
	        return;
	       }
	      }
	      if (!canceled1) {
	       ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
	      }
	      if (!canceled2) {
	       ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
	      }
	      reading = false;
	      if (readAgainForBranch1) {
	       pull1Algorithm();
	      } else if (readAgainForBranch2) {
	       pull2Algorithm();
	      }
	     });
	    },
	    _closeSteps: function () {
	     reading = false;
	     if (!canceled1) {
	      ReadableByteStreamControllerClose(branch1._readableStreamController);
	     }
	     if (!canceled2) {
	      ReadableByteStreamControllerClose(branch2._readableStreamController);
	     }
	     if (branch1._readableStreamController._pendingPullIntos.length > 0) {
	      ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
	     }
	     if (branch2._readableStreamController._pendingPullIntos.length > 0) {
	      ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
	     }
	     if (!canceled1 || !canceled2) {
	      resolveCancelPromise(undefined);
	     }
	    },
	    _errorSteps: function () {
	     reading = false;
	    }
	   };
	   ReadableStreamDefaultReaderRead(reader, readRequest);
	  }
	  function pullWithBYOBReader(view, forBranch2) {
	   if (IsReadableStreamDefaultReader(reader)) {
	    ReadableStreamReaderGenericRelease(reader);
	    reader = AcquireReadableStreamBYOBReader(stream);
	    forwardReaderError(reader);
	   }
	   var byobBranch = forBranch2 ? branch2 : branch1;
	   var otherBranch = forBranch2 ? branch1 : branch2;
	   var readIntoRequest = {
	    _chunkSteps: function (chunk) {
	     queueMicrotask(function () {
	      readAgainForBranch1 = false;
	      readAgainForBranch2 = false;
	      var byobCanceled = forBranch2 ? canceled2 : canceled1;
	      var otherCanceled = forBranch2 ? canceled1 : canceled2;
	      if (!otherCanceled) {
	       var clonedChunk = void 0;
	       try {
	        clonedChunk = CloneAsUint8Array(chunk);
	       } catch (cloneE) {
	        ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
	        ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
	        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
	        return;
	       }
	       if (!byobCanceled) {
	        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
	       }
	       ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
	      } else if (!byobCanceled) {
	       ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
	      }
	      reading = false;
	      if (readAgainForBranch1) {
	       pull1Algorithm();
	      } else if (readAgainForBranch2) {
	       pull2Algorithm();
	      }
	     });
	    },
	    _closeSteps: function (chunk) {
	     reading = false;
	     var byobCanceled = forBranch2 ? canceled2 : canceled1;
	     var otherCanceled = forBranch2 ? canceled1 : canceled2;
	     if (!byobCanceled) {
	      ReadableByteStreamControllerClose(byobBranch._readableStreamController);
	     }
	     if (!otherCanceled) {
	      ReadableByteStreamControllerClose(otherBranch._readableStreamController);
	     }
	     if (chunk !== undefined) {
	      if (!byobCanceled) {
	       ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
	      }
	      if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
	       ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
	      }
	     }
	     if (!byobCanceled || !otherCanceled) {
	      resolveCancelPromise(undefined);
	     }
	    },
	    _errorSteps: function () {
	     reading = false;
	    }
	   };
	   ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
	  }
	  function pull1Algorithm() {
	   if (reading) {
	    readAgainForBranch1 = true;
	    return promiseResolvedWith(undefined);
	   }
	   reading = true;
	   var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
	   if (byobRequest === null) {
	    pullWithDefaultReader();
	   } else {
	    pullWithBYOBReader(byobRequest._view, false);
	   }
	   return promiseResolvedWith(undefined);
	  }
	  function pull2Algorithm() {
	   if (reading) {
	    readAgainForBranch2 = true;
	    return promiseResolvedWith(undefined);
	   }
	   reading = true;
	   var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
	   if (byobRequest === null) {
	    pullWithDefaultReader();
	   } else {
	    pullWithBYOBReader(byobRequest._view, true);
	   }
	   return promiseResolvedWith(undefined);
	  }
	  function cancel1Algorithm(reason) {
	   canceled1 = true;
	   reason1 = reason;
	   if (canceled2) {
	    var compositeReason = CreateArrayFromList([
	     reason1,
	     reason2
	    ]);
	    var cancelResult = ReadableStreamCancel(stream, compositeReason);
	    resolveCancelPromise(cancelResult);
	   }
	   return cancelPromise;
	  }
	  function cancel2Algorithm(reason) {
	   canceled2 = true;
	   reason2 = reason;
	   if (canceled1) {
	    var compositeReason = CreateArrayFromList([
	     reason1,
	     reason2
	    ]);
	    var cancelResult = ReadableStreamCancel(stream, compositeReason);
	    resolveCancelPromise(cancelResult);
	   }
	   return cancelPromise;
	  }
	  function startAlgorithm() {
	  }
	  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
	  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
	  forwardReaderError(reader);
	  return [
	   branch1,
	   branch2
	  ];
	 }
	 function convertUnderlyingDefaultOrByteSource(source, context) {
	  assertDictionary(source, context);
	  var original = source;
	  var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
	  var cancel = original === null || original === void 0 ? void 0 : original.cancel;
	  var pull = original === null || original === void 0 ? void 0 : original.pull;
	  var start = original === null || original === void 0 ? void 0 : original.start;
	  var type = original === null || original === void 0 ? void 0 : original.type;
	  return {
	   autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
	   cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
	   pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
	   start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
	   type: type === undefined ? undefined : convertReadableStreamType(type, context + " has member 'type' that")
	  };
	 }
	 function convertUnderlyingSourceCancelCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (reason) {
	   return promiseCall(fn, original, [reason]);
	  };
	 }
	 function convertUnderlyingSourcePullCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (controller) {
	   return promiseCall(fn, original, [controller]);
	  };
	 }
	 function convertUnderlyingSourceStartCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (controller) {
	   return reflectCall(fn, original, [controller]);
	  };
	 }
	 function convertReadableStreamType(type, context) {
	  type = "" + type;
	  if (type !== 'bytes') {
	   throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
	  }
	  return type;
	 }
	 function convertReaderOptions(options, context) {
	  assertDictionary(options, context);
	  var mode = options === null || options === void 0 ? void 0 : options.mode;
	  return { mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, context + " has member 'mode' that") };
	 }
	 function convertReadableStreamReaderMode(mode, context) {
	  mode = "" + mode;
	  if (mode !== 'byob') {
	   throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
	  }
	  return mode;
	 }
	 function convertIteratorOptions(options, context) {
	  assertDictionary(options, context);
	  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
	  return { preventCancel: Boolean(preventCancel) };
	 }
	 function convertPipeOptions(options, context) {
	  assertDictionary(options, context);
	  var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
	  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
	  var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
	  var signal = options === null || options === void 0 ? void 0 : options.signal;
	  if (signal !== undefined) {
	   assertAbortSignal(signal, context + " has member 'signal' that");
	  }
	  return {
	   preventAbort: Boolean(preventAbort),
	   preventCancel: Boolean(preventCancel),
	   preventClose: Boolean(preventClose),
	   signal: signal
	  };
	 }
	 function assertAbortSignal(signal, context) {
	  if (!isAbortSignal(signal)) {
	   throw new TypeError(context + " is not an AbortSignal.");
	  }
	 }
	 function convertReadableWritablePair(pair, context) {
	  assertDictionary(pair, context);
	  var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
	  assertRequiredField(readable, 'readable', 'ReadableWritablePair');
	  assertReadableStream(readable, context + " has member 'readable' that");
	  var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
	  assertRequiredField(writable, 'writable', 'ReadableWritablePair');
	  assertWritableStream(writable, context + " has member 'writable' that");
	  return {
	   readable: readable,
	   writable: writable
	  };
	 }
	 var ReadableStream = (function () {
	  function ReadableStream(rawUnderlyingSource, rawStrategy) {
	   if (rawUnderlyingSource === void 0) {
	    rawUnderlyingSource = {};
	   }
	   if (rawStrategy === void 0) {
	    rawStrategy = {};
	   }
	   if (rawUnderlyingSource === undefined) {
	    rawUnderlyingSource = null;
	   } else {
	    assertObject(rawUnderlyingSource, 'First parameter');
	   }
	   var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
	   var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
	   InitializeReadableStream(this);
	   if (underlyingSource.type === 'bytes') {
	    if (strategy.size !== undefined) {
	     throw new RangeError('The strategy for a byte stream cannot have a size function');
	    }
	    var highWaterMark = ExtractHighWaterMark(strategy, 0);
	    SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
	   } else {
	    var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
	    var highWaterMark = ExtractHighWaterMark(strategy, 1);
	    SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
	   }
	  }
	  Object.defineProperty(ReadableStream.prototype, "locked", {
	   get: function () {
	    if (!IsReadableStream(this)) {
	     throw streamBrandCheckException$1('locked');
	    }
	    return IsReadableStreamLocked(this);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  ReadableStream.prototype.cancel = function (reason) {
	   if (reason === void 0) {
	    reason = undefined;
	   }
	   if (!IsReadableStream(this)) {
	    return promiseRejectedWith(streamBrandCheckException$1('cancel'));
	   }
	   if (IsReadableStreamLocked(this)) {
	    return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
	   }
	   return ReadableStreamCancel(this, reason);
	  };
	  ReadableStream.prototype.getReader = function (rawOptions) {
	   if (rawOptions === void 0) {
	    rawOptions = undefined;
	   }
	   if (!IsReadableStream(this)) {
	    throw streamBrandCheckException$1('getReader');
	   }
	   var options = convertReaderOptions(rawOptions, 'First parameter');
	   if (options.mode === undefined) {
	    return AcquireReadableStreamDefaultReader(this);
	   }
	   return AcquireReadableStreamBYOBReader(this);
	  };
	  ReadableStream.prototype.pipeThrough = function (rawTransform, rawOptions) {
	   if (rawOptions === void 0) {
	    rawOptions = {};
	   }
	   if (!IsReadableStream(this)) {
	    throw streamBrandCheckException$1('pipeThrough');
	   }
	   assertRequiredArgument(rawTransform, 1, 'pipeThrough');
	   var transform = convertReadableWritablePair(rawTransform, 'First parameter');
	   var options = convertPipeOptions(rawOptions, 'Second parameter');
	   if (IsReadableStreamLocked(this)) {
	    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
	   }
	   if (IsWritableStreamLocked(transform.writable)) {
	    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
	   }
	   var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
	   setPromiseIsHandledToTrue(promise);
	   return transform.readable;
	  };
	  ReadableStream.prototype.pipeTo = function (destination, rawOptions) {
	   if (rawOptions === void 0) {
	    rawOptions = {};
	   }
	   if (!IsReadableStream(this)) {
	    return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
	   }
	   if (destination === undefined) {
	    return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
	   }
	   if (!IsWritableStream(destination)) {
	    return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
	   }
	   var options;
	   try {
	    options = convertPipeOptions(rawOptions, 'Second parameter');
	   } catch (e) {
	    return promiseRejectedWith(e);
	   }
	   if (IsReadableStreamLocked(this)) {
	    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
	   }
	   if (IsWritableStreamLocked(destination)) {
	    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
	   }
	   return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
	  };
	  ReadableStream.prototype.tee = function () {
	   if (!IsReadableStream(this)) {
	    throw streamBrandCheckException$1('tee');
	   }
	   var branches = ReadableStreamTee(this);
	   return CreateArrayFromList(branches);
	  };
	  ReadableStream.prototype.values = function (rawOptions) {
	   if (rawOptions === void 0) {
	    rawOptions = undefined;
	   }
	   if (!IsReadableStream(this)) {
	    throw streamBrandCheckException$1('values');
	   }
	   var options = convertIteratorOptions(rawOptions, 'First parameter');
	   return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
	  };
	  return ReadableStream;
	 }());
	 Object.defineProperties(ReadableStream.prototype, {
	  cancel: { enumerable: true },
	  getReader: { enumerable: true },
	  pipeThrough: { enumerable: true },
	  pipeTo: { enumerable: true },
	  tee: { enumerable: true },
	  values: { enumerable: true },
	  locked: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ReadableStream',
	   configurable: true
	  });
	 }
	 if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
	  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
	   value: ReadableStream.prototype.values,
	   writable: true,
	   configurable: true
	  });
	 }
	 function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
	  if (highWaterMark === void 0) {
	   highWaterMark = 1;
	  }
	  if (sizeAlgorithm === void 0) {
	   sizeAlgorithm = function () {
	    return 1;
	   };
	  }
	  var stream = Object.create(ReadableStream.prototype);
	  InitializeReadableStream(stream);
	  var controller = Object.create(ReadableStreamDefaultController.prototype);
	  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
	  return stream;
	 }
	 function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
	  var stream = Object.create(ReadableStream.prototype);
	  InitializeReadableStream(stream);
	  var controller = Object.create(ReadableByteStreamController.prototype);
	  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
	  return stream;
	 }
	 function InitializeReadableStream(stream) {
	  stream._state = 'readable';
	  stream._reader = undefined;
	  stream._storedError = undefined;
	  stream._disturbed = false;
	 }
	 function IsReadableStream(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
	   return false;
	  }
	  return x instanceof ReadableStream;
	 }
	 function IsReadableStreamLocked(stream) {
	  if (stream._reader === undefined) {
	   return false;
	  }
	  return true;
	 }
	 function ReadableStreamCancel(stream, reason) {
	  stream._disturbed = true;
	  if (stream._state === 'closed') {
	   return promiseResolvedWith(undefined);
	  }
	  if (stream._state === 'errored') {
	   return promiseRejectedWith(stream._storedError);
	  }
	  ReadableStreamClose(stream);
	  var reader = stream._reader;
	  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
	   reader._readIntoRequests.forEach(function (readIntoRequest) {
	    readIntoRequest._closeSteps(undefined);
	   });
	   reader._readIntoRequests = new SimpleQueue();
	  }
	  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
	  return transformPromiseWith(sourceCancelPromise, noop);
	 }
	 function ReadableStreamClose(stream) {
	  stream._state = 'closed';
	  var reader = stream._reader;
	  if (reader === undefined) {
	   return;
	  }
	  defaultReaderClosedPromiseResolve(reader);
	  if (IsReadableStreamDefaultReader(reader)) {
	   reader._readRequests.forEach(function (readRequest) {
	    readRequest._closeSteps();
	   });
	   reader._readRequests = new SimpleQueue();
	  }
	 }
	 function ReadableStreamError(stream, e) {
	  stream._state = 'errored';
	  stream._storedError = e;
	  var reader = stream._reader;
	  if (reader === undefined) {
	   return;
	  }
	  defaultReaderClosedPromiseReject(reader, e);
	  if (IsReadableStreamDefaultReader(reader)) {
	   reader._readRequests.forEach(function (readRequest) {
	    readRequest._errorSteps(e);
	   });
	   reader._readRequests = new SimpleQueue();
	  } else {
	   reader._readIntoRequests.forEach(function (readIntoRequest) {
	    readIntoRequest._errorSteps(e);
	   });
	   reader._readIntoRequests = new SimpleQueue();
	  }
	 }
	 function streamBrandCheckException$1(name) {
	  return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
	 }
	 function convertQueuingStrategyInit(init, context) {
	  assertDictionary(init, context);
	  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
	  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
	  return { highWaterMark: convertUnrestrictedDouble(highWaterMark) };
	 }
	 var byteLengthSizeFunction = function (chunk) {
	  return chunk.byteLength;
	 };
	 Object.defineProperty(byteLengthSizeFunction, 'name', {
	  value: 'size',
	  configurable: true
	 });
	 var ByteLengthQueuingStrategy = (function () {
	  function ByteLengthQueuingStrategy(options) {
	   assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
	   options = convertQueuingStrategyInit(options, 'First parameter');
	   this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
	  }
	  Object.defineProperty(ByteLengthQueuingStrategy.prototype, "highWaterMark", {
	   get: function () {
	    if (!IsByteLengthQueuingStrategy(this)) {
	     throw byteLengthBrandCheckException('highWaterMark');
	    }
	    return this._byteLengthQueuingStrategyHighWaterMark;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(ByteLengthQueuingStrategy.prototype, "size", {
	   get: function () {
	    if (!IsByteLengthQueuingStrategy(this)) {
	     throw byteLengthBrandCheckException('size');
	    }
	    return byteLengthSizeFunction;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  return ByteLengthQueuingStrategy;
	 }());
	 Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
	  highWaterMark: { enumerable: true },
	  size: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
	   value: 'ByteLengthQueuingStrategy',
	   configurable: true
	  });
	 }
	 function byteLengthBrandCheckException(name) {
	  return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
	 }
	 function IsByteLengthQueuingStrategy(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
	   return false;
	  }
	  return x instanceof ByteLengthQueuingStrategy;
	 }
	 var countSizeFunction = function () {
	  return 1;
	 };
	 Object.defineProperty(countSizeFunction, 'name', {
	  value: 'size',
	  configurable: true
	 });
	 var CountQueuingStrategy = (function () {
	  function CountQueuingStrategy(options) {
	   assertRequiredArgument(options, 1, 'CountQueuingStrategy');
	   options = convertQueuingStrategyInit(options, 'First parameter');
	   this._countQueuingStrategyHighWaterMark = options.highWaterMark;
	  }
	  Object.defineProperty(CountQueuingStrategy.prototype, "highWaterMark", {
	   get: function () {
	    if (!IsCountQueuingStrategy(this)) {
	     throw countBrandCheckException('highWaterMark');
	    }
	    return this._countQueuingStrategyHighWaterMark;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(CountQueuingStrategy.prototype, "size", {
	   get: function () {
	    if (!IsCountQueuingStrategy(this)) {
	     throw countBrandCheckException('size');
	    }
	    return countSizeFunction;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  return CountQueuingStrategy;
	 }());
	 Object.defineProperties(CountQueuingStrategy.prototype, {
	  highWaterMark: { enumerable: true },
	  size: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
	   value: 'CountQueuingStrategy',
	   configurable: true
	  });
	 }
	 function countBrandCheckException(name) {
	  return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
	 }
	 function IsCountQueuingStrategy(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
	   return false;
	  }
	  return x instanceof CountQueuingStrategy;
	 }
	 function convertTransformer(original, context) {
	  assertDictionary(original, context);
	  var flush = original === null || original === void 0 ? void 0 : original.flush;
	  var readableType = original === null || original === void 0 ? void 0 : original.readableType;
	  var start = original === null || original === void 0 ? void 0 : original.start;
	  var transform = original === null || original === void 0 ? void 0 : original.transform;
	  var writableType = original === null || original === void 0 ? void 0 : original.writableType;
	  return {
	   flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
	   readableType: readableType,
	   start: start === undefined ? undefined : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
	   transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
	   writableType: writableType
	  };
	 }
	 function convertTransformerFlushCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (controller) {
	   return promiseCall(fn, original, [controller]);
	  };
	 }
	 function convertTransformerStartCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (controller) {
	   return reflectCall(fn, original, [controller]);
	  };
	 }
	 function convertTransformerTransformCallback(fn, original, context) {
	  assertFunction(fn, context);
	  return function (chunk, controller) {
	   return promiseCall(fn, original, [
	    chunk,
	    controller
	   ]);
	  };
	 }
	 var TransformStream = (function () {
	  function TransformStream(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
	   if (rawTransformer === void 0) {
	    rawTransformer = {};
	   }
	   if (rawWritableStrategy === void 0) {
	    rawWritableStrategy = {};
	   }
	   if (rawReadableStrategy === void 0) {
	    rawReadableStrategy = {};
	   }
	   if (rawTransformer === undefined) {
	    rawTransformer = null;
	   }
	   var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
	   var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
	   var transformer = convertTransformer(rawTransformer, 'First parameter');
	   if (transformer.readableType !== undefined) {
	    throw new RangeError('Invalid readableType specified');
	   }
	   if (transformer.writableType !== undefined) {
	    throw new RangeError('Invalid writableType specified');
	   }
	   var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
	   var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
	   var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
	   var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
	   var startPromise_resolve;
	   var startPromise = newPromise(function (resolve) {
	    startPromise_resolve = resolve;
	   });
	   InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
	   SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
	   if (transformer.start !== undefined) {
	    startPromise_resolve(transformer.start(this._transformStreamController));
	   } else {
	    startPromise_resolve(undefined);
	   }
	  }
	  Object.defineProperty(TransformStream.prototype, "readable", {
	   get: function () {
	    if (!IsTransformStream(this)) {
	     throw streamBrandCheckException('readable');
	    }
	    return this._readable;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  Object.defineProperty(TransformStream.prototype, "writable", {
	   get: function () {
	    if (!IsTransformStream(this)) {
	     throw streamBrandCheckException('writable');
	    }
	    return this._writable;
	   },
	   enumerable: false,
	   configurable: true
	  });
	  return TransformStream;
	 }());
	 Object.defineProperties(TransformStream.prototype, {
	  readable: { enumerable: true },
	  writable: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
	   value: 'TransformStream',
	   configurable: true
	  });
	 }
	 function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
	  function startAlgorithm() {
	   return startPromise;
	  }
	  function writeAlgorithm(chunk) {
	   return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
	  }
	  function abortAlgorithm(reason) {
	   return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
	  }
	  function closeAlgorithm() {
	   return TransformStreamDefaultSinkCloseAlgorithm(stream);
	  }
	  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
	  function pullAlgorithm() {
	   return TransformStreamDefaultSourcePullAlgorithm(stream);
	  }
	  function cancelAlgorithm(reason) {
	   TransformStreamErrorWritableAndUnblockWrite(stream, reason);
	   return promiseResolvedWith(undefined);
	  }
	  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
	  stream._backpressure = undefined;
	  stream._backpressureChangePromise = undefined;
	  stream._backpressureChangePromise_resolve = undefined;
	  TransformStreamSetBackpressure(stream, true);
	  stream._transformStreamController = undefined;
	 }
	 function IsTransformStream(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
	   return false;
	  }
	  return x instanceof TransformStream;
	 }
	 function TransformStreamError(stream, e) {
	  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
	  TransformStreamErrorWritableAndUnblockWrite(stream, e);
	 }
	 function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
	  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
	  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
	  if (stream._backpressure) {
	   TransformStreamSetBackpressure(stream, false);
	  }
	 }
	 function TransformStreamSetBackpressure(stream, backpressure) {
	  if (stream._backpressureChangePromise !== undefined) {
	   stream._backpressureChangePromise_resolve();
	  }
	  stream._backpressureChangePromise = newPromise(function (resolve) {
	   stream._backpressureChangePromise_resolve = resolve;
	  });
	  stream._backpressure = backpressure;
	 }
	 var TransformStreamDefaultController = (function () {
	  function TransformStreamDefaultController() {
	   throw new TypeError('Illegal constructor');
	  }
	  Object.defineProperty(TransformStreamDefaultController.prototype, "desiredSize", {
	   get: function () {
	    if (!IsTransformStreamDefaultController(this)) {
	     throw defaultControllerBrandCheckException('desiredSize');
	    }
	    var readableController = this._controlledTransformStream._readable._readableStreamController;
	    return ReadableStreamDefaultControllerGetDesiredSize(readableController);
	   },
	   enumerable: false,
	   configurable: true
	  });
	  TransformStreamDefaultController.prototype.enqueue = function (chunk) {
	   if (chunk === void 0) {
	    chunk = undefined;
	   }
	   if (!IsTransformStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException('enqueue');
	   }
	   TransformStreamDefaultControllerEnqueue(this, chunk);
	  };
	  TransformStreamDefaultController.prototype.error = function (reason) {
	   if (reason === void 0) {
	    reason = undefined;
	   }
	   if (!IsTransformStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException('error');
	   }
	   TransformStreamDefaultControllerError(this, reason);
	  };
	  TransformStreamDefaultController.prototype.terminate = function () {
	   if (!IsTransformStreamDefaultController(this)) {
	    throw defaultControllerBrandCheckException('terminate');
	   }
	   TransformStreamDefaultControllerTerminate(this);
	  };
	  return TransformStreamDefaultController;
	 }());
	 Object.defineProperties(TransformStreamDefaultController.prototype, {
	  enqueue: { enumerable: true },
	  error: { enumerable: true },
	  terminate: { enumerable: true },
	  desiredSize: { enumerable: true }
	 });
	 if (typeof SymbolPolyfill.toStringTag === 'symbol') {
	  Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
	   value: 'TransformStreamDefaultController',
	   configurable: true
	  });
	 }
	 function IsTransformStreamDefaultController(x) {
	  if (!typeIsObject(x)) {
	   return false;
	  }
	  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
	   return false;
	  }
	  return x instanceof TransformStreamDefaultController;
	 }
	 function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
	  controller._controlledTransformStream = stream;
	  stream._transformStreamController = controller;
	  controller._transformAlgorithm = transformAlgorithm;
	  controller._flushAlgorithm = flushAlgorithm;
	 }
	 function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
	  var controller = Object.create(TransformStreamDefaultController.prototype);
	  var transformAlgorithm = function (chunk) {
	   try {
	    TransformStreamDefaultControllerEnqueue(controller, chunk);
	    return promiseResolvedWith(undefined);
	   } catch (transformResultE) {
	    return promiseRejectedWith(transformResultE);
	   }
	  };
	  var flushAlgorithm = function () {
	   return promiseResolvedWith(undefined);
	  };
	  if (transformer.transform !== undefined) {
	   transformAlgorithm = function (chunk) {
	    return transformer.transform(chunk, controller);
	   };
	  }
	  if (transformer.flush !== undefined) {
	   flushAlgorithm = function () {
	    return transformer.flush(controller);
	   };
	  }
	  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
	 }
	 function TransformStreamDefaultControllerClearAlgorithms(controller) {
	  controller._transformAlgorithm = undefined;
	  controller._flushAlgorithm = undefined;
	 }
	 function TransformStreamDefaultControllerEnqueue(controller, chunk) {
	  var stream = controller._controlledTransformStream;
	  var readableController = stream._readable._readableStreamController;
	  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
	   throw new TypeError('Readable side is not in a state that permits enqueue');
	  }
	  try {
	   ReadableStreamDefaultControllerEnqueue(readableController, chunk);
	  } catch (e) {
	   TransformStreamErrorWritableAndUnblockWrite(stream, e);
	   throw stream._readable._storedError;
	  }
	  var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
	  if (backpressure !== stream._backpressure) {
	   TransformStreamSetBackpressure(stream, true);
	  }
	 }
	 function TransformStreamDefaultControllerError(controller, e) {
	  TransformStreamError(controller._controlledTransformStream, e);
	 }
	 function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
	  var transformPromise = controller._transformAlgorithm(chunk);
	  return transformPromiseWith(transformPromise, undefined, function (r) {
	   TransformStreamError(controller._controlledTransformStream, r);
	   throw r;
	  });
	 }
	 function TransformStreamDefaultControllerTerminate(controller) {
	  var stream = controller._controlledTransformStream;
	  var readableController = stream._readable._readableStreamController;
	  ReadableStreamDefaultControllerClose(readableController);
	  var error = new TypeError('TransformStream terminated');
	  TransformStreamErrorWritableAndUnblockWrite(stream, error);
	 }
	 function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
	  var controller = stream._transformStreamController;
	  if (stream._backpressure) {
	   var backpressureChangePromise = stream._backpressureChangePromise;
	   return transformPromiseWith(backpressureChangePromise, function () {
	    var writable = stream._writable;
	    var state = writable._state;
	    if (state === 'erroring') {
	     throw writable._storedError;
	    }
	    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
	   });
	  }
	  return TransformStreamDefaultControllerPerformTransform(controller, chunk);
	 }
	 function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
	  TransformStreamError(stream, reason);
	  return promiseResolvedWith(undefined);
	 }
	 function TransformStreamDefaultSinkCloseAlgorithm(stream) {
	  var readable = stream._readable;
	  var controller = stream._transformStreamController;
	  var flushPromise = controller._flushAlgorithm();
	  TransformStreamDefaultControllerClearAlgorithms(controller);
	  return transformPromiseWith(flushPromise, function () {
	   if (readable._state === 'errored') {
	    throw readable._storedError;
	   }
	   ReadableStreamDefaultControllerClose(readable._readableStreamController);
	  }, function (r) {
	   TransformStreamError(stream, r);
	   throw readable._storedError;
	  });
	 }
	 function TransformStreamDefaultSourcePullAlgorithm(stream) {
	  TransformStreamSetBackpressure(stream, false);
	  return stream._backpressureChangePromise;
	 }
	 function defaultControllerBrandCheckException(name) {
	  return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
	 }
	 function streamBrandCheckException(name) {
	  return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
	 }
	 exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
	 exports.CountQueuingStrategy = CountQueuingStrategy;
	 exports.ReadableByteStreamController = ReadableByteStreamController;
	 exports.ReadableStream = ReadableStream;
	 exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
	 exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
	 exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
	 exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
	 exports.TransformStream = TransformStream;
	 exports.TransformStreamDefaultController = TransformStreamDefaultController;
	 exports.WritableStream = WritableStream;
	 exports.WritableStreamDefaultController = WritableStreamDefaultController;
	 exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
	 Object.defineProperty(exports, '__esModule', { value: true });
	}));

	/***/ }),
	/* 135 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var BaseCanvasFactory = /*#__PURE__*/function () {
	  function BaseCanvasFactory() {
	    _classCallCheck(this, BaseCanvasFactory);

	    if (this.constructor === BaseCanvasFactory) {
	      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
	    }
	  }

	  _createClass(BaseCanvasFactory, [{
	    key: "create",
	    value: function create(width, height) {
	      if (width <= 0 || height <= 0) {
	        throw new Error("Invalid canvas size");
	      }

	      var canvas = this._createCanvas(width, height);

	      return {
	        canvas: canvas,
	        context: canvas.getContext("2d")
	      };
	    }
	  }, {
	    key: "reset",
	    value: function reset(canvasAndContext, width, height) {
	      if (!canvasAndContext.canvas) {
	        throw new Error("Canvas is not specified");
	      }

	      if (width <= 0 || height <= 0) {
	        throw new Error("Invalid canvas size");
	      }

	      canvasAndContext.canvas.width = width;
	      canvasAndContext.canvas.height = height;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy(canvasAndContext) {
	      if (!canvasAndContext.canvas) {
	        throw new Error("Canvas is not specified");
	      }

	      canvasAndContext.canvas.width = 0;
	      canvasAndContext.canvas.height = 0;
	      canvasAndContext.canvas = null;
	      canvasAndContext.context = null;
	    }
	  }, {
	    key: "_createCanvas",
	    value: function _createCanvas(width, height) {
	      (0, _util.unreachable)("Abstract method `_createCanvas` called.");
	    }
	  }]);

	  return BaseCanvasFactory;
	}();

	exports.BaseCanvasFactory = BaseCanvasFactory;

	var BaseCMapReaderFactory = /*#__PURE__*/function () {
	  function BaseCMapReaderFactory(_ref) {
	    var _ref$baseUrl = _ref.baseUrl,
	        baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl,
	        _ref$isCompressed = _ref.isCompressed,
	        isCompressed = _ref$isCompressed === void 0 ? false : _ref$isCompressed;

	    _classCallCheck(this, BaseCMapReaderFactory);

	    if (this.constructor === BaseCMapReaderFactory) {
	      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
	    }

	    this.baseUrl = baseUrl;
	    this.isCompressed = isCompressed;
	  }

	  _createClass(BaseCMapReaderFactory, [{
	    key: "fetch",
	    value: function () {
	      var _fetch = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref2) {
	        var _this = this;

	        var name, url, compressionType;
	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                name = _ref2.name;

	                if (this.baseUrl) {
	                  _context.next = 3;
	                  break;
	                }

	                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');

	              case 3:
	                if (name) {
	                  _context.next = 5;
	                  break;
	                }

	                throw new Error("CMap name must be specified.");

	              case 5:
	                url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
	                compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
	                return _context.abrupt("return", this._fetchData(url, compressionType)["catch"](function (reason) {
	                  throw new Error("Unable to load ".concat(_this.isCompressed ? "binary " : "", "CMap at: ").concat(url));
	                }));

	              case 8:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function fetch(_x) {
	        return _fetch.apply(this, arguments);
	      }

	      return fetch;
	    }()
	  }, {
	    key: "_fetchData",
	    value: function _fetchData(url, compressionType) {
	      (0, _util.unreachable)("Abstract method `_fetchData` called.");
	    }
	  }]);

	  return BaseCMapReaderFactory;
	}();

	exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

	var BaseStandardFontDataFactory = /*#__PURE__*/function () {
	  function BaseStandardFontDataFactory(_ref3) {
	    var _ref3$baseUrl = _ref3.baseUrl,
	        baseUrl = _ref3$baseUrl === void 0 ? null : _ref3$baseUrl;

	    _classCallCheck(this, BaseStandardFontDataFactory);

	    if (this.constructor === BaseStandardFontDataFactory) {
	      (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
	    }

	    this.baseUrl = baseUrl;
	  }

	  _createClass(BaseStandardFontDataFactory, [{
	    key: "fetch",
	    value: function () {
	      var _fetch2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref4) {
	        var filename, url;
	        return _regenerator["default"].wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                filename = _ref4.filename;

	                if (this.baseUrl) {
	                  _context2.next = 3;
	                  break;
	                }

	                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');

	              case 3:
	                if (filename) {
	                  _context2.next = 5;
	                  break;
	                }

	                throw new Error("Font filename must be specified.");

	              case 5:
	                url = "".concat(this.baseUrl).concat(filename);
	                return _context2.abrupt("return", this._fetchData(url)["catch"](function (reason) {
	                  throw new Error("Unable to load font data at: ".concat(url));
	                }));

	              case 7:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function fetch(_x2) {
	        return _fetch2.apply(this, arguments);
	      }

	      return fetch;
	    }()
	  }, {
	    key: "_fetchData",
	    value: function _fetchData(url) {
	      (0, _util.unreachable)("Abstract method `_fetchData` called.");
	    }
	  }]);

	  return BaseStandardFontDataFactory;
	}();

	exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;

	var BaseSVGFactory = /*#__PURE__*/function () {
	  function BaseSVGFactory() {
	    _classCallCheck(this, BaseSVGFactory);

	    if (this.constructor === BaseSVGFactory) {
	      (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
	    }
	  }

	  _createClass(BaseSVGFactory, [{
	    key: "create",
	    value: function create(width, height) {
	      if (width <= 0 || height <= 0) {
	        throw new Error("Invalid SVG dimensions");
	      }

	      var svg = this._createSVG("svg:svg");

	      svg.setAttribute("version", "1.1");
	      svg.setAttribute("width", "".concat(width, "px"));
	      svg.setAttribute("height", "".concat(height, "px"));
	      svg.setAttribute("preserveAspectRatio", "none");
	      svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
	      return svg;
	    }
	  }, {
	    key: "createElement",
	    value: function createElement(type) {
	      if (typeof type !== "string") {
	        throw new Error("Invalid SVG element type");
	      }

	      return this._createSVG(type);
	    }
	  }, {
	    key: "_createSVG",
	    value: function _createSVG(type) {
	      (0, _util.unreachable)("Abstract method `_createSVG` called.");
	    }
	  }]);

	  return BaseSVGFactory;
	}();

	exports.BaseSVGFactory = BaseSVGFactory;

	/***/ }),
	/* 136 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.build = exports.RenderTask = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
	exports.getDocument = getDocument;
	exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
	exports.version = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	var _display_utils = __w_pdfjs_require__(1);

	var _font_loader = __w_pdfjs_require__(137);

	var _node_utils = __w_pdfjs_require__(138);

	var _annotation_storage = __w_pdfjs_require__(139);

	var _canvas = __w_pdfjs_require__(140);

	var _worker_options = __w_pdfjs_require__(142);

	var _is_node = __w_pdfjs_require__(6);

	var _message_handler = __w_pdfjs_require__(143);

	var _metadata = __w_pdfjs_require__(144);

	var _optional_content_config = __w_pdfjs_require__(145);

	var _transport_stream = __w_pdfjs_require__(146);

	var _xfa_text = __w_pdfjs_require__(147);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

	function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

	function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

	function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

	function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

	function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

	function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var DEFAULT_RANGE_CHUNK_SIZE = 65536;
	var RENDERING_CANCELLED_TIMEOUT = 100;
	var DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
	exports.DefaultCanvasFactory = DefaultCanvasFactory;
	var DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
	exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
	var DefaultStandardFontDataFactory = _is_node.isNodeJS ? _node_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
	exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
	var createPDFNetworkStream;

	function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
	  createPDFNetworkStream = pdfNetworkStreamFactory;
	}

	function getDocument(src) {
	  var task = new PDFDocumentLoadingTask();
	  var source;

	  if (typeof src === "string" || src instanceof URL) {
	    source = {
	      url: src
	    };
	  } else if ((0, _util.isArrayBuffer)(src)) {
	    source = {
	      data: src
	    };
	  } else if (src instanceof PDFDataRangeTransport) {
	    source = {
	      range: src
	    };
	  } else {
	    if (_typeof(src) !== "object") {
	      throw new Error("Invalid parameter in getDocument, " + "need either string, URL, Uint8Array, or parameter object.");
	    }

	    if (!src.url && !src.data && !src.range) {
	      throw new Error("Invalid parameter object: need either .data, .range or .url");
	    }

	    source = src;
	  }

	  var params = Object.create(null);
	  var rangeTransport = null,
	      worker = null;

	  for (var key in source) {
	    var value = source[key];

	    switch (key) {
	      case "url":
	        if (typeof window !== "undefined") {
	          try {
	            params[key] = new URL(value, window.location).href;
	            continue;
	          } catch (ex) {
	            (0, _util.warn)("Cannot create valid URL: \"".concat(ex, "\"."));
	          }
	        } else if (typeof value === "string" || value instanceof URL) {
	          params[key] = value.toString();
	          continue;
	        }

	        throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

	      case "range":
	        rangeTransport = value;
	        continue;

	      case "worker":
	        worker = value;
	        continue;

	      case "data":
	        if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
	          params[key] = new Uint8Array(value);
	        } else if (value instanceof Uint8Array) {
	          break;
	        } else if (typeof value === "string") {
	          params[key] = (0, _util.stringToBytes)(value);
	        } else if (_typeof(value) === "object" && value !== null && !isNaN(value.length)) {
	          params[key] = new Uint8Array(value);
	        } else if ((0, _util.isArrayBuffer)(value)) {
	          params[key] = new Uint8Array(value);
	        } else {
	          throw new Error("Invalid PDF binary data: either typed array, " + "string, or array-like object is expected in the data property.");
	        }

	        continue;
	    }

	    params[key] = value;
	  }

	  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
	  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
	  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
	  params.ignoreErrors = params.stopAtErrors !== true;
	  params.fontExtraProperties = params.fontExtraProperties === true;
	  params.pdfBug = params.pdfBug === true;
	  params.enableXfa = params.enableXfa === true;

	  if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
	    params.docBaseUrl = null;
	  }

	  if (!Number.isInteger(params.maxImageSize)) {
	    params.maxImageSize = -1;
	  }

	  if (typeof params.useWorkerFetch !== "boolean") {
	    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
	  }

	  if (typeof params.isEvalSupported !== "boolean") {
	    params.isEvalSupported = true;
	  }

	  if (typeof params.disableFontFace !== "boolean") {
	    params.disableFontFace = _is_node.isNodeJS;
	  }

	  if (typeof params.useSystemFonts !== "boolean") {
	    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
	  }

	  if (typeof params.ownerDocument === "undefined") {
	    params.ownerDocument = globalThis.document;
	  }

	  if (typeof params.disableRange !== "boolean") {
	    params.disableRange = false;
	  }

	  if (typeof params.disableStream !== "boolean") {
	    params.disableStream = false;
	  }

	  if (typeof params.disableAutoFetch !== "boolean") {
	    params.disableAutoFetch = false;
	  }

	  (0, _util.setVerbosityLevel)(params.verbosity);

	  if (!worker) {
	    var workerParams = {
	      verbosity: params.verbosity,
	      port: _worker_options.GlobalWorkerOptions.workerPort
	    };
	    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
	    task._worker = worker;
	  }

	  var docId = task.docId;
	  worker.promise.then(function () {
	    if (task.destroyed) {
	      throw new Error("Loading aborted");
	    }

	    var workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

	    var networkStreamPromise = new Promise(function (resolve) {
	      var networkStream;

	      if (rangeTransport) {
	        networkStream = new _transport_stream.PDFDataTransportStream({
	          length: params.length,
	          initialData: params.initialData,
	          progressiveDone: params.progressiveDone,
	          contentDispositionFilename: params.contentDispositionFilename,
	          disableRange: params.disableRange,
	          disableStream: params.disableStream
	        }, rangeTransport);
	      } else if (!params.data) {
	        networkStream = createPDFNetworkStream({
	          url: params.url,
	          length: params.length,
	          httpHeaders: params.httpHeaders,
	          withCredentials: params.withCredentials,
	          rangeChunkSize: params.rangeChunkSize,
	          disableRange: params.disableRange,
	          disableStream: params.disableStream
	        });
	      }

	      resolve(networkStream);
	    });
	    return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 2),
	          workerId = _ref2[0],
	          networkStream = _ref2[1];

	      if (task.destroyed) {
	        throw new Error("Loading aborted");
	      }

	      var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
	      var transport = new WorkerTransport(messageHandler, task, networkStream, params);
	      task._transport = transport;
	      messageHandler.send("Ready", null);
	    });
	  })["catch"](task._capability.reject);
	  return task;
	}

	function _fetchDocument(_x, _x2, _x3, _x4) {
	  return _fetchDocument2.apply(this, arguments);
	}

	function _fetchDocument2() {
	  _fetchDocument2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee7(worker, source, pdfDataRangeTransport, docId) {
	    var workerId;
	    return _regenerator["default"].wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            if (!worker.destroyed) {
	              _context7.next = 2;
	              break;
	            }

	            throw new Error("Worker was destroyed");

	          case 2:
	            if (pdfDataRangeTransport) {
	              source.length = pdfDataRangeTransport.length;
	              source.initialData = pdfDataRangeTransport.initialData;
	              source.progressiveDone = pdfDataRangeTransport.progressiveDone;
	              source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
	            }

	            _context7.next = 5;
	            return worker.messageHandler.sendWithPromise("GetDocRequest", {
	              docId: docId,
	              apiVersion: '2.12.313',
	              source: {
	                data: source.data,
	                url: source.url,
	                password: source.password,
	                disableAutoFetch: source.disableAutoFetch,
	                rangeChunkSize: source.rangeChunkSize,
	                length: source.length
	              },
	              maxImageSize: source.maxImageSize,
	              disableFontFace: source.disableFontFace,
	              docBaseUrl: source.docBaseUrl,
	              ignoreErrors: source.ignoreErrors,
	              isEvalSupported: source.isEvalSupported,
	              fontExtraProperties: source.fontExtraProperties,
	              enableXfa: source.enableXfa,
	              useSystemFonts: source.useSystemFonts,
	              cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
	              standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
	            });

	          case 5:
	            workerId = _context7.sent;

	            if (!worker.destroyed) {
	              _context7.next = 8;
	              break;
	            }

	            throw new Error("Worker was destroyed");

	          case 8:
	            return _context7.abrupt("return", workerId);

	          case 9:
	          case "end":
	            return _context7.stop();
	        }
	      }
	    }, _callee7);
	  }));
	  return _fetchDocument2.apply(this, arguments);
	}

	var PDFDocumentLoadingTask = /*#__PURE__*/function () {
	  function PDFDocumentLoadingTask() {
	    _classCallCheck(this, PDFDocumentLoadingTask);

	    this._capability = (0, _util.createPromiseCapability)();
	    this._transport = null;
	    this._worker = null;
	    this.docId = "d".concat(PDFDocumentLoadingTask.idCounters.doc++);
	    this.destroyed = false;
	    this.onPassword = null;
	    this.onProgress = null;
	    this.onUnsupportedFeature = null;
	  }

	  _createClass(PDFDocumentLoadingTask, [{
	    key: "promise",
	    get: function get() {
	      return this._capability.promise;
	    }
	  }, {
	    key: "destroy",
	    value: function () {
	      var _destroy = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
	        var _this$_transport;

	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                this.destroyed = true;
	                _context.next = 3;
	                return (_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();

	              case 3:
	                this._transport = null;

	                if (this._worker) {
	                  this._worker.destroy();

	                  this._worker = null;
	                }

	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function destroy() {
	        return _destroy.apply(this, arguments);
	      }

	      return destroy;
	    }()
	  }], [{
	    key: "idCounters",
	    get: function get() {
	      return (0, _util.shadow)(this, "idCounters", {
	        doc: 0
	      });
	    }
	  }]);

	  return PDFDocumentLoadingTask;
	}();

	exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;

	var PDFDataRangeTransport = /*#__PURE__*/function () {
	  function PDFDataRangeTransport(length, initialData) {
	    var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	    _classCallCheck(this, PDFDataRangeTransport);

	    this.length = length;
	    this.initialData = initialData;
	    this.progressiveDone = progressiveDone;
	    this.contentDispositionFilename = contentDispositionFilename;
	    this._rangeListeners = [];
	    this._progressListeners = [];
	    this._progressiveReadListeners = [];
	    this._progressiveDoneListeners = [];
	    this._readyCapability = (0, _util.createPromiseCapability)();
	  }

	  _createClass(PDFDataRangeTransport, [{
	    key: "addRangeListener",
	    value: function addRangeListener(listener) {
	      this._rangeListeners.push(listener);
	    }
	  }, {
	    key: "addProgressListener",
	    value: function addProgressListener(listener) {
	      this._progressListeners.push(listener);
	    }
	  }, {
	    key: "addProgressiveReadListener",
	    value: function addProgressiveReadListener(listener) {
	      this._progressiveReadListeners.push(listener);
	    }
	  }, {
	    key: "addProgressiveDoneListener",
	    value: function addProgressiveDoneListener(listener) {
	      this._progressiveDoneListeners.push(listener);
	    }
	  }, {
	    key: "onDataRange",
	    value: function onDataRange(begin, chunk) {
	      var _iterator = _createForOfIteratorHelper(this._rangeListeners),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var listener = _step.value;
	          listener(begin, chunk);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    }
	  }, {
	    key: "onDataProgress",
	    value: function onDataProgress(loaded, total) {
	      var _this = this;

	      this._readyCapability.promise.then(function () {
	        var _iterator2 = _createForOfIteratorHelper(_this._progressListeners),
	            _step2;

	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var listener = _step2.value;
	            listener(loaded, total);
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	      });
	    }
	  }, {
	    key: "onDataProgressiveRead",
	    value: function onDataProgressiveRead(chunk) {
	      var _this2 = this;

	      this._readyCapability.promise.then(function () {
	        var _iterator3 = _createForOfIteratorHelper(_this2._progressiveReadListeners),
	            _step3;

	        try {
	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var listener = _step3.value;
	            listener(chunk);
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }
	      });
	    }
	  }, {
	    key: "onDataProgressiveDone",
	    value: function onDataProgressiveDone() {
	      var _this3 = this;

	      this._readyCapability.promise.then(function () {
	        var _iterator4 = _createForOfIteratorHelper(_this3._progressiveDoneListeners),
	            _step4;

	        try {
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var listener = _step4.value;
	            listener();
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }
	      });
	    }
	  }, {
	    key: "transportReady",
	    value: function transportReady() {
	      this._readyCapability.resolve();
	    }
	  }, {
	    key: "requestDataRange",
	    value: function requestDataRange(begin, end) {
	      (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
	    }
	  }, {
	    key: "abort",
	    value: function abort() {}
	  }]);

	  return PDFDataRangeTransport;
	}();

	exports.PDFDataRangeTransport = PDFDataRangeTransport;

	var PDFDocumentProxy = /*#__PURE__*/function () {
	  function PDFDocumentProxy(pdfInfo, transport) {
	    var _this4 = this;

	    _classCallCheck(this, PDFDocumentProxy);

	    this._pdfInfo = pdfInfo;
	    this._transport = transport;
	    Object.defineProperty(this, "fingerprint", {
	      get: function get() {
	        (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
	        return this.fingerprints[0];
	      }
	    });
	    Object.defineProperty(this, "getStats", {
	      value: function () {
	        var _value = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
	          return _regenerator["default"].wrap(function _callee2$(_context2) {
	            while (1) {
	              switch (_context2.prev = _context2.next) {
	                case 0:
	                  (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, " + "please use the `PDFDocumentProxy.stats`-getter instead.");
	                  return _context2.abrupt("return", _this4.stats || {
	                    streamTypes: {},
	                    fontTypes: {}
	                  });

	                case 2:
	                case "end":
	                  return _context2.stop();
	              }
	            }
	          }, _callee2);
	        }));

	        function value() {
	          return _value.apply(this, arguments);
	        }

	        return value;
	      }()
	    });
	  }

	  _createClass(PDFDocumentProxy, [{
	    key: "annotationStorage",
	    get: function get() {
	      return this._transport.annotationStorage;
	    }
	  }, {
	    key: "numPages",
	    get: function get() {
	      return this._pdfInfo.numPages;
	    }
	  }, {
	    key: "fingerprints",
	    get: function get() {
	      return this._pdfInfo.fingerprints;
	    }
	  }, {
	    key: "stats",
	    get: function get() {
	      return this._transport.stats;
	    }
	  }, {
	    key: "isPureXfa",
	    get: function get() {
	      return !!this._transport._htmlForXfa;
	    }
	  }, {
	    key: "allXfaHtml",
	    get: function get() {
	      return this._transport._htmlForXfa;
	    }
	  }, {
	    key: "getPage",
	    value: function getPage(pageNumber) {
	      return this._transport.getPage(pageNumber);
	    }
	  }, {
	    key: "getPageIndex",
	    value: function getPageIndex(ref) {
	      return this._transport.getPageIndex(ref);
	    }
	  }, {
	    key: "getDestinations",
	    value: function getDestinations() {
	      return this._transport.getDestinations();
	    }
	  }, {
	    key: "getDestination",
	    value: function getDestination(id) {
	      return this._transport.getDestination(id);
	    }
	  }, {
	    key: "getPageLabels",
	    value: function getPageLabels() {
	      return this._transport.getPageLabels();
	    }
	  }, {
	    key: "getPageLayout",
	    value: function getPageLayout() {
	      return this._transport.getPageLayout();
	    }
	  }, {
	    key: "getPageMode",
	    value: function getPageMode() {
	      return this._transport.getPageMode();
	    }
	  }, {
	    key: "getViewerPreferences",
	    value: function getViewerPreferences() {
	      return this._transport.getViewerPreferences();
	    }
	  }, {
	    key: "getOpenAction",
	    value: function getOpenAction() {
	      return this._transport.getOpenAction();
	    }
	  }, {
	    key: "getAttachments",
	    value: function getAttachments() {
	      return this._transport.getAttachments();
	    }
	  }, {
	    key: "getJavaScript",
	    value: function getJavaScript() {
	      return this._transport.getJavaScript();
	    }
	  }, {
	    key: "getJSActions",
	    value: function getJSActions() {
	      return this._transport.getDocJSActions();
	    }
	  }, {
	    key: "getOutline",
	    value: function getOutline() {
	      return this._transport.getOutline();
	    }
	  }, {
	    key: "getOptionalContentConfig",
	    value: function getOptionalContentConfig() {
	      return this._transport.getOptionalContentConfig();
	    }
	  }, {
	    key: "getPermissions",
	    value: function getPermissions() {
	      return this._transport.getPermissions();
	    }
	  }, {
	    key: "getMetadata",
	    value: function getMetadata() {
	      return this._transport.getMetadata();
	    }
	  }, {
	    key: "getMarkInfo",
	    value: function getMarkInfo() {
	      return this._transport.getMarkInfo();
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this._transport.getData();
	    }
	  }, {
	    key: "getDownloadInfo",
	    value: function getDownloadInfo() {
	      return this._transport.downloadInfoCapability.promise;
	    }
	  }, {
	    key: "cleanup",
	    value: function cleanup() {
	      var keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      return this.loadingTask.destroy();
	    }
	  }, {
	    key: "loadingParams",
	    get: function get() {
	      return this._transport.loadingParams;
	    }
	  }, {
	    key: "loadingTask",
	    get: function get() {
	      return this._transport.loadingTask;
	    }
	  }, {
	    key: "saveDocument",
	    value: function saveDocument() {
	      if (this._transport.annotationStorage.size <= 0) {
	        (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
	      }

	      return this._transport.saveDocument();
	    }
	  }, {
	    key: "getFieldObjects",
	    value: function getFieldObjects() {
	      return this._transport.getFieldObjects();
	    }
	  }, {
	    key: "hasJSActions",
	    value: function hasJSActions() {
	      return this._transport.hasJSActions();
	    }
	  }, {
	    key: "getCalculationOrderIds",
	    value: function getCalculationOrderIds() {
	      return this._transport.getCalculationOrderIds();
	    }
	  }]);

	  return PDFDocumentProxy;
	}();

	exports.PDFDocumentProxy = PDFDocumentProxy;

	var PDFPageProxy = /*#__PURE__*/function () {
	  function PDFPageProxy(pageIndex, pageInfo, transport, ownerDocument) {
	    var pdfBug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

	    _classCallCheck(this, PDFPageProxy);

	    this._pageIndex = pageIndex;
	    this._pageInfo = pageInfo;
	    this._ownerDocument = ownerDocument;
	    this._transport = transport;
	    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
	    this._pdfBug = pdfBug;
	    this.commonObjs = transport.commonObjs;
	    this.objs = new PDFObjects();
	    this.cleanupAfterRender = false;
	    this.pendingCleanup = false;
	    this._intentStates = new Map();
	    this._annotationPromises = new Map();
	    this.destroyed = false;
	  }

	  _createClass(PDFPageProxy, [{
	    key: "pageNumber",
	    get: function get() {
	      return this._pageIndex + 1;
	    }
	  }, {
	    key: "rotate",
	    get: function get() {
	      return this._pageInfo.rotate;
	    }
	  }, {
	    key: "ref",
	    get: function get() {
	      return this._pageInfo.ref;
	    }
	  }, {
	    key: "userUnit",
	    get: function get() {
	      return this._pageInfo.userUnit;
	    }
	  }, {
	    key: "view",
	    get: function get() {
	      return this._pageInfo.view;
	    }
	  }, {
	    key: "getViewport",
	    value: function getViewport() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          scale = _ref3.scale,
	          _ref3$rotation = _ref3.rotation,
	          rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation,
	          _ref3$offsetX = _ref3.offsetX,
	          offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,
	          _ref3$offsetY = _ref3.offsetY,
	          offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,
	          _ref3$dontFlip = _ref3.dontFlip,
	          dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;

	      return new _display_utils.PageViewport({
	        viewBox: this.view,
	        scale: scale,
	        rotation: rotation,
	        offsetX: offsetX,
	        offsetY: offsetY,
	        dontFlip: dontFlip
	      });
	    }
	  }, {
	    key: "getAnnotations",
	    value: function getAnnotations() {
	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref4$intent = _ref4.intent,
	          intent = _ref4$intent === void 0 ? "display" : _ref4$intent;

	      var intentArgs = this._transport.getRenderingIntent(intent);

	      var promise = this._annotationPromises.get(intentArgs.cacheKey);

	      if (!promise) {
	        promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);

	        this._annotationPromises.set(intentArgs.cacheKey, promise);

	        promise = promise.then(function (annotations) {
	          var _iterator5 = _createForOfIteratorHelper(annotations),
	              _step5;

	          try {
	            var _loop = function _loop() {
	              var annotation = _step5.value;

	              if (annotation.titleObj !== undefined) {
	                Object.defineProperty(annotation, "title", {
	                  get: function get() {
	                    (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
	                    return annotation.titleObj.str;
	                  }
	                });
	              }

	              if (annotation.contentsObj !== undefined) {
	                Object.defineProperty(annotation, "contents", {
	                  get: function get() {
	                    (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
	                    return annotation.contentsObj.str;
	                  }
	                });
	              }
	            };

	            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	              _loop();
	            }
	          } catch (err) {
	            _iterator5.e(err);
	          } finally {
	            _iterator5.f();
	          }

	          return annotations;
	        });
	      }

	      return promise;
	    }
	  }, {
	    key: "getJSActions",
	    value: function getJSActions() {
	      return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
	    }
	  }, {
	    key: "getXfa",
	    value: function () {
	      var _getXfa = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
	        var _this$_transport$_htm;

	        return _regenerator["default"].wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                return _context3.abrupt("return", ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null);

	              case 1:
	              case "end":
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function getXfa() {
	        return _getXfa.apply(this, arguments);
	      }

	      return getXfa;
	    }()
	  }, {
	    key: "render",
	    value: function render(_ref5) {
	      var _arguments$,
	          _arguments$2,
	          _this5 = this,
	          _intentState;

	      var canvasContext = _ref5.canvasContext,
	          viewport = _ref5.viewport,
	          _ref5$intent = _ref5.intent,
	          intent = _ref5$intent === void 0 ? "display" : _ref5$intent,
	          _ref5$annotationMode = _ref5.annotationMode,
	          annotationMode = _ref5$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref5$annotationMode,
	          _ref5$transform = _ref5.transform,
	          transform = _ref5$transform === void 0 ? null : _ref5$transform,
	          _ref5$imageLayer = _ref5.imageLayer,
	          imageLayer = _ref5$imageLayer === void 0 ? null : _ref5$imageLayer,
	          _ref5$canvasFactory = _ref5.canvasFactory,
	          canvasFactory = _ref5$canvasFactory === void 0 ? null : _ref5$canvasFactory,
	          _ref5$background = _ref5.background,
	          background = _ref5$background === void 0 ? null : _ref5$background,
	          _ref5$optionalContent = _ref5.optionalContentConfigPromise,
	          optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent,
	          _ref5$annotationCanva = _ref5.annotationCanvasMap,
	          annotationCanvasMap = _ref5$annotationCanva === void 0 ? null : _ref5$annotationCanva;

	      if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== undefined) {
	        (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");

	        if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
	          annotationMode = _util.AnnotationMode.ENABLE_FORMS;
	        }
	      }

	      if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== undefined) {
	        (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");

	        if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
	          annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
	        }
	      }

	      if (this._stats) {
	        this._stats.time("Overall");
	      }

	      var intentArgs = this._transport.getRenderingIntent(intent, annotationMode);

	      this.pendingCleanup = false;

	      if (!optionalContentConfigPromise) {
	        optionalContentConfigPromise = this._transport.getOptionalContentConfig();
	      }

	      var intentState = this._intentStates.get(intentArgs.cacheKey);

	      if (!intentState) {
	        intentState = Object.create(null);

	        this._intentStates.set(intentArgs.cacheKey, intentState);
	      }

	      if (intentState.streamReaderCancelTimeout) {
	        clearTimeout(intentState.streamReaderCancelTimeout);
	        intentState.streamReaderCancelTimeout = null;
	      }

	      var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
	        ownerDocument: this._ownerDocument
	      });
	      var intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);

	      if (!intentState.displayReadyCapability) {
	        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
	        intentState.operatorList = {
	          fnArray: [],
	          argsArray: [],
	          lastChunk: false
	        };

	        if (this._stats) {
	          this._stats.time("Page Request");
	        }

	        this._pumpOperatorList(intentArgs);
	      }

	      var complete = function complete(error) {
	        intentState.renderTasks["delete"](internalRenderTask);

	        if (_this5.cleanupAfterRender || intentPrint) {
	          _this5.pendingCleanup = true;
	        }

	        _this5._tryCleanup();

	        if (error) {
	          internalRenderTask.capability.reject(error);

	          _this5._abortOperatorList({
	            intentState: intentState,
	            reason: error instanceof Error ? error : new Error(error)
	          });
	        } else {
	          internalRenderTask.capability.resolve();
	        }

	        if (_this5._stats) {
	          _this5._stats.timeEnd("Rendering");

	          _this5._stats.timeEnd("Overall");
	        }
	      };

	      var internalRenderTask = new InternalRenderTask({
	        callback: complete,
	        params: {
	          canvasContext: canvasContext,
	          viewport: viewport,
	          transform: transform,
	          imageLayer: imageLayer,
	          background: background
	        },
	        objs: this.objs,
	        commonObjs: this.commonObjs,
	        annotationCanvasMap: annotationCanvasMap,
	        operatorList: intentState.operatorList,
	        pageIndex: this._pageIndex,
	        canvasFactory: canvasFactoryInstance,
	        useRequestAnimationFrame: !intentPrint,
	        pdfBug: this._pdfBug
	      });
	      ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
	      var renderTask = internalRenderTask.task;
	      Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function (_ref6) {
	        var _ref7 = _slicedToArray(_ref6, 2),
	            transparency = _ref7[0],
	            optionalContentConfig = _ref7[1];

	        if (_this5.pendingCleanup) {
	          complete();
	          return;
	        }

	        if (_this5._stats) {
	          _this5._stats.time("Rendering");
	        }

	        internalRenderTask.initializeGraphics({
	          transparency: transparency,
	          optionalContentConfig: optionalContentConfig
	        });
	        internalRenderTask.operatorListChanged();
	      })["catch"](complete);
	      return renderTask;
	    }
	  }, {
	    key: "getOperatorList",
	    value: function getOperatorList() {
	      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref8$intent = _ref8.intent,
	          intent = _ref8$intent === void 0 ? "display" : _ref8$intent,
	          _ref8$annotationMode = _ref8.annotationMode,
	          annotationMode = _ref8$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref8$annotationMode;

	      function operatorListChanged() {
	        if (intentState.operatorList.lastChunk) {
	          intentState.opListReadCapability.resolve(intentState.operatorList);
	          intentState.renderTasks["delete"](opListTask);
	        }
	      }

	      var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);

	      var intentState = this._intentStates.get(intentArgs.cacheKey);

	      if (!intentState) {
	        intentState = Object.create(null);

	        this._intentStates.set(intentArgs.cacheKey, intentState);
	      }

	      var opListTask;

	      if (!intentState.opListReadCapability) {
	        var _intentState2;

	        opListTask = Object.create(null);
	        opListTask.operatorListChanged = operatorListChanged;
	        intentState.opListReadCapability = (0, _util.createPromiseCapability)();
	        ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
	        intentState.operatorList = {
	          fnArray: [],
	          argsArray: [],
	          lastChunk: false
	        };

	        if (this._stats) {
	          this._stats.time("Page Request");
	        }

	        this._pumpOperatorList(intentArgs);
	      }

	      return intentState.opListReadCapability.promise;
	    }
	  }, {
	    key: "streamTextContent",
	    value: function streamTextContent() {
	      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref9$normalizeWhites = _ref9.normalizeWhitespace,
	          normalizeWhitespace = _ref9$normalizeWhites === void 0 ? false : _ref9$normalizeWhites,
	          _ref9$disableCombineT = _ref9.disableCombineTextItems,
	          disableCombineTextItems = _ref9$disableCombineT === void 0 ? false : _ref9$disableCombineT,
	          _ref9$includeMarkedCo = _ref9.includeMarkedContent,
	          includeMarkedContent = _ref9$includeMarkedCo === void 0 ? false : _ref9$includeMarkedCo;

	      var TEXT_CONTENT_CHUNK_SIZE = 100;
	      return this._transport.messageHandler.sendWithStream("GetTextContent", {
	        pageIndex: this._pageIndex,
	        normalizeWhitespace: normalizeWhitespace === true,
	        combineTextItems: disableCombineTextItems !== true,
	        includeMarkedContent: includeMarkedContent === true
	      }, {
	        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
	        size: function size(textContent) {
	          return textContent.items.length;
	        }
	      });
	    }
	  }, {
	    key: "getTextContent",
	    value: function getTextContent() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (this._transport._htmlForXfa) {
	        return this.getXfa().then(function (xfa) {
	          return _xfa_text.XfaText.textContent(xfa);
	        });
	      }

	      var readableStream = this.streamTextContent(params);
	      return new Promise(function (resolve, reject) {
	        function pump() {
	          reader.read().then(function (_ref10) {
	            var _textContent$items;

	            var value = _ref10.value,
	                done = _ref10.done;

	            if (done) {
	              resolve(textContent);
	              return;
	            }

	            Object.assign(textContent.styles, value.styles);

	            (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));

	            pump();
	          }, reject);
	        }

	        var reader = readableStream.getReader();
	        var textContent = {
	          items: [],
	          styles: Object.create(null)
	        };
	        pump();
	      });
	    }
	  }, {
	    key: "getStructTree",
	    value: function getStructTree() {
	      return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
	    }
	  }, {
	    key: "_destroy",
	    value: function _destroy() {
	      this.destroyed = true;
	      var waitOn = [];

	      var _iterator6 = _createForOfIteratorHelper(this._intentStates.values()),
	          _step6;

	      try {
	        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	          var intentState = _step6.value;

	          this._abortOperatorList({
	            intentState: intentState,
	            reason: new Error("Page was destroyed."),
	            force: true
	          });

	          if (intentState.opListReadCapability) {
	            continue;
	          }

	          var _iterator7 = _createForOfIteratorHelper(intentState.renderTasks),
	              _step7;

	          try {
	            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	              var internalRenderTask = _step7.value;
	              waitOn.push(internalRenderTask.completed);
	              internalRenderTask.cancel();
	            }
	          } catch (err) {
	            _iterator7.e(err);
	          } finally {
	            _iterator7.f();
	          }
	        }
	      } catch (err) {
	        _iterator6.e(err);
	      } finally {
	        _iterator6.f();
	      }

	      this.objs.clear();

	      this._annotationPromises.clear();

	      this._jsActionsPromise = null;
	      this._structTreePromise = null;
	      this.pendingCleanup = false;
	      return Promise.all(waitOn);
	    }
	  }, {
	    key: "cleanup",
	    value: function cleanup() {
	      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      this.pendingCleanup = true;
	      return this._tryCleanup(resetStats);
	    }
	  }, {
	    key: "_tryCleanup",
	    value: function _tryCleanup() {
	      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (!this.pendingCleanup) {
	        return false;
	      }

	      var _iterator8 = _createForOfIteratorHelper(this._intentStates.values()),
	          _step8;

	      try {
	        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
	          var _step8$value = _step8.value,
	              renderTasks = _step8$value.renderTasks,
	              operatorList = _step8$value.operatorList;

	          if (renderTasks.size > 0 || !operatorList.lastChunk) {
	            return false;
	          }
	        }
	      } catch (err) {
	        _iterator8.e(err);
	      } finally {
	        _iterator8.f();
	      }

	      this._intentStates.clear();

	      this.objs.clear();

	      this._annotationPromises.clear();

	      this._jsActionsPromise = null;
	      this._structTreePromise = null;

	      if (resetStats && this._stats) {
	        this._stats = new _display_utils.StatTimer();
	      }

	      this.pendingCleanup = false;
	      return true;
	    }
	  }, {
	    key: "_startRenderPage",
	    value: function _startRenderPage(transparency, cacheKey) {
	      var intentState = this._intentStates.get(cacheKey);

	      if (!intentState) {
	        return;
	      }

	      if (this._stats) {
	        this._stats.timeEnd("Page Request");
	      }

	      if (intentState.displayReadyCapability) {
	        intentState.displayReadyCapability.resolve(transparency);
	      }
	    }
	  }, {
	    key: "_renderPageChunk",
	    value: function _renderPageChunk(operatorListChunk, intentState) {
	      for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
	        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
	        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
	      }

	      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

	      var _iterator9 = _createForOfIteratorHelper(intentState.renderTasks),
	          _step9;

	      try {
	        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
	          var internalRenderTask = _step9.value;
	          internalRenderTask.operatorListChanged();
	        }
	      } catch (err) {
	        _iterator9.e(err);
	      } finally {
	        _iterator9.f();
	      }

	      if (operatorListChunk.lastChunk) {
	        this._tryCleanup();
	      }
	    }
	  }, {
	    key: "_pumpOperatorList",
	    value: function _pumpOperatorList(_ref11) {
	      var _this6 = this;

	      var renderingIntent = _ref11.renderingIntent,
	          cacheKey = _ref11.cacheKey;

	      var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
	        pageIndex: this._pageIndex,
	        intent: renderingIntent,
	        cacheKey: cacheKey,
	        annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
	      });

	      var reader = readableStream.getReader();

	      var intentState = this._intentStates.get(cacheKey);

	      intentState.streamReader = reader;

	      var pump = function pump() {
	        reader.read().then(function (_ref12) {
	          var value = _ref12.value,
	              done = _ref12.done;

	          if (done) {
	            intentState.streamReader = null;
	            return;
	          }

	          if (_this6._transport.destroyed) {
	            return;
	          }

	          _this6._renderPageChunk(value, intentState);

	          pump();
	        }, function (reason) {
	          intentState.streamReader = null;

	          if (_this6._transport.destroyed) {
	            return;
	          }

	          if (intentState.operatorList) {
	            intentState.operatorList.lastChunk = true;

	            var _iterator10 = _createForOfIteratorHelper(intentState.renderTasks),
	                _step10;

	            try {
	              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
	                var internalRenderTask = _step10.value;
	                internalRenderTask.operatorListChanged();
	              }
	            } catch (err) {
	              _iterator10.e(err);
	            } finally {
	              _iterator10.f();
	            }

	            _this6._tryCleanup();
	          }

	          if (intentState.displayReadyCapability) {
	            intentState.displayReadyCapability.reject(reason);
	          } else if (intentState.opListReadCapability) {
	            intentState.opListReadCapability.reject(reason);
	          } else {
	            throw reason;
	          }
	        });
	      };

	      pump();
	    }
	  }, {
	    key: "_abortOperatorList",
	    value: function _abortOperatorList(_ref13) {
	      var _this7 = this;

	      var intentState = _ref13.intentState,
	          reason = _ref13.reason,
	          _ref13$force = _ref13.force,
	          force = _ref13$force === void 0 ? false : _ref13$force;

	      if (!intentState.streamReader) {
	        return;
	      }

	      if (!force) {
	        if (intentState.renderTasks.size > 0) {
	          return;
	        }

	        if (reason instanceof _display_utils.RenderingCancelledException) {
	          intentState.streamReaderCancelTimeout = setTimeout(function () {
	            _this7._abortOperatorList({
	              intentState: intentState,
	              reason: reason,
	              force: true
	            });

	            intentState.streamReaderCancelTimeout = null;
	          }, RENDERING_CANCELLED_TIMEOUT);
	          return;
	        }
	      }

	      intentState.streamReader.cancel(new _util.AbortException(reason.message))["catch"](function () {});
	      intentState.streamReader = null;

	      if (this._transport.destroyed) {
	        return;
	      }

	      var _iterator11 = _createForOfIteratorHelper(this._intentStates),
	          _step11;

	      try {
	        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
	          var _step11$value = _slicedToArray(_step11.value, 2),
	              curCacheKey = _step11$value[0],
	              curIntentState = _step11$value[1];

	          if (curIntentState === intentState) {
	            this._intentStates["delete"](curCacheKey);

	            break;
	          }
	        }
	      } catch (err) {
	        _iterator11.e(err);
	      } finally {
	        _iterator11.f();
	      }

	      this.cleanup();
	    }
	  }, {
	    key: "stats",
	    get: function get() {
	      return this._stats;
	    }
	  }]);

	  return PDFPageProxy;
	}();

	exports.PDFPageProxy = PDFPageProxy;

	var LoopbackPort = /*#__PURE__*/function () {
	  function LoopbackPort() {
	    _classCallCheck(this, LoopbackPort);

	    this._listeners = [];
	    this._deferred = Promise.resolve();
	  }

	  _createClass(LoopbackPort, [{
	    key: "postMessage",
	    value: function postMessage(obj, transfers) {
	      var _this8 = this;

	      function cloneValue(object) {
	        if (globalThis.structuredClone) {
	          return globalThis.structuredClone(object, transfers);
	        }

	        function fallbackCloneValue(value) {
	          if (typeof value === "function" || _typeof(value) === "symbol" || value instanceof URL) {
	            throw new Error("LoopbackPort.postMessage - cannot clone: ".concat(value === null || value === void 0 ? void 0 : value.toString()));
	          }

	          if (_typeof(value) !== "object" || value === null) {
	            return value;
	          }

	          if (cloned.has(value)) {
	            return cloned.get(value);
	          }

	          var buffer, result;

	          if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
	            if (transfers !== null && transfers !== void 0 && transfers.includes(buffer)) {
	              result = new value.constructor(buffer, value.byteOffset, value.byteLength);
	            } else {
	              result = new value.constructor(value);
	            }

	            cloned.set(value, result);
	            return result;
	          }

	          if (value instanceof Map) {
	            result = new Map();
	            cloned.set(value, result);

	            var _iterator12 = _createForOfIteratorHelper(value),
	                _step12;

	            try {
	              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
	                var _step12$value = _slicedToArray(_step12.value, 2),
	                    key = _step12$value[0],
	                    val = _step12$value[1];

	                result.set(key, fallbackCloneValue(val));
	              }
	            } catch (err) {
	              _iterator12.e(err);
	            } finally {
	              _iterator12.f();
	            }

	            return result;
	          }

	          if (value instanceof Set) {
	            result = new Set();
	            cloned.set(value, result);

	            var _iterator13 = _createForOfIteratorHelper(value),
	                _step13;

	            try {
	              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
	                var _val = _step13.value;
	                result.add(fallbackCloneValue(_val));
	              }
	            } catch (err) {
	              _iterator13.e(err);
	            } finally {
	              _iterator13.f();
	            }

	            return result;
	          }

	          result = Array.isArray(value) ? [] : Object.create(null);
	          cloned.set(value, result);

	          for (var i in value) {
	            var _value$hasOwnProperty;

	            var desc = void 0,
	                p = value;

	            while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
	              p = Object.getPrototypeOf(p);
	            }

	            if (typeof desc.value === "undefined") {
	              continue;
	            }

	            if (typeof desc.value === "function" && !((_value$hasOwnProperty = value.hasOwnProperty) !== null && _value$hasOwnProperty !== void 0 && _value$hasOwnProperty.call(value, i))) {
	              continue;
	            }

	            result[i] = fallbackCloneValue(desc.value);
	          }

	          return result;
	        }

	        var cloned = new WeakMap();
	        return fallbackCloneValue(object);
	      }

	      var event = {
	        data: cloneValue(obj)
	      };

	      this._deferred.then(function () {
	        var _iterator14 = _createForOfIteratorHelper(_this8._listeners),
	            _step14;

	        try {
	          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
	            var listener = _step14.value;
	            listener.call(_this8, event);
	          }
	        } catch (err) {
	          _iterator14.e(err);
	        } finally {
	          _iterator14.f();
	        }
	      });
	    }
	  }, {
	    key: "addEventListener",
	    value: function addEventListener(name, listener) {
	      this._listeners.push(listener);
	    }
	  }, {
	    key: "removeEventListener",
	    value: function removeEventListener(name, listener) {
	      var i = this._listeners.indexOf(listener);

	      this._listeners.splice(i, 1);
	    }
	  }, {
	    key: "terminate",
	    value: function terminate() {
	      this._listeners.length = 0;
	    }
	  }]);

	  return LoopbackPort;
	}();

	exports.LoopbackPort = LoopbackPort;
	var PDFWorkerUtil = {
	  isWorkerDisabled: false,
	  fallbackWorkerSrc: null,
	  fakeWorkerId: 0
	};
	{
	  if (_is_node.isNodeJS && typeof commonjsRequire$1 === "function") {
	    PDFWorkerUtil.isWorkerDisabled = true;
	    PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
	  } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object") {
	    var _document, _document$currentScri;

	    var pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;

	    if (pdfjsFilePath) {
	      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
	    }
	  }

	  PDFWorkerUtil.createCDNWrapper = function (url) {
	    var wrapper = "importScripts(\"".concat(url, "\");");
	    return URL.createObjectURL(new Blob([wrapper]));
	  };
	}

	var PDFWorker = /*#__PURE__*/function () {
	  function PDFWorker() {
	    var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref14$name = _ref14.name,
	        name = _ref14$name === void 0 ? null : _ref14$name,
	        _ref14$port = _ref14.port,
	        port = _ref14$port === void 0 ? null : _ref14$port,
	        _ref14$verbosity = _ref14.verbosity,
	        verbosity = _ref14$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref14$verbosity;

	    _classCallCheck(this, PDFWorker);

	    if (port && PDFWorker._workerPorts.has(port)) {
	      throw new Error("Cannot use more than one PDFWorker per port.");
	    }

	    this.name = name;
	    this.destroyed = false;
	    this.verbosity = verbosity;
	    this._readyCapability = (0, _util.createPromiseCapability)();
	    this._port = null;
	    this._webWorker = null;
	    this._messageHandler = null;

	    if (port) {
	      PDFWorker._workerPorts.set(port, this);

	      this._initializeFromPort(port);

	      return;
	    }

	    this._initialize();
	  }

	  _createClass(PDFWorker, [{
	    key: "promise",
	    get: function get() {
	      return this._readyCapability.promise;
	    }
	  }, {
	    key: "port",
	    get: function get() {
	      return this._port;
	    }
	  }, {
	    key: "messageHandler",
	    get: function get() {
	      return this._messageHandler;
	    }
	  }, {
	    key: "_initializeFromPort",
	    value: function _initializeFromPort(port) {
	      this._port = port;
	      this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

	      this._messageHandler.on("ready", function () {});

	      this._readyCapability.resolve();
	    }
	  }, {
	    key: "_initialize",
	    value: function _initialize() {
	      var _this9 = this;

	      if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
	        var workerSrc = PDFWorker.workerSrc;

	        try {
	          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
	            workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
	          }

	          var worker = new Worker(workerSrc);
	          var messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

	          var terminateEarly = function terminateEarly() {
	            worker.removeEventListener("error", onWorkerError);
	            messageHandler.destroy();
	            worker.terminate();

	            if (_this9.destroyed) {
	              _this9._readyCapability.reject(new Error("Worker was destroyed"));
	            } else {
	              _this9._setupFakeWorker();
	            }
	          };

	          var onWorkerError = function onWorkerError() {
	            if (!_this9._webWorker) {
	              terminateEarly();
	            }
	          };

	          worker.addEventListener("error", onWorkerError);
	          messageHandler.on("test", function (data) {
	            worker.removeEventListener("error", onWorkerError);

	            if (_this9.destroyed) {
	              terminateEarly();
	              return;
	            }

	            if (data) {
	              _this9._messageHandler = messageHandler;
	              _this9._port = worker;
	              _this9._webWorker = worker;

	              _this9._readyCapability.resolve();

	              messageHandler.send("configure", {
	                verbosity: _this9.verbosity
	              });
	            } else {
	              _this9._setupFakeWorker();

	              messageHandler.destroy();
	              worker.terminate();
	            }
	          });
	          messageHandler.on("ready", function (data) {
	            worker.removeEventListener("error", onWorkerError);

	            if (_this9.destroyed) {
	              terminateEarly();
	              return;
	            }

	            try {
	              sendTest();
	            } catch (e) {
	              _this9._setupFakeWorker();
	            }
	          });

	          var sendTest = function sendTest() {
	            var testObj = new Uint8Array([255]);

	            try {
	              messageHandler.send("test", testObj, [testObj.buffer]);
	            } catch (ex) {
	              (0, _util.warn)("Cannot use postMessage transfers.");
	              testObj[0] = 0;
	              messageHandler.send("test", testObj);
	            }
	          };

	          sendTest();
	          return;
	        } catch (e) {
	          (0, _util.info)("The worker has been disabled.");
	        }
	      }

	      this._setupFakeWorker();
	    }
	  }, {
	    key: "_setupFakeWorker",
	    value: function _setupFakeWorker() {
	      var _this10 = this;

	      if (!PDFWorkerUtil.isWorkerDisabled) {
	        (0, _util.warn)("Setting up fake worker.");
	        PDFWorkerUtil.isWorkerDisabled = true;
	      }

	      PDFWorker._setupFakeWorkerGlobal.then(function (WorkerMessageHandler) {
	        if (_this10.destroyed) {
	          _this10._readyCapability.reject(new Error("Worker was destroyed"));

	          return;
	        }

	        var port = new LoopbackPort();
	        _this10._port = port;
	        var id = "fake".concat(PDFWorkerUtil.fakeWorkerId++);
	        var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
	        WorkerMessageHandler.setup(workerHandler, port);
	        var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
	        _this10._messageHandler = messageHandler;

	        _this10._readyCapability.resolve();

	        messageHandler.send("configure", {
	          verbosity: _this10.verbosity
	        });
	      })["catch"](function (reason) {
	        _this10._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\".")));
	      });
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.destroyed = true;

	      if (this._webWorker) {
	        this._webWorker.terminate();

	        this._webWorker = null;
	      }

	      PDFWorker._workerPorts["delete"](this._port);

	      this._port = null;

	      if (this._messageHandler) {
	        this._messageHandler.destroy();

	        this._messageHandler = null;
	      }
	    }
	  }], [{
	    key: "_workerPorts",
	    get: function get() {
	      return (0, _util.shadow)(this, "_workerPorts", new WeakMap());
	    }
	  }, {
	    key: "fromPort",
	    value: function fromPort(params) {
	      if (!(params !== null && params !== void 0 && params.port)) {
	        throw new Error("PDFWorker.fromPort - invalid method signature.");
	      }

	      if (this._workerPorts.has(params.port)) {
	        return this._workerPorts.get(params.port);
	      }

	      return new PDFWorker(params);
	    }
	  }, {
	    key: "workerSrc",
	    get: function get() {
	      if (_worker_options.GlobalWorkerOptions.workerSrc) {
	        return _worker_options.GlobalWorkerOptions.workerSrc;
	      }

	      if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
	        if (!_is_node.isNodeJS) {
	          (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
	        }

	        return PDFWorkerUtil.fallbackWorkerSrc;
	      }

	      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
	    }
	  }, {
	    key: "_mainThreadWorkerMessageHandler",
	    get: function get() {
	      try {
	        var _globalThis$pdfjsWork;

	        return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
	      } catch (ex) {
	        return null;
	      }
	    }
	  }, {
	    key: "_setupFakeWorkerGlobal",
	    get: function get() {
	      var _this11 = this;

	      var loader = /*#__PURE__*/function () {
	        var _ref15 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
	          var mainWorkerMessageHandler, worker;
	          return _regenerator["default"].wrap(function _callee4$(_context4) {
	            while (1) {
	              switch (_context4.prev = _context4.next) {
	                case 0:
	                  mainWorkerMessageHandler = _this11._mainThreadWorkerMessageHandler;

	                  if (!mainWorkerMessageHandler) {
	                    _context4.next = 3;
	                    break;
	                  }

	                  return _context4.abrupt("return", mainWorkerMessageHandler);

	                case 3:
	                  if (!(_is_node.isNodeJS && typeof commonjsRequire$1 === "function")) {
	                    _context4.next = 6;
	                    break;
	                  }

	                  worker = eval("require")(_this11.workerSrc);
	                  return _context4.abrupt("return", worker.WorkerMessageHandler);

	                case 6:
	                  _context4.next = 8;
	                  return (0, _display_utils.loadScript)(_this11.workerSrc);

	                case 8:
	                  return _context4.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);

	                case 9:
	                case "end":
	                  return _context4.stop();
	              }
	            }
	          }, _callee4);
	        }));

	        return function loader() {
	          return _ref15.apply(this, arguments);
	        };
	      }();

	      return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
	    }
	  }]);

	  return PDFWorker;
	}();

	exports.PDFWorker = PDFWorker;
	{
	  PDFWorker.getWorkerSrc = function () {
	    (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
	    return this.workerSrc;
	  };
	}

	var _docStats = /*#__PURE__*/new WeakMap();

	var _pageCache = /*#__PURE__*/new WeakMap();

	var _pagePromises = /*#__PURE__*/new WeakMap();

	var _metadataPromise = /*#__PURE__*/new WeakMap();

	var WorkerTransport = /*#__PURE__*/function () {
	  function WorkerTransport(messageHandler, loadingTask, networkStream, params) {
	    _classCallCheck(this, WorkerTransport);

	    _classPrivateFieldInitSpec(this, _docStats, {
	      writable: true,
	      value: null
	    });

	    _classPrivateFieldInitSpec(this, _pageCache, {
	      writable: true,
	      value: new Map()
	    });

	    _classPrivateFieldInitSpec(this, _pagePromises, {
	      writable: true,
	      value: new Map()
	    });

	    _classPrivateFieldInitSpec(this, _metadataPromise, {
	      writable: true,
	      value: null
	    });

	    this.messageHandler = messageHandler;
	    this.loadingTask = loadingTask;
	    this.commonObjs = new PDFObjects();
	    this.fontLoader = new _font_loader.FontLoader({
	      docId: loadingTask.docId,
	      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
	      ownerDocument: params.ownerDocument,
	      styleElement: params.styleElement
	    });
	    this._params = params;

	    if (!params.useWorkerFetch) {
	      this.CMapReaderFactory = new params.CMapReaderFactory({
	        baseUrl: params.cMapUrl,
	        isCompressed: params.cMapPacked
	      });
	      this.StandardFontDataFactory = new params.StandardFontDataFactory({
	        baseUrl: params.standardFontDataUrl
	      });
	    }

	    this.destroyed = false;
	    this.destroyCapability = null;
	    this._passwordCapability = null;
	    this._networkStream = networkStream;
	    this._fullReader = null;
	    this._lastProgress = null;
	    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
	    this.setupMessageHandler();
	  }

	  _createClass(WorkerTransport, [{
	    key: "annotationStorage",
	    get: function get() {
	      return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
	    }
	  }, {
	    key: "stats",
	    get: function get() {
	      return _classPrivateFieldGet(this, _docStats);
	    }
	  }, {
	    key: "getRenderingIntent",
	    value: function getRenderingIntent(intent) {
	      var annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;
	      var isOpList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      var renderingIntent = _util.RenderingIntentFlag.DISPLAY;
	      var lastModified = "";

	      switch (intent) {
	        case "any":
	          renderingIntent = _util.RenderingIntentFlag.ANY;
	          break;

	        case "display":
	          break;

	        case "print":
	          renderingIntent = _util.RenderingIntentFlag.PRINT;
	          break;

	        default:
	          (0, _util.warn)("getRenderingIntent - invalid intent: ".concat(intent));
	      }

	      switch (annotationMode) {
	        case _util.AnnotationMode.DISABLE:
	          renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
	          break;

	        case _util.AnnotationMode.ENABLE:
	          break;

	        case _util.AnnotationMode.ENABLE_FORMS:
	          renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
	          break;

	        case _util.AnnotationMode.ENABLE_STORAGE:
	          renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
	          lastModified = this.annotationStorage.lastModified;
	          break;

	        default:
	          (0, _util.warn)("getRenderingIntent - invalid annotationMode: ".concat(annotationMode));
	      }

	      if (isOpList) {
	        renderingIntent += _util.RenderingIntentFlag.OPLIST;
	      }

	      return {
	        renderingIntent: renderingIntent,
	        cacheKey: "".concat(renderingIntent, "_").concat(lastModified)
	      };
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      var _this12 = this;

	      if (this.destroyCapability) {
	        return this.destroyCapability.promise;
	      }

	      this.destroyed = true;
	      this.destroyCapability = (0, _util.createPromiseCapability)();

	      if (this._passwordCapability) {
	        this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
	      }

	      var waitOn = [];

	      var _iterator15 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _pageCache).values()),
	          _step15;

	      try {
	        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
	          var page = _step15.value;
	          waitOn.push(page._destroy());
	        }
	      } catch (err) {
	        _iterator15.e(err);
	      } finally {
	        _iterator15.f();
	      }

	      _classPrivateFieldGet(this, _pageCache).clear();

	      _classPrivateFieldGet(this, _pagePromises).clear();

	      if (this.hasOwnProperty("annotationStorage")) {
	        this.annotationStorage.resetModified();
	      }

	      var terminated = this.messageHandler.sendWithPromise("Terminate", null);
	      waitOn.push(terminated);
	      Promise.all(waitOn).then(function () {
	        _this12.commonObjs.clear();

	        _this12.fontLoader.clear();

	        _classPrivateFieldSet(_this12, _metadataPromise, null);

	        _this12._getFieldObjectsPromise = null;
	        _this12._hasJSActionsPromise = null;

	        if (_this12._networkStream) {
	          _this12._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
	        }

	        if (_this12.messageHandler) {
	          _this12.messageHandler.destroy();

	          _this12.messageHandler = null;
	        }

	        _this12.destroyCapability.resolve();
	      }, this.destroyCapability.reject);
	      return this.destroyCapability.promise;
	    }
	  }, {
	    key: "setupMessageHandler",
	    value: function setupMessageHandler() {
	      var _this13 = this;

	      var messageHandler = this.messageHandler,
	          loadingTask = this.loadingTask;
	      messageHandler.on("GetReader", function (data, sink) {
	        (0, _util.assert)(_this13._networkStream, "GetReader - no `IPDFStream` instance available.");
	        _this13._fullReader = _this13._networkStream.getFullReader();

	        _this13._fullReader.onProgress = function (evt) {
	          _this13._lastProgress = {
	            loaded: evt.loaded,
	            total: evt.total
	          };
	        };

	        sink.onPull = function () {
	          _this13._fullReader.read().then(function (_ref16) {
	            var value = _ref16.value,
	                done = _ref16.done;

	            if (done) {
	              sink.close();
	              return;
	            }

	            (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
	            sink.enqueue(new Uint8Array(value), 1, [value]);
	          })["catch"](function (reason) {
	            sink.error(reason);
	          });
	        };

	        sink.onCancel = function (reason) {
	          _this13._fullReader.cancel(reason);

	          sink.ready["catch"](function (readyReason) {
	            if (_this13.destroyed) {
	              return;
	            }

	            throw readyReason;
	          });
	        };
	      });
	      messageHandler.on("ReaderHeadersReady", function (data) {
	        var headersCapability = (0, _util.createPromiseCapability)();
	        var fullReader = _this13._fullReader;
	        fullReader.headersReady.then(function () {
	          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
	            if (_this13._lastProgress) {
	              var _loadingTask$onProgre;

	              (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, _this13._lastProgress);
	            }

	            fullReader.onProgress = function (evt) {
	              var _loadingTask$onProgre2;

	              (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {
	                loaded: evt.loaded,
	                total: evt.total
	              });
	            };
	          }

	          headersCapability.resolve({
	            isStreamingSupported: fullReader.isStreamingSupported,
	            isRangeSupported: fullReader.isRangeSupported,
	            contentLength: fullReader.contentLength
	          });
	        }, headersCapability.reject);
	        return headersCapability.promise;
	      });
	      messageHandler.on("GetRangeReader", function (data, sink) {
	        (0, _util.assert)(_this13._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

	        var rangeReader = _this13._networkStream.getRangeReader(data.begin, data.end);

	        if (!rangeReader) {
	          sink.close();
	          return;
	        }

	        sink.onPull = function () {
	          rangeReader.read().then(function (_ref17) {
	            var value = _ref17.value,
	                done = _ref17.done;

	            if (done) {
	              sink.close();
	              return;
	            }

	            (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
	            sink.enqueue(new Uint8Array(value), 1, [value]);
	          })["catch"](function (reason) {
	            sink.error(reason);
	          });
	        };

	        sink.onCancel = function (reason) {
	          rangeReader.cancel(reason);
	          sink.ready["catch"](function (readyReason) {
	            if (_this13.destroyed) {
	              return;
	            }

	            throw readyReason;
	          });
	        };
	      });
	      messageHandler.on("GetDoc", function (_ref18) {
	        var pdfInfo = _ref18.pdfInfo;
	        _this13._numPages = pdfInfo.numPages;
	        _this13._htmlForXfa = pdfInfo.htmlForXfa;
	        delete pdfInfo.htmlForXfa;

	        loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this13));
	      });
	      messageHandler.on("DocException", function (ex) {
	        var reason;

	        switch (ex.name) {
	          case "PasswordException":
	            reason = new _util.PasswordException(ex.message, ex.code);
	            break;

	          case "InvalidPDFException":
	            reason = new _util.InvalidPDFException(ex.message);
	            break;

	          case "MissingPDFException":
	            reason = new _util.MissingPDFException(ex.message);
	            break;

	          case "UnexpectedResponseException":
	            reason = new _util.UnexpectedResponseException(ex.message, ex.status);
	            break;

	          case "UnknownErrorException":
	            reason = new _util.UnknownErrorException(ex.message, ex.details);
	            break;

	          default:
	            (0, _util.unreachable)("DocException - expected a valid Error.");
	        }

	        loadingTask._capability.reject(reason);
	      });
	      messageHandler.on("PasswordRequest", function (exception) {
	        _this13._passwordCapability = (0, _util.createPromiseCapability)();

	        if (loadingTask.onPassword) {
	          var updatePassword = function updatePassword(password) {
	            _this13._passwordCapability.resolve({
	              password: password
	            });
	          };

	          try {
	            loadingTask.onPassword(updatePassword, exception.code);
	          } catch (ex) {
	            _this13._passwordCapability.reject(ex);
	          }
	        } else {
	          _this13._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
	        }

	        return _this13._passwordCapability.promise;
	      });
	      messageHandler.on("DataLoaded", function (data) {
	        var _loadingTask$onProgre3;

	        (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {
	          loaded: data.length,
	          total: data.length
	        });

	        _this13.downloadInfoCapability.resolve(data);
	      });
	      messageHandler.on("StartRenderPage", function (data) {
	        if (_this13.destroyed) {
	          return;
	        }

	        var page = _classPrivateFieldGet(_this13, _pageCache).get(data.pageIndex);

	        page._startRenderPage(data.transparency, data.cacheKey);
	      });
	      messageHandler.on("commonobj", function (_ref19) {
	        var _globalThis$FontInspe;

	        var _ref20 = _slicedToArray(_ref19, 3),
	            id = _ref20[0],
	            type = _ref20[1],
	            exportedData = _ref20[2];

	        if (_this13.destroyed) {
	          return;
	        }

	        if (_this13.commonObjs.has(id)) {
	          return;
	        }

	        switch (type) {
	          case "Font":
	            var params = _this13._params;

	            if ("error" in exportedData) {
	              var exportedError = exportedData.error;
	              (0, _util.warn)("Error during font loading: ".concat(exportedError));

	              _this13.commonObjs.resolve(id, exportedError);

	              break;
	            }

	            var fontRegistry = null;

	            if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
	              fontRegistry = {
	                registerFont: function registerFont(font, url) {
	                  globalThis.FontInspector.fontAdded(font, url);
	                }
	              };
	            }

	            var font = new _font_loader.FontFaceObject(exportedData, {
	              isEvalSupported: params.isEvalSupported,
	              disableFontFace: params.disableFontFace,
	              ignoreErrors: params.ignoreErrors,
	              onUnsupportedFeature: _this13._onUnsupportedFeature.bind(_this13),
	              fontRegistry: fontRegistry
	            });

	            _this13.fontLoader.bind(font)["catch"](function (reason) {
	              return messageHandler.sendWithPromise("FontFallback", {
	                id: id
	              });
	            })["finally"](function () {
	              if (!params.fontExtraProperties && font.data) {
	                font.data = null;
	              }

	              _this13.commonObjs.resolve(id, font);
	            });

	            break;

	          case "FontPath":
	          case "Image":
	            _this13.commonObjs.resolve(id, exportedData);

	            break;

	          default:
	            throw new Error("Got unknown common object type ".concat(type));
	        }
	      });
	      messageHandler.on("obj", function (_ref21) {
	        var _imageData$data;

	        var _ref22 = _slicedToArray(_ref21, 4),
	            id = _ref22[0],
	            pageIndex = _ref22[1],
	            type = _ref22[2],
	            imageData = _ref22[3];

	        if (_this13.destroyed) {
	          return;
	        }

	        var pageProxy = _classPrivateFieldGet(_this13, _pageCache).get(pageIndex);

	        if (pageProxy.objs.has(id)) {
	          return;
	        }

	        switch (type) {
	          case "Image":
	            pageProxy.objs.resolve(id, imageData);
	            var MAX_IMAGE_SIZE_TO_STORE = 8000000;

	            if ((imageData === null || imageData === void 0 ? void 0 : (_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) > MAX_IMAGE_SIZE_TO_STORE) {
	              pageProxy.cleanupAfterRender = true;
	            }

	            break;

	          case "Pattern":
	            pageProxy.objs.resolve(id, imageData);
	            break;

	          default:
	            throw new Error("Got unknown object type ".concat(type));
	        }
	      });
	      messageHandler.on("DocProgress", function (data) {
	        var _loadingTask$onProgre4;

	        if (_this13.destroyed) {
	          return;
	        }

	        (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {
	          loaded: data.loaded,
	          total: data.total
	        });
	      });
	      messageHandler.on("DocStats", function (data) {
	        if (_this13.destroyed) {
	          return;
	        }

	        _classPrivateFieldSet(_this13, _docStats, Object.freeze({
	          streamTypes: Object.freeze(data.streamTypes),
	          fontTypes: Object.freeze(data.fontTypes)
	        }));
	      });
	      messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
	      messageHandler.on("FetchBuiltInCMap", function (data) {
	        if (_this13.destroyed) {
	          return Promise.reject(new Error("Worker was destroyed."));
	        }

	        if (!_this13.CMapReaderFactory) {
	          return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
	        }

	        return _this13.CMapReaderFactory.fetch(data);
	      });
	      messageHandler.on("FetchStandardFontData", function (data) {
	        if (_this13.destroyed) {
	          return Promise.reject(new Error("Worker was destroyed."));
	        }

	        if (!_this13.StandardFontDataFactory) {
	          return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
	        }

	        return _this13.StandardFontDataFactory.fetch(data);
	      });
	    }
	  }, {
	    key: "_onUnsupportedFeature",
	    value: function _onUnsupportedFeature(_ref23) {
	      var _this$loadingTask$onU, _this$loadingTask;

	      var featureId = _ref23.featureId;

	      if (this.destroyed) {
	        return;
	      }

	      (_this$loadingTask$onU = (_this$loadingTask = this.loadingTask).onUnsupportedFeature) === null || _this$loadingTask$onU === void 0 ? void 0 : _this$loadingTask$onU.call(_this$loadingTask, featureId);
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.messageHandler.sendWithPromise("GetData", null);
	    }
	  }, {
	    key: "getPage",
	    value: function getPage(pageNumber) {
	      var _this14 = this;

	      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
	        return Promise.reject(new Error("Invalid page request"));
	      }

	      var pageIndex = pageNumber - 1,
	          cachedPromise = _classPrivateFieldGet(this, _pagePromises).get(pageIndex);

	      if (cachedPromise) {
	        return cachedPromise;
	      }

	      var promise = this.messageHandler.sendWithPromise("GetPage", {
	        pageIndex: pageIndex
	      }).then(function (pageInfo) {
	        if (_this14.destroyed) {
	          throw new Error("Transport destroyed");
	        }

	        var page = new PDFPageProxy(pageIndex, pageInfo, _this14, _this14._params.ownerDocument, _this14._params.pdfBug);

	        _classPrivateFieldGet(_this14, _pageCache).set(pageIndex, page);

	        return page;
	      });

	      _classPrivateFieldGet(this, _pagePromises).set(pageIndex, promise);

	      return promise;
	    }
	  }, {
	    key: "getPageIndex",
	    value: function getPageIndex(ref) {
	      return this.messageHandler.sendWithPromise("GetPageIndex", {
	        ref: ref
	      });
	    }
	  }, {
	    key: "getAnnotations",
	    value: function getAnnotations(pageIndex, intent) {
	      return this.messageHandler.sendWithPromise("GetAnnotations", {
	        pageIndex: pageIndex,
	        intent: intent
	      });
	    }
	  }, {
	    key: "saveDocument",
	    value: function saveDocument() {
	      var _this$_fullReader$fil,
	          _this$_fullReader,
	          _this15 = this;

	      return this.messageHandler.sendWithPromise("SaveDocument", {
	        isPureXfa: !!this._htmlForXfa,
	        numPages: this._numPages,
	        annotationStorage: this.annotationStorage.serializable,
	        filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
	      })["finally"](function () {
	        _this15.annotationStorage.resetModified();
	      });
	    }
	  }, {
	    key: "getFieldObjects",
	    value: function getFieldObjects() {
	      return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
	    }
	  }, {
	    key: "hasJSActions",
	    value: function hasJSActions() {
	      return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
	    }
	  }, {
	    key: "getCalculationOrderIds",
	    value: function getCalculationOrderIds() {
	      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
	    }
	  }, {
	    key: "getDestinations",
	    value: function getDestinations() {
	      return this.messageHandler.sendWithPromise("GetDestinations", null);
	    }
	  }, {
	    key: "getDestination",
	    value: function getDestination(id) {
	      if (typeof id !== "string") {
	        return Promise.reject(new Error("Invalid destination request."));
	      }

	      return this.messageHandler.sendWithPromise("GetDestination", {
	        id: id
	      });
	    }
	  }, {
	    key: "getPageLabels",
	    value: function getPageLabels() {
	      return this.messageHandler.sendWithPromise("GetPageLabels", null);
	    }
	  }, {
	    key: "getPageLayout",
	    value: function getPageLayout() {
	      return this.messageHandler.sendWithPromise("GetPageLayout", null);
	    }
	  }, {
	    key: "getPageMode",
	    value: function getPageMode() {
	      return this.messageHandler.sendWithPromise("GetPageMode", null);
	    }
	  }, {
	    key: "getViewerPreferences",
	    value: function getViewerPreferences() {
	      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
	    }
	  }, {
	    key: "getOpenAction",
	    value: function getOpenAction() {
	      return this.messageHandler.sendWithPromise("GetOpenAction", null);
	    }
	  }, {
	    key: "getAttachments",
	    value: function getAttachments() {
	      return this.messageHandler.sendWithPromise("GetAttachments", null);
	    }
	  }, {
	    key: "getJavaScript",
	    value: function getJavaScript() {
	      return this.messageHandler.sendWithPromise("GetJavaScript", null);
	    }
	  }, {
	    key: "getDocJSActions",
	    value: function getDocJSActions() {
	      return this.messageHandler.sendWithPromise("GetDocJSActions", null);
	    }
	  }, {
	    key: "getPageJSActions",
	    value: function getPageJSActions(pageIndex) {
	      return this.messageHandler.sendWithPromise("GetPageJSActions", {
	        pageIndex: pageIndex
	      });
	    }
	  }, {
	    key: "getStructTree",
	    value: function getStructTree(pageIndex) {
	      return this.messageHandler.sendWithPromise("GetStructTree", {
	        pageIndex: pageIndex
	      });
	    }
	  }, {
	    key: "getOutline",
	    value: function getOutline() {
	      return this.messageHandler.sendWithPromise("GetOutline", null);
	    }
	  }, {
	    key: "getOptionalContentConfig",
	    value: function getOptionalContentConfig() {
	      return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(function (results) {
	        return new _optional_content_config.OptionalContentConfig(results);
	      });
	    }
	  }, {
	    key: "getPermissions",
	    value: function getPermissions() {
	      return this.messageHandler.sendWithPromise("GetPermissions", null);
	    }
	  }, {
	    key: "getMetadata",
	    value: function getMetadata() {
	      var _this16 = this;

	      return _classPrivateFieldGet(this, _metadataPromise) || _classPrivateFieldSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then(function (results) {
	        var _this16$_fullReader$f, _this16$_fullReader, _this16$_fullReader$c, _this16$_fullReader2;

	        return {
	          info: results[0],
	          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
	          contentDispositionFilename: (_this16$_fullReader$f = (_this16$_fullReader = _this16._fullReader) === null || _this16$_fullReader === void 0 ? void 0 : _this16$_fullReader.filename) !== null && _this16$_fullReader$f !== void 0 ? _this16$_fullReader$f : null,
	          contentLength: (_this16$_fullReader$c = (_this16$_fullReader2 = _this16._fullReader) === null || _this16$_fullReader2 === void 0 ? void 0 : _this16$_fullReader2.contentLength) !== null && _this16$_fullReader$c !== void 0 ? _this16$_fullReader$c : null
	        };
	      }));
	    }
	  }, {
	    key: "getMarkInfo",
	    value: function getMarkInfo() {
	      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
	    }
	  }, {
	    key: "startCleanup",
	    value: function () {
	      var _startCleanup = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
	        var keepLoadedFonts,
	            _iterator16,
	            _step16,
	            page,
	            cleanupSuccessful,
	            _args5 = arguments;

	        return _regenerator["default"].wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                keepLoadedFonts = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : false;
	                _context5.next = 3;
	                return this.messageHandler.sendWithPromise("Cleanup", null);

	              case 3:
	                if (!this.destroyed) {
	                  _context5.next = 5;
	                  break;
	                }

	                return _context5.abrupt("return");

	              case 5:
	                _iterator16 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _pageCache).values());
	                _context5.prev = 6;

	                _iterator16.s();

	              case 8:
	                if ((_step16 = _iterator16.n()).done) {
	                  _context5.next = 15;
	                  break;
	                }

	                page = _step16.value;
	                cleanupSuccessful = page.cleanup();

	                if (cleanupSuccessful) {
	                  _context5.next = 13;
	                  break;
	                }

	                throw new Error("startCleanup: Page ".concat(page.pageNumber, " is currently rendering."));

	              case 13:
	                _context5.next = 8;
	                break;

	              case 15:
	                _context5.next = 20;
	                break;

	              case 17:
	                _context5.prev = 17;
	                _context5.t0 = _context5["catch"](6);

	                _iterator16.e(_context5.t0);

	              case 20:
	                _context5.prev = 20;

	                _iterator16.f();

	                return _context5.finish(20);

	              case 23:
	                this.commonObjs.clear();

	                if (!keepLoadedFonts) {
	                  this.fontLoader.clear();
	                }

	                _classPrivateFieldSet(this, _metadataPromise, null);

	                this._getFieldObjectsPromise = null;
	                this._hasJSActionsPromise = null;

	              case 28:
	              case "end":
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this, [[6, 17, 20, 23]]);
	      }));

	      function startCleanup() {
	        return _startCleanup.apply(this, arguments);
	      }

	      return startCleanup;
	    }()
	  }, {
	    key: "loadingParams",
	    get: function get() {
	      var params = this._params;
	      return (0, _util.shadow)(this, "loadingParams", {
	        disableAutoFetch: params.disableAutoFetch,
	        enableXfa: params.enableXfa
	      });
	    }
	  }]);

	  return WorkerTransport;
	}();

	var PDFObjects = /*#__PURE__*/function () {
	  function PDFObjects() {
	    _classCallCheck(this, PDFObjects);

	    this._objs = Object.create(null);
	  }

	  _createClass(PDFObjects, [{
	    key: "_ensureObj",
	    value: function _ensureObj(objId) {
	      if (this._objs[objId]) {
	        return this._objs[objId];
	      }

	      return this._objs[objId] = {
	        capability: (0, _util.createPromiseCapability)(),
	        data: null,
	        resolved: false
	      };
	    }
	  }, {
	    key: "get",
	    value: function get(objId) {
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (callback) {
	        this._ensureObj(objId).capability.promise.then(callback);

	        return null;
	      }

	      var obj = this._objs[objId];

	      if (!obj || !obj.resolved) {
	        throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
	      }

	      return obj.data;
	    }
	  }, {
	    key: "has",
	    value: function has(objId) {
	      var obj = this._objs[objId];
	      return (obj === null || obj === void 0 ? void 0 : obj.resolved) || false;
	    }
	  }, {
	    key: "resolve",
	    value: function resolve(objId, data) {
	      var obj = this._ensureObj(objId);

	      obj.resolved = true;
	      obj.data = data;
	      obj.capability.resolve(data);
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this._objs = Object.create(null);
	    }
	  }]);

	  return PDFObjects;
	}();

	var RenderTask = /*#__PURE__*/function () {
	  function RenderTask(internalRenderTask) {
	    _classCallCheck(this, RenderTask);

	    this._internalRenderTask = internalRenderTask;
	    this.onContinue = null;
	  }

	  _createClass(RenderTask, [{
	    key: "promise",
	    get: function get() {
	      return this._internalRenderTask.capability.promise;
	    }
	  }, {
	    key: "cancel",
	    value: function cancel() {
	      this._internalRenderTask.cancel();
	    }
	  }]);

	  return RenderTask;
	}();

	exports.RenderTask = RenderTask;

	var InternalRenderTask = /*#__PURE__*/function () {
	  function InternalRenderTask(_ref24) {
	    var callback = _ref24.callback,
	        params = _ref24.params,
	        objs = _ref24.objs,
	        commonObjs = _ref24.commonObjs,
	        annotationCanvasMap = _ref24.annotationCanvasMap,
	        operatorList = _ref24.operatorList,
	        pageIndex = _ref24.pageIndex,
	        canvasFactory = _ref24.canvasFactory,
	        _ref24$useRequestAnim = _ref24.useRequestAnimationFrame,
	        useRequestAnimationFrame = _ref24$useRequestAnim === void 0 ? false : _ref24$useRequestAnim,
	        _ref24$pdfBug = _ref24.pdfBug,
	        pdfBug = _ref24$pdfBug === void 0 ? false : _ref24$pdfBug;

	    _classCallCheck(this, InternalRenderTask);

	    this.callback = callback;
	    this.params = params;
	    this.objs = objs;
	    this.commonObjs = commonObjs;
	    this.annotationCanvasMap = annotationCanvasMap;
	    this.operatorListIdx = null;
	    this.operatorList = operatorList;
	    this._pageIndex = pageIndex;
	    this.canvasFactory = canvasFactory;
	    this._pdfBug = pdfBug;
	    this.running = false;
	    this.graphicsReadyCallback = null;
	    this.graphicsReady = false;
	    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
	    this.cancelled = false;
	    this.capability = (0, _util.createPromiseCapability)();
	    this.task = new RenderTask(this);
	    this._cancelBound = this.cancel.bind(this);
	    this._continueBound = this._continue.bind(this);
	    this._scheduleNextBound = this._scheduleNext.bind(this);
	    this._nextBound = this._next.bind(this);
	    this._canvas = params.canvasContext.canvas;
	  }

	  _createClass(InternalRenderTask, [{
	    key: "completed",
	    get: function get() {
	      return this.capability.promise["catch"](function () {});
	    }
	  }, {
	    key: "initializeGraphics",
	    value: function initializeGraphics(_ref25) {
	      var _globalThis$StepperMa;

	      var _ref25$transparency = _ref25.transparency,
	          transparency = _ref25$transparency === void 0 ? false : _ref25$transparency,
	          optionalContentConfig = _ref25.optionalContentConfig;

	      if (this.cancelled) {
	        return;
	      }

	      if (this._canvas) {
	        if (InternalRenderTask.canvasInUse.has(this._canvas)) {
	          throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
	        }

	        InternalRenderTask.canvasInUse.add(this._canvas);
	      }

	      if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
	        this.stepper = globalThis.StepperManager.create(this._pageIndex);
	        this.stepper.init(this.operatorList);
	        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
	      }

	      var _this$params = this.params,
	          canvasContext = _this$params.canvasContext,
	          viewport = _this$params.viewport,
	          transform = _this$params.transform,
	          imageLayer = _this$params.imageLayer,
	          background = _this$params.background;
	      this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap);
	      this.gfx.beginDrawing({
	        transform: transform,
	        viewport: viewport,
	        transparency: transparency,
	        background: background
	      });
	      this.operatorListIdx = 0;
	      this.graphicsReady = true;

	      if (this.graphicsReadyCallback) {
	        this.graphicsReadyCallback();
	      }
	    }
	  }, {
	    key: "cancel",
	    value: function cancel() {
	      var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      this.running = false;
	      this.cancelled = true;

	      if (this.gfx) {
	        this.gfx.endDrawing();
	      }

	      if (this._canvas) {
	        InternalRenderTask.canvasInUse["delete"](this._canvas);
	      }

	      this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
	    }
	  }, {
	    key: "operatorListChanged",
	    value: function operatorListChanged() {
	      if (!this.graphicsReady) {
	        if (!this.graphicsReadyCallback) {
	          this.graphicsReadyCallback = this._continueBound;
	        }

	        return;
	      }

	      if (this.stepper) {
	        this.stepper.updateOperatorList(this.operatorList);
	      }

	      if (this.running) {
	        return;
	      }

	      this._continue();
	    }
	  }, {
	    key: "_continue",
	    value: function _continue() {
	      this.running = true;

	      if (this.cancelled) {
	        return;
	      }

	      if (this.task.onContinue) {
	        this.task.onContinue(this._scheduleNextBound);
	      } else {
	        this._scheduleNext();
	      }
	    }
	  }, {
	    key: "_scheduleNext",
	    value: function _scheduleNext() {
	      var _this17 = this;

	      if (this._useRequestAnimationFrame) {
	        window.requestAnimationFrame(function () {
	          _this17._nextBound()["catch"](_this17._cancelBound);
	        });
	      } else {
	        Promise.resolve().then(this._nextBound)["catch"](this._cancelBound);
	      }
	    }
	  }, {
	    key: "_next",
	    value: function () {
	      var _next2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
	        return _regenerator["default"].wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                if (!this.cancelled) {
	                  _context6.next = 2;
	                  break;
	                }

	                return _context6.abrupt("return");

	              case 2:
	                this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

	                if (this.operatorListIdx === this.operatorList.argsArray.length) {
	                  this.running = false;

	                  if (this.operatorList.lastChunk) {
	                    this.gfx.endDrawing();

	                    if (this._canvas) {
	                      InternalRenderTask.canvasInUse["delete"](this._canvas);
	                    }

	                    this.callback();
	                  }
	                }

	              case 4:
	              case "end":
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this);
	      }));

	      function _next() {
	        return _next2.apply(this, arguments);
	      }

	      return _next;
	    }()
	  }], [{
	    key: "canvasInUse",
	    get: function get() {
	      return (0, _util.shadow)(this, "canvasInUse", new WeakSet());
	    }
	  }]);

	  return InternalRenderTask;
	}();

	var version = '2.12.313';
	exports.version = version;
	var build = 'a2ae56f39';
	exports.build = build;

	/***/ }),
	/* 137 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.FontLoader = exports.FontFaceObject = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var BaseFontLoader = /*#__PURE__*/function () {
	  function BaseFontLoader(_ref) {
	    var docId = _ref.docId,
	        onUnsupportedFeature = _ref.onUnsupportedFeature,
	        _ref$ownerDocument = _ref.ownerDocument,
	        ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;
	        _ref.styleElement;

	    _classCallCheck(this, BaseFontLoader);

	    if (this.constructor === BaseFontLoader) {
	      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
	    }

	    this.docId = docId;
	    this._onUnsupportedFeature = onUnsupportedFeature;
	    this._document = ownerDocument;
	    this.nativeFontFaces = [];
	    this.styleElement = null;
	  }

	  _createClass(BaseFontLoader, [{
	    key: "addNativeFontFace",
	    value: function addNativeFontFace(nativeFontFace) {
	      this.nativeFontFaces.push(nativeFontFace);

	      this._document.fonts.add(nativeFontFace);
	    }
	  }, {
	    key: "insertRule",
	    value: function insertRule(rule) {
	      var styleElement = this.styleElement;

	      if (!styleElement) {
	        styleElement = this.styleElement = this._document.createElement("style");
	        styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);

	        this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
	      }

	      var styleSheet = styleElement.sheet;
	      styleSheet.insertRule(rule, styleSheet.cssRules.length);
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _iterator = _createForOfIteratorHelper(this.nativeFontFaces),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var nativeFontFace = _step.value;

	          this._document.fonts["delete"](nativeFontFace);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      this.nativeFontFaces.length = 0;

	      if (this.styleElement) {
	        this.styleElement.remove();
	        this.styleElement = null;
	      }
	    }
	  }, {
	    key: "bind",
	    value: function () {
	      var _bind = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(font) {
	        var _this = this;

	        var nativeFontFace, rule;
	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(font.attached || font.missingFile)) {
	                  _context.next = 2;
	                  break;
	                }

	                return _context.abrupt("return");

	              case 2:
	                font.attached = true;

	                if (!this.isFontLoadingAPISupported) {
	                  _context.next = 19;
	                  break;
	                }

	                nativeFontFace = font.createNativeFontFace();

	                if (!nativeFontFace) {
	                  _context.next = 18;
	                  break;
	                }

	                this.addNativeFontFace(nativeFontFace);
	                _context.prev = 7;
	                _context.next = 10;
	                return nativeFontFace.loaded;

	              case 10:
	                _context.next = 18;
	                break;

	              case 12:
	                _context.prev = 12;
	                _context.t0 = _context["catch"](7);

	                this._onUnsupportedFeature({
	                  featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
	                });

	                (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context.t0, "'."));
	                font.disableFontFace = true;
	                throw _context.t0;

	              case 18:
	                return _context.abrupt("return");

	              case 19:
	                rule = font.createFontFaceRule();

	                if (!rule) {
	                  _context.next = 26;
	                  break;
	                }

	                this.insertRule(rule);

	                if (!this.isSyncFontLoadingSupported) {
	                  _context.next = 24;
	                  break;
	                }

	                return _context.abrupt("return");

	              case 24:
	                _context.next = 26;
	                return new Promise(function (resolve) {
	                  var request = _this._queueLoadingCallback(resolve);

	                  _this._prepareFontLoadEvent([rule], [font], request);
	                });

	              case 26:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[7, 12]]);
	      }));

	      function bind(_x) {
	        return _bind.apply(this, arguments);
	      }

	      return bind;
	    }()
	  }, {
	    key: "_queueLoadingCallback",
	    value: function _queueLoadingCallback(callback) {
	      (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
	    }
	  }, {
	    key: "isFontLoadingAPISupported",
	    get: function get() {
	      var _this$_document;

	      var hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
	      return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
	    }
	  }, {
	    key: "isSyncFontLoadingSupported",
	    get: function get() {
	      (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
	    }
	  }, {
	    key: "_loadTestFont",
	    get: function get() {
	      (0, _util.unreachable)("Abstract method `_loadTestFont`.");
	    }
	  }, {
	    key: "_prepareFontLoadEvent",
	    value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
	      (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
	    }
	  }]);

	  return BaseFontLoader;
	}();

	var FontLoader;
	exports.FontLoader = FontLoader;
	{
	  exports.FontLoader = FontLoader = /*#__PURE__*/function (_BaseFontLoader) {
	    _inherits(GenericFontLoader, _BaseFontLoader);

	    var _super = _createSuper(GenericFontLoader);

	    function GenericFontLoader(params) {
	      var _this2;

	      _classCallCheck(this, GenericFontLoader);

	      _this2 = _super.call(this, params);
	      _this2.loadingContext = {
	        requests: [],
	        nextRequestId: 0
	      };
	      _this2.loadTestFontId = 0;
	      return _this2;
	    }

	    _createClass(GenericFontLoader, [{
	      key: "isSyncFontLoadingSupported",
	      get: function get() {
	        var supported = false;

	        if (typeof navigator === "undefined") {
	          supported = true;
	        } else {
	          var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

	          if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
	            supported = true;
	          }
	        }

	        return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
	      }
	    }, {
	      key: "_queueLoadingCallback",
	      value: function _queueLoadingCallback(callback) {
	        function completeRequest() {
	          (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
	          request.done = true;

	          while (context.requests.length > 0 && context.requests[0].done) {
	            var otherRequest = context.requests.shift();
	            setTimeout(otherRequest.callback, 0);
	          }
	        }

	        var context = this.loadingContext;
	        var request = {
	          id: "pdfjs-font-loading-".concat(context.nextRequestId++),
	          done: false,
	          complete: completeRequest,
	          callback: callback
	        };
	        context.requests.push(request);
	        return request;
	      }
	    }, {
	      key: "_loadTestFont",
	      get: function get() {
	        var getLoadTestFont = function getLoadTestFont() {
	          return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
	        };

	        return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
	      }
	    }, {
	      key: "_prepareFontLoadEvent",
	      value: function _prepareFontLoadEvent(rules, fonts, request) {
	        function int32(data, offset) {
	          return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
	        }

	        function spliceString(s, offset, remove, insert) {
	          var chunk1 = s.substring(0, offset);
	          var chunk2 = s.substring(offset + remove);
	          return chunk1 + insert + chunk2;
	        }

	        var i, ii;

	        var canvas = this._document.createElement("canvas");

	        canvas.width = 1;
	        canvas.height = 1;
	        var ctx = canvas.getContext("2d");
	        var called = 0;

	        function isFontReady(name, callback) {
	          called++;

	          if (called > 30) {
	            (0, _util.warn)("Load test font never loaded.");
	            callback();
	            return;
	          }

	          ctx.font = "30px " + name;
	          ctx.fillText(".", 0, 20);
	          var imageData = ctx.getImageData(0, 0, 1, 1);

	          if (imageData.data[3] > 0) {
	            callback();
	            return;
	          }

	          setTimeout(isFontReady.bind(null, name, callback));
	        }

	        var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
	        var data = this._loadTestFont;
	        var COMMENT_OFFSET = 976;
	        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
	        var CFF_CHECKSUM_OFFSET = 16;
	        var XXXX_VALUE = 0x58585858;
	        var checksum = int32(data, CFF_CHECKSUM_OFFSET);

	        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
	          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
	        }

	        if (i < loadTestFontId.length) {
	          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
	        }

	        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
	        var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
	        var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}");
	        this.insertRule(rule);
	        var names = [];

	        var _iterator2 = _createForOfIteratorHelper(fonts),
	            _step2;

	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var font = _step2.value;
	            names.push(font.loadedName);
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }

	        names.push(loadTestFontId);

	        var div = this._document.createElement("div");

	        div.style.visibility = "hidden";
	        div.style.width = div.style.height = "10px";
	        div.style.position = "absolute";
	        div.style.top = div.style.left = "0px";

	        for (var _i = 0, _names = names; _i < _names.length; _i++) {
	          var name = _names[_i];

	          var span = this._document.createElement("span");

	          span.textContent = "Hi";
	          span.style.fontFamily = name;
	          div.appendChild(span);
	        }

	        this._document.body.appendChild(div);

	        isFontReady(loadTestFontId, function () {
	          div.remove();
	          request.complete();
	        });
	      }
	    }]);

	    return GenericFontLoader;
	  }(BaseFontLoader);
	}

	var FontFaceObject = /*#__PURE__*/function () {
	  function FontFaceObject(translatedData, _ref2) {
	    var _ref2$isEvalSupported = _ref2.isEvalSupported,
	        isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported,
	        _ref2$disableFontFace = _ref2.disableFontFace,
	        disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace,
	        _ref2$ignoreErrors = _ref2.ignoreErrors,
	        ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors,
	        onUnsupportedFeature = _ref2.onUnsupportedFeature,
	        _ref2$fontRegistry = _ref2.fontRegistry,
	        fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;

	    _classCallCheck(this, FontFaceObject);

	    this.compiledGlyphs = Object.create(null);

	    for (var i in translatedData) {
	      this[i] = translatedData[i];
	    }

	    this.isEvalSupported = isEvalSupported !== false;
	    this.disableFontFace = disableFontFace === true;
	    this.ignoreErrors = ignoreErrors === true;
	    this._onUnsupportedFeature = onUnsupportedFeature;
	    this.fontRegistry = fontRegistry;
	  }

	  _createClass(FontFaceObject, [{
	    key: "createNativeFontFace",
	    value: function createNativeFontFace() {
	      if (!this.data || this.disableFontFace) {
	        return null;
	      }

	      var nativeFontFace;

	      if (!this.cssFontInfo) {
	        nativeFontFace = new FontFace(this.loadedName, this.data, {});
	      } else {
	        var css = {
	          weight: this.cssFontInfo.fontWeight
	        };

	        if (this.cssFontInfo.italicAngle) {
	          css.style = "oblique ".concat(this.cssFontInfo.italicAngle, "deg");
	        }

	        nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
	      }

	      if (this.fontRegistry) {
	        this.fontRegistry.registerFont(this);
	      }

	      return nativeFontFace;
	    }
	  }, {
	    key: "createFontFaceRule",
	    value: function createFontFaceRule() {
	      if (!this.data || this.disableFontFace) {
	        return null;
	      }

	      var data = (0, _util.bytesToString)(this.data);
	      var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
	      var rule;

	      if (!this.cssFontInfo) {
	        rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}");
	      } else {
	        var css = "font-weight: ".concat(this.cssFontInfo.fontWeight, ";");

	        if (this.cssFontInfo.italicAngle) {
	          css += "font-style: oblique ".concat(this.cssFontInfo.italicAngle, "deg;");
	        }

	        rule = "@font-face {font-family:\"".concat(this.cssFontInfo.fontFamily, "\";").concat(css, "src:").concat(url, "}");
	      }

	      if (this.fontRegistry) {
	        this.fontRegistry.registerFont(this, url);
	      }

	      return rule;
	    }
	  }, {
	    key: "getPathGenerator",
	    value: function getPathGenerator(objs, character) {
	      if (this.compiledGlyphs[character] !== undefined) {
	        return this.compiledGlyphs[character];
	      }

	      var cmds;

	      try {
	        cmds = objs.get(this.loadedName + "_path_" + character);
	      } catch (ex) {
	        if (!this.ignoreErrors) {
	          throw ex;
	        }

	        this._onUnsupportedFeature({
	          featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
	        });

	        (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\"."));
	        return this.compiledGlyphs[character] = function (c, size) {};
	      }

	      if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
	        var jsBuf = [];

	        var _iterator3 = _createForOfIteratorHelper(cmds),
	            _step3;

	        try {
	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var current = _step3.value;
	            var args = current.args !== undefined ? current.args.join(",") : "";
	            jsBuf.push("c.", current.cmd, "(", args, ");\n");
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }

	        return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
	      }

	      return this.compiledGlyphs[character] = function (c, size) {
	        var _iterator4 = _createForOfIteratorHelper(cmds),
	            _step4;

	        try {
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var _current = _step4.value;

	            if (_current.cmd === "scale") {
	              _current.args = [size, -size];
	            }

	            c[_current.cmd].apply(c, _current.args);
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }
	      };
	    }
	  }]);

	  return FontFaceObject;
	}();

	exports.FontFaceObject = FontFaceObject;

	/***/ }),
	/* 138 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;

	var _base_factory = __w_pdfjs_require__(135);

	var _is_node = __w_pdfjs_require__(6);

	var _util = __w_pdfjs_require__(4);

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NodeCanvasFactory = function NodeCanvasFactory() {
	  _classCallCheck(this, NodeCanvasFactory);

	  (0, _util.unreachable)("Not implemented: NodeCanvasFactory");
	};

	exports.NodeCanvasFactory = NodeCanvasFactory;

	var NodeCMapReaderFactory = function NodeCMapReaderFactory() {
	  _classCallCheck(this, NodeCMapReaderFactory);

	  (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");
	};

	exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

	var NodeStandardFontDataFactory = function NodeStandardFontDataFactory() {
	  _classCallCheck(this, NodeStandardFontDataFactory);

	  (0, _util.unreachable)("Not implemented: NodeStandardFontDataFactory");
	};

	exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

	if (_is_node.isNodeJS) {
	  var fetchData = function fetchData(url) {
	    return new Promise(function (resolve, reject) {
	      var fs = require$$0;

	      fs.readFile(url, function (error, data) {
	        if (error || !data) {
	          reject(new Error(error));
	          return;
	        }

	        resolve(new Uint8Array(data));
	      });
	    });
	  };

	  exports.NodeCanvasFactory = NodeCanvasFactory = /*#__PURE__*/function (_BaseCanvasFactory) {
	    _inherits(NodeCanvasFactory, _BaseCanvasFactory);

	    var _super = _createSuper(NodeCanvasFactory);

	    function NodeCanvasFactory() {
	      _classCallCheck(this, NodeCanvasFactory);

	      return _super.apply(this, arguments);
	    }

	    _createClass(NodeCanvasFactory, [{
	      key: "_createCanvas",
	      value: function _createCanvas(width, height) {
	        var Canvas = require$$0;

	        return Canvas.createCanvas(width, height);
	      }
	    }]);

	    return NodeCanvasFactory;
	  }(_base_factory.BaseCanvasFactory);

	  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = /*#__PURE__*/function (_BaseCMapReaderFactor) {
	    _inherits(NodeCMapReaderFactory, _BaseCMapReaderFactor);

	    var _super2 = _createSuper(NodeCMapReaderFactory);

	    function NodeCMapReaderFactory() {
	      _classCallCheck(this, NodeCMapReaderFactory);

	      return _super2.apply(this, arguments);
	    }

	    _createClass(NodeCMapReaderFactory, [{
	      key: "_fetchData",
	      value: function _fetchData(url, compressionType) {
	        return fetchData(url).then(function (data) {
	          return {
	            cMapData: data,
	            compressionType: compressionType
	          };
	        });
	      }
	    }]);

	    return NodeCMapReaderFactory;
	  }(_base_factory.BaseCMapReaderFactory);

	  exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory = /*#__PURE__*/function (_BaseStandardFontData) {
	    _inherits(NodeStandardFontDataFactory, _BaseStandardFontData);

	    var _super3 = _createSuper(NodeStandardFontDataFactory);

	    function NodeStandardFontDataFactory() {
	      _classCallCheck(this, NodeStandardFontDataFactory);

	      return _super3.apply(this, arguments);
	    }

	    _createClass(NodeStandardFontDataFactory, [{
	      key: "_fetchData",
	      value: function _fetchData(url) {
	        return fetchData(url);
	      }
	    }]);

	    return NodeStandardFontDataFactory;
	  }(_base_factory.BaseStandardFontDataFactory);
	}

	/***/ }),
	/* 139 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.AnnotationStorage = void 0;

	var _util = __w_pdfjs_require__(4);

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var AnnotationStorage = /*#__PURE__*/function () {
	  function AnnotationStorage() {
	    _classCallCheck(this, AnnotationStorage);

	    this._storage = new Map();
	    this._timeStamp = Date.now();
	    this._modified = false;
	    this.onSetModified = null;
	    this.onResetModified = null;
	  }

	  _createClass(AnnotationStorage, [{
	    key: "getValue",
	    value: function getValue(key, defaultValue) {
	      var value = this._storage.get(key);

	      if (value === undefined) {
	        return defaultValue;
	      }

	      return Object.assign(defaultValue, value);
	    }
	  }, {
	    key: "setValue",
	    value: function setValue(key, value) {
	      var obj = this._storage.get(key);

	      var modified = false;

	      if (obj !== undefined) {
	        for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
	          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
	              entry = _Object$entries$_i[0],
	              val = _Object$entries$_i[1];

	          if (obj[entry] !== val) {
	            modified = true;
	            obj[entry] = val;
	          }
	        }
	      } else {
	        modified = true;

	        this._storage.set(key, value);
	      }

	      if (modified) {
	        this._timeStamp = Date.now();

	        this._setModified();
	      }
	    }
	  }, {
	    key: "getAll",
	    value: function getAll() {
	      return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
	    }
	  }, {
	    key: "size",
	    get: function get() {
	      return this._storage.size;
	    }
	  }, {
	    key: "_setModified",
	    value: function _setModified() {
	      if (!this._modified) {
	        this._modified = true;

	        if (typeof this.onSetModified === "function") {
	          this.onSetModified();
	        }
	      }
	    }
	  }, {
	    key: "resetModified",
	    value: function resetModified() {
	      if (this._modified) {
	        this._modified = false;

	        if (typeof this.onResetModified === "function") {
	          this.onResetModified();
	        }
	      }
	    }
	  }, {
	    key: "serializable",
	    get: function get() {
	      return this._storage.size > 0 ? this._storage : null;
	    }
	  }, {
	    key: "lastModified",
	    get: function get() {
	      return this._timeStamp.toString();
	    }
	  }]);

	  return AnnotationStorage;
	}();

	exports.AnnotationStorage = AnnotationStorage;

	/***/ }),
	/* 140 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.CanvasGraphics = void 0;

	var _util = __w_pdfjs_require__(4);

	var _pattern_helper = __w_pdfjs_require__(141);

	var _display_utils = __w_pdfjs_require__(1);

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	var MIN_FONT_SIZE = 16;
	var MAX_FONT_SIZE = 100;
	var MAX_GROUP_SIZE = 4096;
	var EXECUTION_TIME = 15;
	var EXECUTION_STEPS = 10;
	var MAX_SIZE_TO_COMPILE = 1000;
	var FULL_CHUNK_HEIGHT = 16;
	var LINEWIDTH_SCALE_FACTOR = 1.000001;

	function mirrorContextOperations(ctx, destCtx) {
	  if (ctx._removeMirroring) {
	    throw new Error("Context is already forwarding operations.");
	  }

	  ctx.__originalSave = ctx.save;
	  ctx.__originalRestore = ctx.restore;
	  ctx.__originalRotate = ctx.rotate;
	  ctx.__originalScale = ctx.scale;
	  ctx.__originalTranslate = ctx.translate;
	  ctx.__originalTransform = ctx.transform;
	  ctx.__originalSetTransform = ctx.setTransform;
	  ctx.__originalResetTransform = ctx.resetTransform;
	  ctx.__originalClip = ctx.clip;
	  ctx.__originalMoveTo = ctx.moveTo;
	  ctx.__originalLineTo = ctx.lineTo;
	  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
	  ctx.__originalRect = ctx.rect;
	  ctx.__originalClosePath = ctx.closePath;
	  ctx.__originalBeginPath = ctx.beginPath;

	  ctx._removeMirroring = function () {
	    ctx.save = ctx.__originalSave;
	    ctx.restore = ctx.__originalRestore;
	    ctx.rotate = ctx.__originalRotate;
	    ctx.scale = ctx.__originalScale;
	    ctx.translate = ctx.__originalTranslate;
	    ctx.transform = ctx.__originalTransform;
	    ctx.setTransform = ctx.__originalSetTransform;
	    ctx.resetTransform = ctx.__originalResetTransform;
	    ctx.clip = ctx.__originalClip;
	    ctx.moveTo = ctx.__originalMoveTo;
	    ctx.lineTo = ctx.__originalLineTo;
	    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
	    ctx.rect = ctx.__originalRect;
	    ctx.closePath = ctx.__originalClosePath;
	    ctx.beginPath = ctx.__originalBeginPath;
	    delete ctx._removeMirroring;
	  };

	  ctx.save = function ctxSave() {
	    destCtx.save();

	    this.__originalSave();
	  };

	  ctx.restore = function ctxRestore() {
	    destCtx.restore();

	    this.__originalRestore();
	  };

	  ctx.translate = function ctxTranslate(x, y) {
	    destCtx.translate(x, y);

	    this.__originalTranslate(x, y);
	  };

	  ctx.scale = function ctxScale(x, y) {
	    destCtx.scale(x, y);

	    this.__originalScale(x, y);
	  };

	  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
	    destCtx.transform(a, b, c, d, e, f);

	    this.__originalTransform(a, b, c, d, e, f);
	  };

	  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
	    destCtx.setTransform(a, b, c, d, e, f);

	    this.__originalSetTransform(a, b, c, d, e, f);
	  };

	  ctx.resetTransform = function ctxResetTransform() {
	    destCtx.resetTransform();

	    this.__originalResetTransform();
	  };

	  ctx.rotate = function ctxRotate(angle) {
	    destCtx.rotate(angle);

	    this.__originalRotate(angle);
	  };

	  ctx.clip = function ctxRotate(rule) {
	    destCtx.clip(rule);

	    this.__originalClip(rule);
	  };

	  ctx.moveTo = function (x, y) {
	    destCtx.moveTo(x, y);

	    this.__originalMoveTo(x, y);
	  };

	  ctx.lineTo = function (x, y) {
	    destCtx.lineTo(x, y);

	    this.__originalLineTo(x, y);
	  };

	  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
	    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);

	    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
	  };

	  ctx.rect = function (x, y, width, height) {
	    destCtx.rect(x, y, width, height);

	    this.__originalRect(x, y, width, height);
	  };

	  ctx.closePath = function () {
	    destCtx.closePath();

	    this.__originalClosePath();
	  };

	  ctx.beginPath = function () {
	    destCtx.beginPath();

	    this.__originalBeginPath();
	  };
	}

	function addContextCurrentTransform(ctx) {
	  if (ctx.mozCurrentTransform) {
	    return;
	  }

	  ctx._originalSave = ctx.save;
	  ctx._originalRestore = ctx.restore;
	  ctx._originalRotate = ctx.rotate;
	  ctx._originalScale = ctx.scale;
	  ctx._originalTranslate = ctx.translate;
	  ctx._originalTransform = ctx.transform;
	  ctx._originalSetTransform = ctx.setTransform;
	  ctx._originalResetTransform = ctx.resetTransform;
	  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
	  ctx._transformStack = [];

	  try {
	    var desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
	    ctx._setLineWidth = desc.set;
	    ctx._getLineWidth = desc.get;
	    Object.defineProperty(ctx, "lineWidth", {
	      set: function setLineWidth(width) {
	        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
	      },
	      get: function getLineWidth() {
	        return this._getLineWidth();
	      }
	    });
	  } catch (_) {}

	  Object.defineProperty(ctx, "mozCurrentTransform", {
	    get: function getCurrentTransform() {
	      return this._transformMatrix;
	    }
	  });
	  Object.defineProperty(ctx, "mozCurrentTransformInverse", {
	    get: function getCurrentTransformInverse() {
	      var _this$_transformMatri = _slicedToArray(this._transformMatrix, 6),
	          a = _this$_transformMatri[0],
	          b = _this$_transformMatri[1],
	          c = _this$_transformMatri[2],
	          d = _this$_transformMatri[3],
	          e = _this$_transformMatri[4],
	          f = _this$_transformMatri[5];

	      var ad_bc = a * d - b * c;
	      var bc_ad = b * c - a * d;
	      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
	    }
	  });

	  ctx.save = function ctxSave() {
	    var old = this._transformMatrix;

	    this._transformStack.push(old);

	    this._transformMatrix = old.slice(0, 6);

	    this._originalSave();
	  };

	  ctx.restore = function ctxRestore() {
	    var prev = this._transformStack.pop();

	    if (prev) {
	      this._transformMatrix = prev;

	      this._originalRestore();
	    }
	  };

	  ctx.translate = function ctxTranslate(x, y) {
	    var m = this._transformMatrix;
	    m[4] = m[0] * x + m[2] * y + m[4];
	    m[5] = m[1] * x + m[3] * y + m[5];

	    this._originalTranslate(x, y);
	  };

	  ctx.scale = function ctxScale(x, y) {
	    var m = this._transformMatrix;
	    m[0] *= x;
	    m[1] *= x;
	    m[2] *= y;
	    m[3] *= y;

	    this._originalScale(x, y);
	  };

	  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
	    var m = this._transformMatrix;
	    this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

	    ctx._originalTransform(a, b, c, d, e, f);
	  };

	  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
	    this._transformMatrix = [a, b, c, d, e, f];

	    ctx._originalSetTransform(a, b, c, d, e, f);
	  };

	  ctx.resetTransform = function ctxResetTransform() {
	    this._transformMatrix = [1, 0, 0, 1, 0, 0];

	    ctx._originalResetTransform();
	  };

	  ctx.rotate = function ctxRotate(angle) {
	    var cosValue = Math.cos(angle);
	    var sinValue = Math.sin(angle);
	    var m = this._transformMatrix;
	    this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

	    this._originalRotate(angle);
	  };
	}

	var CachedCanvases = /*#__PURE__*/function () {
	  function CachedCanvases(canvasFactory) {
	    _classCallCheck(this, CachedCanvases);

	    this.canvasFactory = canvasFactory;
	    this.cache = Object.create(null);
	  }

	  _createClass(CachedCanvases, [{
	    key: "getCanvas",
	    value: function getCanvas(id, width, height, trackTransform) {
	      var canvasEntry;

	      if (this.cache[id] !== undefined) {
	        canvasEntry = this.cache[id];
	        this.canvasFactory.reset(canvasEntry, width, height);
	        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
	      } else {
	        canvasEntry = this.canvasFactory.create(width, height);
	        this.cache[id] = canvasEntry;
	      }

	      if (trackTransform) {
	        addContextCurrentTransform(canvasEntry.context);
	      }

	      return canvasEntry;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      for (var id in this.cache) {
	        var canvasEntry = this.cache[id];
	        this.canvasFactory.destroy(canvasEntry);
	        delete this.cache[id];
	      }
	    }
	  }]);

	  return CachedCanvases;
	}();

	function compileType3Glyph(imgData) {
	  var POINT_TO_PROCESS_LIMIT = 1000;
	  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
	  var width = imgData.width,
	      height = imgData.height,
	      width1 = width + 1;
	  var i, ii, j, j0;
	  var points = new Uint8Array(width1 * (height + 1));
	  var lineSize = width + 7 & ~7,
	      data0 = imgData.data;
	  var data = new Uint8Array(lineSize * height);
	  var pos = 0;

	  for (i = 0, ii = data0.length; i < ii; i++) {
	    var elem = data0[i];
	    var mask = 128;

	    while (mask > 0) {
	      data[pos++] = elem & mask ? 0 : 255;
	      mask >>= 1;
	    }
	  }

	  var count = 0;
	  pos = 0;

	  if (data[pos] !== 0) {
	    points[0] = 1;
	    ++count;
	  }

	  for (j = 1; j < width; j++) {
	    if (data[pos] !== data[pos + 1]) {
	      points[j] = data[pos] ? 2 : 1;
	      ++count;
	    }

	    pos++;
	  }

	  if (data[pos] !== 0) {
	    points[j] = 2;
	    ++count;
	  }

	  for (i = 1; i < height; i++) {
	    pos = i * lineSize;
	    j0 = i * width1;

	    if (data[pos - lineSize] !== data[pos]) {
	      points[j0] = data[pos] ? 1 : 8;
	      ++count;
	    }

	    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

	    for (j = 1; j < width; j++) {
	      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

	      if (POINT_TYPES[sum]) {
	        points[j0 + j] = POINT_TYPES[sum];
	        ++count;
	      }

	      pos++;
	    }

	    if (data[pos - lineSize] !== data[pos]) {
	      points[j0 + j] = data[pos] ? 2 : 4;
	      ++count;
	    }

	    if (count > POINT_TO_PROCESS_LIMIT) {
	      return null;
	    }
	  }

	  pos = lineSize * (height - 1);
	  j0 = i * width1;

	  if (data[pos] !== 0) {
	    points[j0] = 8;
	    ++count;
	  }

	  for (j = 1; j < width; j++) {
	    if (data[pos] !== data[pos + 1]) {
	      points[j0 + j] = data[pos] ? 4 : 8;
	      ++count;
	    }

	    pos++;
	  }

	  if (data[pos] !== 0) {
	    points[j0 + j] = 4;
	    ++count;
	  }

	  if (count > POINT_TO_PROCESS_LIMIT) {
	    return null;
	  }

	  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
	  var outlines = [];

	  for (i = 0; count && i <= height; i++) {
	    var p = i * width1;
	    var end = p + width;

	    while (p < end && !points[p]) {
	      p++;
	    }

	    if (p === end) {
	      continue;
	    }

	    var coords = [p % width1, i];
	    var p0 = p;
	    var type = points[p];

	    do {
	      var step = steps[type];

	      do {
	        p += step;
	      } while (!points[p]);

	      var pp = points[p];

	      if (pp !== 5 && pp !== 10) {
	        type = pp;
	        points[p] = 0;
	      } else {
	        type = pp & 0x33 * type >> 4;
	        points[p] &= type >> 2 | type << 2;
	      }

	      coords.push(p % width1, p / width1 | 0);

	      if (!points[p]) {
	        --count;
	      }
	    } while (p0 !== p);

	    outlines.push(coords);
	    --i;
	  }

	  var drawOutline = function drawOutline(c) {
	    c.save();
	    c.scale(1 / width, -1 / height);
	    c.translate(0, -height);
	    c.beginPath();

	    for (var k = 0, kk = outlines.length; k < kk; k++) {
	      var o = outlines[k];
	      c.moveTo(o[0], o[1]);

	      for (var l = 2, ll = o.length; l < ll; l += 2) {
	        c.lineTo(o[l], o[l + 1]);
	      }
	    }

	    c.fill();
	    c.beginPath();
	    c.restore();
	  };

	  return drawOutline;
	}

	var CanvasExtraState = /*#__PURE__*/function () {
	  function CanvasExtraState(width, height) {
	    _classCallCheck(this, CanvasExtraState);

	    this.alphaIsShape = false;
	    this.fontSize = 0;
	    this.fontSizeScale = 1;
	    this.textMatrix = _util.IDENTITY_MATRIX;
	    this.textMatrixScale = 1;
	    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
	    this.leading = 0;
	    this.x = 0;
	    this.y = 0;
	    this.lineX = 0;
	    this.lineY = 0;
	    this.charSpacing = 0;
	    this.wordSpacing = 0;
	    this.textHScale = 1;
	    this.textRenderingMode = _util.TextRenderingMode.FILL;
	    this.textRise = 0;
	    this.fillColor = "#000000";
	    this.strokeColor = "#000000";
	    this.patternFill = false;
	    this.fillAlpha = 1;
	    this.strokeAlpha = 1;
	    this.lineWidth = 1;
	    this.activeSMask = null;
	    this.transferMaps = null;
	    this.startNewPathAndClipBox([0, 0, width, height]);
	  }

	  _createClass(CanvasExtraState, [{
	    key: "clone",
	    value: function clone() {
	      var clone = Object.create(this);
	      clone.clipBox = this.clipBox.slice();
	      return clone;
	    }
	  }, {
	    key: "setCurrentPoint",
	    value: function setCurrentPoint(x, y) {
	      this.x = x;
	      this.y = y;
	    }
	  }, {
	    key: "updatePathMinMax",
	    value: function updatePathMinMax(transform, x, y) {
	      var _Util$applyTransform = _util.Util.applyTransform([x, y], transform);

	      var _Util$applyTransform2 = _slicedToArray(_Util$applyTransform, 2);

	      x = _Util$applyTransform2[0];
	      y = _Util$applyTransform2[1];
	      this.minX = Math.min(this.minX, x);
	      this.minY = Math.min(this.minY, y);
	      this.maxX = Math.max(this.maxX, x);
	      this.maxY = Math.max(this.maxY, y);
	    }
	  }, {
	    key: "updateCurvePathMinMax",
	    value: function updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3) {
	      var box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);

	      this.updatePathMinMax(transform, box[0], box[1]);
	      this.updatePathMinMax(transform, box[2], box[3]);
	    }
	  }, {
	    key: "getPathBoundingBox",
	    value: function getPathBoundingBox() {
	      var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
	      var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var box = [this.minX, this.minY, this.maxX, this.maxY];

	      if (pathType === _pattern_helper.PathType.STROKE) {
	        if (!transform) {
	          (0, _util.unreachable)("Stroke bounding box must include transform.");
	        }

	        var scale = _util.Util.singularValueDecompose2dScale(transform);

	        var xStrokePad = scale[0] * this.lineWidth / 2;
	        var yStrokePad = scale[1] * this.lineWidth / 2;
	        box[0] -= xStrokePad;
	        box[1] -= yStrokePad;
	        box[2] += xStrokePad;
	        box[3] += yStrokePad;
	      }

	      return box;
	    }
	  }, {
	    key: "updateClipFromPath",
	    value: function updateClipFromPath() {
	      var intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());

	      this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
	    }
	  }, {
	    key: "startNewPathAndClipBox",
	    value: function startNewPathAndClipBox(box) {
	      this.clipBox = box;
	      this.minX = Infinity;
	      this.minY = Infinity;
	      this.maxX = 0;
	      this.maxY = 0;
	    }
	  }, {
	    key: "getClippedPathBoundingBox",
	    value: function getClippedPathBoundingBox() {
	      var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
	      var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
	    }
	  }]);

	  return CanvasExtraState;
	}();

	function putBinaryImageData(ctx, imgData) {
	  var transferMaps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
	    ctx.putImageData(imgData, 0, 0);
	    return;
	  }

	  var height = imgData.height,
	      width = imgData.width;
	  var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
	  var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
	  var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
	  var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
	  var srcPos = 0,
	      destPos;
	  var src = imgData.data;
	  var dest = chunkImgData.data;
	  var i, j, thisChunkHeight, elemsInThisChunk;
	  var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

	  if (transferMaps) {
	    switch (transferMaps.length) {
	      case 1:
	        transferMapRed = transferMaps[0];
	        transferMapGreen = transferMaps[0];
	        transferMapBlue = transferMaps[0];
	        transferMapGray = transferMaps[0];
	        break;

	      case 4:
	        transferMapRed = transferMaps[0];
	        transferMapGreen = transferMaps[1];
	        transferMapBlue = transferMaps[2];
	        transferMapGray = transferMaps[3];
	        break;
	    }
	  }

	  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
	    var srcLength = src.byteLength;
	    var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
	    var dest32DataLength = dest32.length;
	    var fullSrcDiff = width + 7 >> 3;
	    var white = 0xffffffff;
	    var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

	    if (transferMapGray) {
	      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
	        var _ref = [black, white];
	        white = _ref[0];
	        black = _ref[1];
	      }
	    }

	    for (i = 0; i < totalChunks; i++) {
	      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
	      destPos = 0;

	      for (j = 0; j < thisChunkHeight; j++) {
	        var srcDiff = srcLength - srcPos;
	        var k = 0;
	        var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
	        var kEndUnrolled = kEnd & ~7;
	        var mask = 0;
	        var srcByte = 0;

	        for (; k < kEndUnrolled; k += 8) {
	          srcByte = src[srcPos++];
	          dest32[destPos++] = srcByte & 128 ? white : black;
	          dest32[destPos++] = srcByte & 64 ? white : black;
	          dest32[destPos++] = srcByte & 32 ? white : black;
	          dest32[destPos++] = srcByte & 16 ? white : black;
	          dest32[destPos++] = srcByte & 8 ? white : black;
	          dest32[destPos++] = srcByte & 4 ? white : black;
	          dest32[destPos++] = srcByte & 2 ? white : black;
	          dest32[destPos++] = srcByte & 1 ? white : black;
	        }

	        for (; k < kEnd; k++) {
	          if (mask === 0) {
	            srcByte = src[srcPos++];
	            mask = 128;
	          }

	          dest32[destPos++] = srcByte & mask ? white : black;
	          mask >>= 1;
	        }
	      }

	      while (destPos < dest32DataLength) {
	        dest32[destPos++] = 0;
	      }

	      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
	    }
	  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
	    var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
	    j = 0;
	    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

	    for (i = 0; i < fullChunks; i++) {
	      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
	      srcPos += elemsInThisChunk;

	      if (hasTransferMaps) {
	        for (var _k = 0; _k < elemsInThisChunk; _k += 4) {
	          if (transferMapRed) {
	            dest[_k + 0] = transferMapRed[dest[_k + 0]];
	          }

	          if (transferMapGreen) {
	            dest[_k + 1] = transferMapGreen[dest[_k + 1]];
	          }

	          if (transferMapBlue) {
	            dest[_k + 2] = transferMapBlue[dest[_k + 2]];
	          }
	        }
	      }

	      ctx.putImageData(chunkImgData, 0, j);
	      j += FULL_CHUNK_HEIGHT;
	    }

	    if (i < totalChunks) {
	      elemsInThisChunk = width * partialChunkHeight * 4;
	      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

	      if (hasTransferMaps) {
	        for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {
	          if (transferMapRed) {
	            dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];
	          }

	          if (transferMapGreen) {
	            dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];
	          }

	          if (transferMapBlue) {
	            dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];
	          }
	        }
	      }

	      ctx.putImageData(chunkImgData, 0, j);
	    }
	  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
	    var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);

	    thisChunkHeight = FULL_CHUNK_HEIGHT;
	    elemsInThisChunk = width * thisChunkHeight;

	    for (i = 0; i < totalChunks; i++) {
	      if (i >= fullChunks) {
	        thisChunkHeight = partialChunkHeight;
	        elemsInThisChunk = width * thisChunkHeight;
	      }

	      destPos = 0;

	      for (j = elemsInThisChunk; j--;) {
	        dest[destPos++] = src[srcPos++];
	        dest[destPos++] = src[srcPos++];
	        dest[destPos++] = src[srcPos++];
	        dest[destPos++] = 255;
	      }

	      if (_hasTransferMaps) {
	        for (var _k3 = 0; _k3 < destPos; _k3 += 4) {
	          if (transferMapRed) {
	            dest[_k3 + 0] = transferMapRed[dest[_k3 + 0]];
	          }

	          if (transferMapGreen) {
	            dest[_k3 + 1] = transferMapGreen[dest[_k3 + 1]];
	          }

	          if (transferMapBlue) {
	            dest[_k3 + 2] = transferMapBlue[dest[_k3 + 2]];
	          }
	        }
	      }

	      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
	    }
	  } else {
	    throw new Error("bad image kind: ".concat(imgData.kind));
	  }
	}

	function putBinaryImageMask(ctx, imgData) {
	  var height = imgData.height,
	      width = imgData.width;
	  var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
	  var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
	  var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
	  var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
	  var srcPos = 0;
	  var src = imgData.data;
	  var dest = chunkImgData.data;

	  for (var i = 0; i < totalChunks; i++) {
	    var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
	    var destPos = 3;

	    for (var j = 0; j < thisChunkHeight; j++) {
	      var elem = void 0,
	          mask = 0;

	      for (var k = 0; k < width; k++) {
	        if (!mask) {
	          elem = src[srcPos++];
	          mask = 128;
	        }

	        dest[destPos] = elem & mask ? 0 : 255;
	        destPos += 4;
	        mask >>= 1;
	      }
	    }

	    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
	  }
	}

	function copyCtxState(sourceCtx, destCtx) {
	  var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

	  for (var i = 0, ii = properties.length; i < ii; i++) {
	    var property = properties[i];

	    if (sourceCtx[property] !== undefined) {
	      destCtx[property] = sourceCtx[property];
	    }
	  }

	  if (sourceCtx.setLineDash !== undefined) {
	    destCtx.setLineDash(sourceCtx.getLineDash());
	    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
	  }
	}

	function resetCtxToDefault(ctx) {
	  ctx.strokeStyle = "#000000";
	  ctx.fillStyle = "#000000";
	  ctx.fillRule = "nonzero";
	  ctx.globalAlpha = 1;
	  ctx.lineWidth = 1;
	  ctx.lineCap = "butt";
	  ctx.lineJoin = "miter";
	  ctx.miterLimit = 10;
	  ctx.globalCompositeOperation = "source-over";
	  ctx.font = "10px sans-serif";

	  if (ctx.setLineDash !== undefined) {
	    ctx.setLineDash([]);
	    ctx.lineDashOffset = 0;
	  }
	}

	function composeSMaskBackdrop(bytes, r0, g0, b0) {
	  var length = bytes.length;

	  for (var i = 3; i < length; i += 4) {
	    var alpha = bytes[i];

	    if (alpha === 0) {
	      bytes[i - 3] = r0;
	      bytes[i - 2] = g0;
	      bytes[i - 1] = b0;
	    } else if (alpha < 255) {
	      var alpha_ = 255 - alpha;
	      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
	      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
	      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
	    }
	  }
	}

	function composeSMaskAlpha(maskData, layerData, transferMap) {
	  var length = maskData.length;
	  var scale = 1 / 255;

	  for (var i = 3; i < length; i += 4) {
	    var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
	    layerData[i] = layerData[i] * alpha * scale | 0;
	  }
	}

	function composeSMaskLuminosity(maskData, layerData, transferMap) {
	  var length = maskData.length;

	  for (var i = 3; i < length; i += 4) {
	    var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
	    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
	  }
	}

	function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
	  var hasBackdrop = !!backdrop;
	  var r0 = hasBackdrop ? backdrop[0] : 0;
	  var g0 = hasBackdrop ? backdrop[1] : 0;
	  var b0 = hasBackdrop ? backdrop[2] : 0;
	  var composeFn;

	  if (subtype === "Luminosity") {
	    composeFn = composeSMaskLuminosity;
	  } else {
	    composeFn = composeSMaskAlpha;
	  }

	  var PIXELS_TO_PROCESS = 1048576;
	  var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

	  for (var row = 0; row < height; row += chunkSize) {
	    var chunkHeight = Math.min(chunkSize, height - row);
	    var maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
	    var layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);

	    if (hasBackdrop) {
	      composeSMaskBackdrop(maskData.data, r0, g0, b0);
	    }

	    composeFn(maskData.data, layerData.data, transferMap);
	    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
	  }
	}

	function composeSMask(ctx, smask, layerCtx, layerBox) {
	  var layerOffsetX = layerBox[0];
	  var layerOffsetY = layerBox[1];
	  var layerWidth = layerBox[2] - layerOffsetX;
	  var layerHeight = layerBox[3] - layerOffsetY;

	  if (layerWidth === 0 || layerHeight === 0) {
	    return;
	  }

	  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
	  ctx.save();
	  ctx.globalAlpha = 1;
	  ctx.globalCompositeOperation = "source-over";
	  ctx.setTransform(1, 0, 0, 1, 0, 0);
	  ctx.drawImage(layerCtx.canvas, 0, 0);
	  ctx.restore();
	}

	function getImageSmoothingEnabled(transform, interpolate) {
	  var scale = _util.Util.singularValueDecompose2dScale(transform);

	  scale[0] = Math.fround(scale[0]);
	  scale[1] = Math.fround(scale[1]);
	  var actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);

	  if (interpolate !== undefined) {
	    return interpolate;
	  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
	    return true;
	  }

	  return false;
	}

	var LINE_CAP_STYLES = ["butt", "round", "square"];
	var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
	var NORMAL_CLIP = {};
	var EO_CLIP = {};

	var CanvasGraphics = /*#__PURE__*/function () {
	  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap) {
	    _classCallCheck(this, CanvasGraphics);

	    this.ctx = canvasCtx;
	    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
	    this.stateStack = [];
	    this.pendingClip = null;
	    this.pendingEOFill = false;
	    this.res = null;
	    this.xobjs = null;
	    this.commonObjs = commonObjs;
	    this.objs = objs;
	    this.canvasFactory = canvasFactory;
	    this.imageLayer = imageLayer;
	    this.groupStack = [];
	    this.processingType3 = null;
	    this.baseTransform = null;
	    this.baseTransformStack = [];
	    this.groupLevel = 0;
	    this.smaskStack = [];
	    this.smaskCounter = 0;
	    this.tempSMask = null;
	    this.suspendedCtx = null;
	    this.contentVisible = true;
	    this.markedContentStack = [];
	    this.optionalContentConfig = optionalContentConfig;
	    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
	    this.cachedPatterns = new Map();
	    this.annotationCanvasMap = annotationCanvasMap;
	    this.viewportScale = 1;
	    this.outputScaleX = 1;
	    this.outputScaleY = 1;

	    if (canvasCtx) {
	      addContextCurrentTransform(canvasCtx);
	    }

	    this._cachedGetSinglePixelWidth = null;
	  }

	  _createClass(CanvasGraphics, [{
	    key: "beginDrawing",
	    value: function beginDrawing(_ref2) {
	      var transform = _ref2.transform,
	          viewport = _ref2.viewport,
	          _ref2$transparency = _ref2.transparency,
	          transparency = _ref2$transparency === void 0 ? false : _ref2$transparency,
	          _ref2$background = _ref2.background,
	          background = _ref2$background === void 0 ? null : _ref2$background;
	      var width = this.ctx.canvas.width;
	      var height = this.ctx.canvas.height;
	      this.ctx.save();
	      this.ctx.fillStyle = background || "rgb(255, 255, 255)";
	      this.ctx.fillRect(0, 0, width, height);
	      this.ctx.restore();

	      if (transparency) {
	        var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
	        this.compositeCtx = this.ctx;
	        this.transparentCanvas = transparentCanvas.canvas;
	        this.ctx = transparentCanvas.context;
	        this.ctx.save();
	        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
	      }

	      this.ctx.save();
	      resetCtxToDefault(this.ctx);

	      if (transform) {
	        this.ctx.transform.apply(this.ctx, transform);
	        this.outputScaleX = transform[0];
	        this.outputScaleY = transform[0];
	      }

	      this.ctx.transform.apply(this.ctx, viewport.transform);
	      this.viewportScale = viewport.scale;
	      this.baseTransform = this.ctx.mozCurrentTransform.slice();
	      this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);

	      if (this.imageLayer) {
	        this.imageLayer.beginLayout();
	      }
	    }
	  }, {
	    key: "executeOperatorList",
	    value: function executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
	      var argsArray = operatorList.argsArray;
	      var fnArray = operatorList.fnArray;
	      var i = executionStartIdx || 0;
	      var argsArrayLen = argsArray.length;

	      if (argsArrayLen === i) {
	        return i;
	      }

	      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
	      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
	      var steps = 0;
	      var commonObjs = this.commonObjs;
	      var objs = this.objs;
	      var fnId;

	      while (true) {
	        if (stepper !== undefined && i === stepper.nextBreakPoint) {
	          stepper.breakIt(i, continueCallback);
	          return i;
	        }

	        fnId = fnArray[i];

	        if (fnId !== _util.OPS.dependency) {
	          this[fnId].apply(this, argsArray[i]);
	        } else {
	          var _iterator = _createForOfIteratorHelper(argsArray[i]),
	              _step;

	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var depObjId = _step.value;
	              var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

	              if (!objsPool.has(depObjId)) {
	                objsPool.get(depObjId, continueCallback);
	                return i;
	              }
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        }

	        i++;

	        if (i === argsArrayLen) {
	          return i;
	        }

	        if (chunkOperations && ++steps > EXECUTION_STEPS) {
	          if (Date.now() > endTime) {
	            continueCallback();
	            return i;
	          }

	          steps = 0;
	        }
	      }
	    }
	  }, {
	    key: "endDrawing",
	    value: function endDrawing() {
	      while (this.stateStack.length || this.current.activeSMask !== null) {
	        this.restore();
	      }

	      this.ctx.restore();

	      if (this.transparentCanvas) {
	        this.ctx = this.compositeCtx;
	        this.ctx.save();
	        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
	        this.ctx.drawImage(this.transparentCanvas, 0, 0);
	        this.ctx.restore();
	        this.transparentCanvas = null;
	      }

	      this.cachedCanvases.clear();
	      this.cachedPatterns.clear();

	      if (this.imageLayer) {
	        this.imageLayer.endLayout();
	      }
	    }
	  }, {
	    key: "_scaleImage",
	    value: function _scaleImage(img, inverseTransform) {
	      var width = img.width;
	      var height = img.height;
	      var widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
	      var heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
	      var paintWidth = width,
	          paintHeight = height;
	      var tmpCanvasId = "prescale1";
	      var tmpCanvas, tmpCtx;

	      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
	        var newWidth = paintWidth,
	            newHeight = paintHeight;

	        if (widthScale > 2 && paintWidth > 1) {
	          newWidth = Math.ceil(paintWidth / 2);
	          widthScale /= paintWidth / newWidth;
	        }

	        if (heightScale > 2 && paintHeight > 1) {
	          newHeight = Math.ceil(paintHeight / 2);
	          heightScale /= paintHeight / newHeight;
	        }

	        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
	        tmpCtx = tmpCanvas.context;
	        tmpCtx.clearRect(0, 0, newWidth, newHeight);
	        tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
	        img = tmpCanvas.canvas;
	        paintWidth = newWidth;
	        paintHeight = newHeight;
	        tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
	      }

	      return {
	        img: img,
	        paintWidth: paintWidth,
	        paintHeight: paintHeight
	      };
	    }
	  }, {
	    key: "_createMaskCanvas",
	    value: function _createMaskCanvas(img) {
	      var ctx = this.ctx;
	      var width = img.width,
	          height = img.height;
	      var fillColor = this.current.fillColor;
	      var isPatternFill = this.current.patternFill;
	      var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
	      var maskCtx = maskCanvas.context;
	      putBinaryImageMask(maskCtx, img);
	      var objToCanvas = ctx.mozCurrentTransform;

	      var maskToCanvas = _util.Util.transform(objToCanvas, [1 / width, 0, 0, -1 / height, 0, 0]);

	      maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);

	      var cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);

	      var cord2 = _util.Util.applyTransform([width, height], maskToCanvas);

	      var rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);

	      var drawnWidth = Math.ceil(rect[2] - rect[0]);
	      var drawnHeight = Math.ceil(rect[3] - rect[1]);
	      var fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
	      var fillCtx = fillCanvas.context;
	      var offsetX = Math.min(cord1[0], cord2[0]);
	      var offsetY = Math.min(cord1[1], cord2[1]);
	      fillCtx.translate(-offsetX, -offsetY);
	      fillCtx.transform.apply(fillCtx, maskToCanvas);

	      var scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);

	      fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
	      fillCtx.drawImage(scaled.img, 0, 0, scaled.img.width, scaled.img.height, 0, 0, width, height);
	      fillCtx.globalCompositeOperation = "source-in";

	      var inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);

	      fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
	      fillCtx.fillRect(0, 0, width, height);
	      return {
	        canvas: fillCanvas.canvas,
	        offsetX: Math.round(offsetX),
	        offsetY: Math.round(offsetY)
	      };
	    }
	  }, {
	    key: "setLineWidth",
	    value: function setLineWidth(width) {
	      this.current.lineWidth = width;
	      this.ctx.lineWidth = width;
	    }
	  }, {
	    key: "setLineCap",
	    value: function setLineCap(style) {
	      this.ctx.lineCap = LINE_CAP_STYLES[style];
	    }
	  }, {
	    key: "setLineJoin",
	    value: function setLineJoin(style) {
	      this.ctx.lineJoin = LINE_JOIN_STYLES[style];
	    }
	  }, {
	    key: "setMiterLimit",
	    value: function setMiterLimit(limit) {
	      this.ctx.miterLimit = limit;
	    }
	  }, {
	    key: "setDash",
	    value: function setDash(dashArray, dashPhase) {
	      var ctx = this.ctx;

	      if (ctx.setLineDash !== undefined) {
	        ctx.setLineDash(dashArray);
	        ctx.lineDashOffset = dashPhase;
	      }
	    }
	  }, {
	    key: "setRenderingIntent",
	    value: function setRenderingIntent(intent) {}
	  }, {
	    key: "setFlatness",
	    value: function setFlatness(flatness) {}
	  }, {
	    key: "setGState",
	    value: function setGState(states) {
	      for (var i = 0, ii = states.length; i < ii; i++) {
	        var state = states[i];
	        var key = state[0];
	        var value = state[1];

	        switch (key) {
	          case "LW":
	            this.setLineWidth(value);
	            break;

	          case "LC":
	            this.setLineCap(value);
	            break;

	          case "LJ":
	            this.setLineJoin(value);
	            break;

	          case "ML":
	            this.setMiterLimit(value);
	            break;

	          case "D":
	            this.setDash(value[0], value[1]);
	            break;

	          case "RI":
	            this.setRenderingIntent(value);
	            break;

	          case "FL":
	            this.setFlatness(value);
	            break;

	          case "Font":
	            this.setFont(value[0], value[1]);
	            break;

	          case "CA":
	            this.current.strokeAlpha = state[1];
	            break;

	          case "ca":
	            this.current.fillAlpha = state[1];
	            this.ctx.globalAlpha = state[1];
	            break;

	          case "BM":
	            this.ctx.globalCompositeOperation = value;
	            break;

	          case "SMask":
	            this.current.activeSMask = value ? this.tempSMask : null;
	            this.tempSMask = null;
	            this.checkSMaskState();
	            break;

	          case "TR":
	            this.current.transferMaps = value;
	        }
	      }
	    }
	  }, {
	    key: "checkSMaskState",
	    value: function checkSMaskState() {
	      var inSMaskMode = !!this.suspendedCtx;

	      if (this.current.activeSMask && !inSMaskMode) {
	        this.beginSMaskMode();
	      } else if (!this.current.activeSMask && inSMaskMode) {
	        this.endSMaskMode();
	      }
	    }
	  }, {
	    key: "beginSMaskMode",
	    value: function beginSMaskMode() {
	      if (this.suspendedCtx) {
	        throw new Error("beginSMaskMode called while already in smask mode");
	      }

	      var drawnWidth = this.ctx.canvas.width;
	      var drawnHeight = this.ctx.canvas.height;
	      var cacheId = "smaskGroupAt" + this.groupLevel;
	      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
	      this.suspendedCtx = this.ctx;
	      this.ctx = scratchCanvas.context;
	      var ctx = this.ctx;
	      ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);
	      copyCtxState(this.suspendedCtx, ctx);
	      mirrorContextOperations(ctx, this.suspendedCtx);
	      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
	    }
	  }, {
	    key: "endSMaskMode",
	    value: function endSMaskMode() {
	      if (!this.suspendedCtx) {
	        throw new Error("endSMaskMode called while not in smask mode");
	      }

	      this.ctx._removeMirroring();

	      copyCtxState(this.ctx, this.suspendedCtx);
	      this.ctx = this.suspendedCtx;
	      this.current.activeSMask = null;
	      this.suspendedCtx = null;
	    }
	  }, {
	    key: "compose",
	    value: function compose(dirtyBox) {
	      if (!this.current.activeSMask) {
	        return;
	      }

	      if (!dirtyBox) {
	        dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
	      } else {
	        dirtyBox[0] = Math.floor(dirtyBox[0]);
	        dirtyBox[1] = Math.floor(dirtyBox[1]);
	        dirtyBox[2] = Math.ceil(dirtyBox[2]);
	        dirtyBox[3] = Math.ceil(dirtyBox[3]);
	      }

	      var smask = this.current.activeSMask;
	      var suspendedCtx = this.suspendedCtx;
	      composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
	      this.ctx.save();
	      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
	      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
	      this.ctx.restore();
	    }
	  }, {
	    key: "save",
	    value: function save() {
	      this.ctx.save();
	      var old = this.current;
	      this.stateStack.push(old);
	      this.current = old.clone();
	    }
	  }, {
	    key: "restore",
	    value: function restore() {
	      if (this.stateStack.length === 0 && this.current.activeSMask) {
	        this.endSMaskMode();
	      }

	      if (this.stateStack.length !== 0) {
	        this.current = this.stateStack.pop();
	        this.ctx.restore();
	        this.checkSMaskState();
	        this.pendingClip = null;
	        this._cachedGetSinglePixelWidth = null;
	      }
	    }
	  }, {
	    key: "transform",
	    value: function transform(a, b, c, d, e, f) {
	      this.ctx.transform(a, b, c, d, e, f);
	      this._cachedGetSinglePixelWidth = null;
	    }
	  }, {
	    key: "constructPath",
	    value: function constructPath(ops, args) {
	      var ctx = this.ctx;
	      var current = this.current;
	      var x = current.x,
	          y = current.y;
	      var startX, startY;

	      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
	        switch (ops[i] | 0) {
	          case _util.OPS.rectangle:
	            x = args[j++];
	            y = args[j++];
	            var width = args[j++];
	            var height = args[j++];
	            var xw = x + width;
	            var yh = y + height;
	            ctx.moveTo(x, y);

	            if (width === 0 || height === 0) {
	              ctx.lineTo(xw, yh);
	            } else {
	              ctx.lineTo(xw, y);
	              ctx.lineTo(xw, yh);
	              ctx.lineTo(x, yh);
	            }

	            current.updatePathMinMax(ctx.mozCurrentTransform, x, y);
	            current.updatePathMinMax(ctx.mozCurrentTransform, xw, yh);
	            ctx.closePath();
	            break;

	          case _util.OPS.moveTo:
	            x = args[j++];
	            y = args[j++];
	            ctx.moveTo(x, y);
	            current.updatePathMinMax(ctx.mozCurrentTransform, x, y);
	            break;

	          case _util.OPS.lineTo:
	            x = args[j++];
	            y = args[j++];
	            ctx.lineTo(x, y);
	            current.updatePathMinMax(ctx.mozCurrentTransform, x, y);
	            break;

	          case _util.OPS.curveTo:
	            startX = x;
	            startY = y;
	            x = args[j + 4];
	            y = args[j + 5];
	            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
	            current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
	            j += 6;
	            break;

	          case _util.OPS.curveTo2:
	            startX = x;
	            startY = y;
	            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
	            current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
	            x = args[j + 2];
	            y = args[j + 3];
	            j += 4;
	            break;

	          case _util.OPS.curveTo3:
	            startX = x;
	            startY = y;
	            x = args[j + 2];
	            y = args[j + 3];
	            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
	            current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], x, y, x, y);
	            j += 4;
	            break;

	          case _util.OPS.closePath:
	            ctx.closePath();
	            break;
	        }
	      }

	      current.setCurrentPoint(x, y);
	    }
	  }, {
	    key: "closePath",
	    value: function closePath() {
	      this.ctx.closePath();
	    }
	  }, {
	    key: "stroke",
	    value: function stroke(consumePath) {
	      consumePath = typeof consumePath !== "undefined" ? consumePath : true;
	      var ctx = this.ctx;
	      var strokeColor = this.current.strokeColor;
	      ctx.globalAlpha = this.current.strokeAlpha;

	      if (this.contentVisible) {
	        if (_typeof(strokeColor) === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
	          var lineWidth = this.getSinglePixelWidth();
	          ctx.save();
	          ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);
	          ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
	          ctx.stroke();
	          ctx.restore();
	        } else {
	          var _lineWidth = this.getSinglePixelWidth();

	          if (_lineWidth < 0 && -_lineWidth >= this.current.lineWidth) {
	            ctx.save();
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	            ctx.stroke();
	            ctx.restore();
	          } else {
	            ctx.lineWidth = Math.max(_lineWidth, this.current.lineWidth);
	            ctx.stroke();
	          }
	        }
	      }

	      if (consumePath) {
	        this.consumePath(this.current.getClippedPathBoundingBox());
	      }

	      ctx.globalAlpha = this.current.fillAlpha;
	    }
	  }, {
	    key: "closeStroke",
	    value: function closeStroke() {
	      this.closePath();
	      this.stroke();
	    }
	  }, {
	    key: "fill",
	    value: function fill(consumePath) {
	      consumePath = typeof consumePath !== "undefined" ? consumePath : true;
	      var ctx = this.ctx;
	      var fillColor = this.current.fillColor;
	      var isPatternFill = this.current.patternFill;
	      var needRestore = false;

	      if (isPatternFill) {
	        ctx.save();
	        ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
	        needRestore = true;
	      }

	      var intersect = this.current.getClippedPathBoundingBox();

	      if (this.contentVisible && intersect !== null) {
	        if (this.pendingEOFill) {
	          ctx.fill("evenodd");
	          this.pendingEOFill = false;
	        } else {
	          ctx.fill();
	        }
	      }

	      if (needRestore) {
	        ctx.restore();
	      }

	      if (consumePath) {
	        this.consumePath(intersect);
	      }
	    }
	  }, {
	    key: "eoFill",
	    value: function eoFill() {
	      this.pendingEOFill = true;
	      this.fill();
	    }
	  }, {
	    key: "fillStroke",
	    value: function fillStroke() {
	      this.fill(false);
	      this.stroke(false);
	      this.consumePath();
	    }
	  }, {
	    key: "eoFillStroke",
	    value: function eoFillStroke() {
	      this.pendingEOFill = true;
	      this.fillStroke();
	    }
	  }, {
	    key: "closeFillStroke",
	    value: function closeFillStroke() {
	      this.closePath();
	      this.fillStroke();
	    }
	  }, {
	    key: "closeEOFillStroke",
	    value: function closeEOFillStroke() {
	      this.pendingEOFill = true;
	      this.closePath();
	      this.fillStroke();
	    }
	  }, {
	    key: "endPath",
	    value: function endPath() {
	      this.consumePath();
	    }
	  }, {
	    key: "clip",
	    value: function clip() {
	      this.pendingClip = NORMAL_CLIP;
	    }
	  }, {
	    key: "eoClip",
	    value: function eoClip() {
	      this.pendingClip = EO_CLIP;
	    }
	  }, {
	    key: "beginText",
	    value: function beginText() {
	      this.current.textMatrix = _util.IDENTITY_MATRIX;
	      this.current.textMatrixScale = 1;
	      this.current.x = this.current.lineX = 0;
	      this.current.y = this.current.lineY = 0;
	    }
	  }, {
	    key: "endText",
	    value: function endText() {
	      var paths = this.pendingTextPaths;
	      var ctx = this.ctx;

	      if (paths === undefined) {
	        ctx.beginPath();
	        return;
	      }

	      ctx.save();
	      ctx.beginPath();

	      for (var i = 0; i < paths.length; i++) {
	        var path = paths[i];
	        ctx.setTransform.apply(ctx, path.transform);
	        ctx.translate(path.x, path.y);
	        path.addToPath(ctx, path.fontSize);
	      }

	      ctx.restore();
	      ctx.clip();
	      ctx.beginPath();
	      delete this.pendingTextPaths;
	    }
	  }, {
	    key: "setCharSpacing",
	    value: function setCharSpacing(spacing) {
	      this.current.charSpacing = spacing;
	    }
	  }, {
	    key: "setWordSpacing",
	    value: function setWordSpacing(spacing) {
	      this.current.wordSpacing = spacing;
	    }
	  }, {
	    key: "setHScale",
	    value: function setHScale(scale) {
	      this.current.textHScale = scale / 100;
	    }
	  }, {
	    key: "setLeading",
	    value: function setLeading(leading) {
	      this.current.leading = -leading;
	    }
	  }, {
	    key: "setFont",
	    value: function setFont(fontRefName, size) {
	      var fontObj = this.commonObjs.get(fontRefName);
	      var current = this.current;

	      if (!fontObj) {
	        throw new Error("Can't find font for ".concat(fontRefName));
	      }

	      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

	      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
	        (0, _util.warn)("Invalid font matrix for font " + fontRefName);
	      }

	      if (size < 0) {
	        size = -size;
	        current.fontDirection = -1;
	      } else {
	        current.fontDirection = 1;
	      }

	      this.current.font = fontObj;
	      this.current.fontSize = size;

	      if (fontObj.isType3Font) {
	        return;
	      }

	      var name = fontObj.loadedName || "sans-serif";
	      var bold = "normal";

	      if (fontObj.black) {
	        bold = "900";
	      } else if (fontObj.bold) {
	        bold = "bold";
	      }

	      var italic = fontObj.italic ? "italic" : "normal";
	      var typeface = "\"".concat(name, "\", ").concat(fontObj.fallbackName);
	      var browserFontSize = size;

	      if (size < MIN_FONT_SIZE) {
	        browserFontSize = MIN_FONT_SIZE;
	      } else if (size > MAX_FONT_SIZE) {
	        browserFontSize = MAX_FONT_SIZE;
	      }

	      this.current.fontSizeScale = size / browserFontSize;
	      this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
	    }
	  }, {
	    key: "setTextRenderingMode",
	    value: function setTextRenderingMode(mode) {
	      this.current.textRenderingMode = mode;
	    }
	  }, {
	    key: "setTextRise",
	    value: function setTextRise(rise) {
	      this.current.textRise = rise;
	    }
	  }, {
	    key: "moveText",
	    value: function moveText(x, y) {
	      this.current.x = this.current.lineX += x;
	      this.current.y = this.current.lineY += y;
	    }
	  }, {
	    key: "setLeadingMoveText",
	    value: function setLeadingMoveText(x, y) {
	      this.setLeading(-y);
	      this.moveText(x, y);
	    }
	  }, {
	    key: "setTextMatrix",
	    value: function setTextMatrix(a, b, c, d, e, f) {
	      this.current.textMatrix = [a, b, c, d, e, f];
	      this.current.textMatrixScale = Math.hypot(a, b);
	      this.current.x = this.current.lineX = 0;
	      this.current.y = this.current.lineY = 0;
	    }
	  }, {
	    key: "nextLine",
	    value: function nextLine() {
	      this.moveText(0, this.current.leading);
	    }
	  }, {
	    key: "paintChar",
	    value: function paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
	      var ctx = this.ctx;
	      var current = this.current;
	      var font = current.font;
	      var textRenderingMode = current.textRenderingMode;
	      var fontSize = current.fontSize / current.fontSizeScale;
	      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
	      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
	      var patternFill = current.patternFill && !font.missingFile;
	      var addToPath;

	      if (font.disableFontFace || isAddToPathSet || patternFill) {
	        addToPath = font.getPathGenerator(this.commonObjs, character);
	      }

	      if (font.disableFontFace || patternFill) {
	        ctx.save();
	        ctx.translate(x, y);
	        ctx.beginPath();
	        addToPath(ctx, fontSize);

	        if (patternTransform) {
	          ctx.setTransform.apply(ctx, patternTransform);
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          ctx.fill();
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          if (resetLineWidthToOne) {
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	          }

	          ctx.stroke();
	        }

	        ctx.restore();
	      } else {
	        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          ctx.fillText(character, x, y);
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          if (resetLineWidthToOne) {
	            ctx.save();
	            ctx.moveTo(x, y);
	            ctx.resetTransform();
	            ctx.lineWidth = Math.round(this._combinedScaleFactor);
	            ctx.strokeText(character, 0, 0);
	            ctx.restore();
	          } else {
	            ctx.strokeText(character, x, y);
	          }
	        }
	      }

	      if (isAddToPathSet) {
	        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
	        paths.push({
	          transform: ctx.mozCurrentTransform,
	          x: x,
	          y: y,
	          fontSize: fontSize,
	          addToPath: addToPath
	        });
	      }
	    }
	  }, {
	    key: "isFontSubpixelAAEnabled",
	    get: function get() {
	      var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10),
	          ctx = _this$cachedCanvases$.context;

	      ctx.scale(1.5, 1);
	      ctx.fillText("I", 0, 10);
	      var data = ctx.getImageData(0, 0, 10, 10).data;
	      var enabled = false;

	      for (var i = 3; i < data.length; i += 4) {
	        if (data[i] > 0 && data[i] < 255) {
	          enabled = true;
	          break;
	        }
	      }

	      return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
	    }
	  }, {
	    key: "showText",
	    value: function showText(glyphs) {
	      var current = this.current;
	      var font = current.font;

	      if (font.isType3Font) {
	        return this.showType3Text(glyphs);
	      }

	      var fontSize = current.fontSize;

	      if (fontSize === 0) {
	        return undefined;
	      }

	      var ctx = this.ctx;
	      var fontSizeScale = current.fontSizeScale;
	      var charSpacing = current.charSpacing;
	      var wordSpacing = current.wordSpacing;
	      var fontDirection = current.fontDirection;
	      var textHScale = current.textHScale * fontDirection;
	      var glyphsLength = glyphs.length;
	      var vertical = font.vertical;
	      var spacingDir = vertical ? 1 : -1;
	      var defaultVMetrics = font.defaultVMetrics;
	      var widthAdvanceScale = fontSize * current.fontMatrix[0];
	      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
	      ctx.save();
	      ctx.transform.apply(ctx, current.textMatrix);
	      ctx.translate(current.x, current.y + current.textRise);

	      if (fontDirection > 0) {
	        ctx.scale(textHScale, -1);
	      } else {
	        ctx.scale(textHScale, 1);
	      }

	      var patternTransform;

	      if (current.patternFill) {
	        ctx.save();
	        var pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
	        patternTransform = ctx.mozCurrentTransform;
	        ctx.restore();
	        ctx.fillStyle = pattern;
	      }

	      var lineWidth = current.lineWidth;
	      var resetLineWidthToOne = false;
	      var scale = current.textMatrixScale;

	      if (scale === 0 || lineWidth === 0) {
	        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          this._cachedGetSinglePixelWidth = null;
	          lineWidth = this.getSinglePixelWidth();
	          resetLineWidthToOne = lineWidth < 0;
	        }
	      } else {
	        lineWidth /= scale;
	      }

	      if (fontSizeScale !== 1.0) {
	        ctx.scale(fontSizeScale, fontSizeScale);
	        lineWidth /= fontSizeScale;
	      }

	      ctx.lineWidth = lineWidth;
	      var x = 0,
	          i;

	      for (i = 0; i < glyphsLength; ++i) {
	        var glyph = glyphs[i];

	        if ((0, _util.isNum)(glyph)) {
	          x += spacingDir * glyph * fontSize / 1000;
	          continue;
	        }

	        var restoreNeeded = false;
	        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
	        var character = glyph.fontChar;
	        var accent = glyph.accent;
	        var scaledX = void 0,
	            scaledY = void 0;
	        var width = glyph.width;

	        if (vertical) {
	          var vmetric = glyph.vmetric || defaultVMetrics;
	          var vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
	          var vy = vmetric[2] * widthAdvanceScale;
	          width = vmetric ? -vmetric[0] : width;
	          scaledX = vx / fontSizeScale;
	          scaledY = (x + vy) / fontSizeScale;
	        } else {
	          scaledX = x / fontSizeScale;
	          scaledY = 0;
	        }

	        if (font.remeasure && width > 0) {
	          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

	          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
	            var characterScaleX = width / measuredWidth;
	            restoreNeeded = true;
	            ctx.save();
	            ctx.scale(characterScaleX, 1);
	            scaledX /= characterScaleX;
	          } else if (width !== measuredWidth) {
	            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
	          }
	        }

	        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
	          if (simpleFillText && !accent) {
	            ctx.fillText(character, scaledX, scaledY);
	          } else {
	            this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);

	            if (accent) {
	              var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
	              var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
	              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
	            }
	          }
	        }

	        var charWidth = void 0;

	        if (vertical) {
	          charWidth = width * widthAdvanceScale - spacing * fontDirection;
	        } else {
	          charWidth = width * widthAdvanceScale + spacing * fontDirection;
	        }

	        x += charWidth;

	        if (restoreNeeded) {
	          ctx.restore();
	        }
	      }

	      if (vertical) {
	        current.y -= x;
	      } else {
	        current.x += x * textHScale;
	      }

	      ctx.restore();
	      this.compose();
	      return undefined;
	    }
	  }, {
	    key: "showType3Text",
	    value: function showType3Text(glyphs) {
	      var ctx = this.ctx;
	      var current = this.current;
	      var font = current.font;
	      var fontSize = current.fontSize;
	      var fontDirection = current.fontDirection;
	      var spacingDir = font.vertical ? 1 : -1;
	      var charSpacing = current.charSpacing;
	      var wordSpacing = current.wordSpacing;
	      var textHScale = current.textHScale * fontDirection;
	      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
	      var glyphsLength = glyphs.length;
	      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
	      var i, glyph, width, spacingLength;

	      if (isTextInvisible || fontSize === 0) {
	        return;
	      }

	      this._cachedGetSinglePixelWidth = null;
	      ctx.save();
	      ctx.transform.apply(ctx, current.textMatrix);
	      ctx.translate(current.x, current.y);
	      ctx.scale(textHScale, fontDirection);

	      for (i = 0; i < glyphsLength; ++i) {
	        glyph = glyphs[i];

	        if ((0, _util.isNum)(glyph)) {
	          spacingLength = spacingDir * glyph * fontSize / 1000;
	          this.ctx.translate(spacingLength, 0);
	          current.x += spacingLength * textHScale;
	          continue;
	        }

	        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
	        var operatorList = font.charProcOperatorList[glyph.operatorListId];

	        if (!operatorList) {
	          (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available."));
	          continue;
	        }

	        if (this.contentVisible) {
	          this.processingType3 = glyph;
	          this.save();
	          ctx.scale(fontSize, fontSize);
	          ctx.transform.apply(ctx, fontMatrix);
	          this.executeOperatorList(operatorList);
	          this.restore();
	        }

	        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

	        width = transformed[0] * fontSize + spacing;
	        ctx.translate(width, 0);
	        current.x += width * textHScale;
	      }

	      ctx.restore();
	      this.processingType3 = null;
	    }
	  }, {
	    key: "setCharWidth",
	    value: function setCharWidth(xWidth, yWidth) {}
	  }, {
	    key: "setCharWidthAndBounds",
	    value: function setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
	      this.ctx.rect(llx, lly, urx - llx, ury - lly);
	      this.clip();
	      this.endPath();
	    }
	  }, {
	    key: "getColorN_Pattern",
	    value: function getColorN_Pattern(IR) {
	      var _this = this;

	      var pattern;

	      if (IR[0] === "TilingPattern") {
	        var color = IR[1];
	        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
	        var canvasGraphicsFactory = {
	          createCanvasGraphics: function createCanvasGraphics(ctx) {
	            return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory);
	          }
	        };
	        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
	      } else {
	        pattern = this._getPattern(IR[1], IR[2]);
	      }

	      return pattern;
	    }
	  }, {
	    key: "setStrokeColorN",
	    value: function setStrokeColorN() {
	      this.current.strokeColor = this.getColorN_Pattern(arguments);
	    }
	  }, {
	    key: "setFillColorN",
	    value: function setFillColorN() {
	      this.current.fillColor = this.getColorN_Pattern(arguments);
	      this.current.patternFill = true;
	    }
	  }, {
	    key: "setStrokeRGBColor",
	    value: function setStrokeRGBColor(r, g, b) {
	      var color = _util.Util.makeHexColor(r, g, b);

	      this.ctx.strokeStyle = color;
	      this.current.strokeColor = color;
	    }
	  }, {
	    key: "setFillRGBColor",
	    value: function setFillRGBColor(r, g, b) {
	      var color = _util.Util.makeHexColor(r, g, b);

	      this.ctx.fillStyle = color;
	      this.current.fillColor = color;
	      this.current.patternFill = false;
	    }
	  }, {
	    key: "_getPattern",
	    value: function _getPattern(objId) {
	      var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var pattern;

	      if (this.cachedPatterns.has(objId)) {
	        pattern = this.cachedPatterns.get(objId);
	      } else {
	        pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
	        this.cachedPatterns.set(objId, pattern);
	      }

	      if (matrix) {
	        pattern.matrix = matrix;
	      }

	      return pattern;
	    }
	  }, {
	    key: "shadingFill",
	    value: function shadingFill(objId) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var ctx = this.ctx;
	      this.save();

	      var pattern = this._getPattern(objId);

	      ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);
	      var inv = ctx.mozCurrentTransformInverse;

	      if (inv) {
	        var canvas = ctx.canvas;
	        var width = canvas.width;
	        var height = canvas.height;

	        var bl = _util.Util.applyTransform([0, 0], inv);

	        var br = _util.Util.applyTransform([0, height], inv);

	        var ul = _util.Util.applyTransform([width, 0], inv);

	        var ur = _util.Util.applyTransform([width, height], inv);

	        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
	        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
	        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
	        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
	        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
	      } else {
	        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
	      }

	      this.compose(this.current.getClippedPathBoundingBox());
	      this.restore();
	    }
	  }, {
	    key: "beginInlineImage",
	    value: function beginInlineImage() {
	      (0, _util.unreachable)("Should not call beginInlineImage");
	    }
	  }, {
	    key: "beginImageData",
	    value: function beginImageData() {
	      (0, _util.unreachable)("Should not call beginImageData");
	    }
	  }, {
	    key: "paintFormXObjectBegin",
	    value: function paintFormXObjectBegin(matrix, bbox) {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.save();
	      this.baseTransformStack.push(this.baseTransform);

	      if (Array.isArray(matrix) && matrix.length === 6) {
	        this.transform.apply(this, matrix);
	      }

	      this.baseTransform = this.ctx.mozCurrentTransform;

	      if (bbox) {
	        var width = bbox[2] - bbox[0];
	        var height = bbox[3] - bbox[1];
	        this.ctx.rect(bbox[0], bbox[1], width, height);
	        this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[0], bbox[1]);
	        this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[2], bbox[3]);
	        this.clip();
	        this.endPath();
	      }
	    }
	  }, {
	    key: "paintFormXObjectEnd",
	    value: function paintFormXObjectEnd() {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.restore();
	      this.baseTransform = this.baseTransformStack.pop();
	    }
	  }, {
	    key: "beginGroup",
	    value: function beginGroup(group) {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.save();
	      var suspendedCtx = this.suspendedCtx;

	      if (this.current.activeSMask) {
	        this.suspendedCtx = null;
	        this.current.activeSMask = null;
	      }

	      var currentCtx = this.ctx;

	      if (!group.isolated) {
	        (0, _util.info)("TODO: Support non-isolated groups.");
	      }

	      if (group.knockout) {
	        (0, _util.warn)("Knockout groups not supported.");
	      }

	      var currentTransform = currentCtx.mozCurrentTransform;

	      if (group.matrix) {
	        currentCtx.transform.apply(currentCtx, group.matrix);
	      }

	      if (!group.bbox) {
	        throw new Error("Bounding box is required.");
	      }

	      var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

	      var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
	      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
	      var offsetX = Math.floor(bounds[0]);
	      var offsetY = Math.floor(bounds[1]);
	      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
	      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
	      var scaleX = 1,
	          scaleY = 1;

	      if (drawnWidth > MAX_GROUP_SIZE) {
	        scaleX = drawnWidth / MAX_GROUP_SIZE;
	        drawnWidth = MAX_GROUP_SIZE;
	      }

	      if (drawnHeight > MAX_GROUP_SIZE) {
	        scaleY = drawnHeight / MAX_GROUP_SIZE;
	        drawnHeight = MAX_GROUP_SIZE;
	      }

	      this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
	      var cacheId = "groupAt" + this.groupLevel;

	      if (group.smask) {
	        cacheId += "_smask_" + this.smaskCounter++ % 2;
	      }

	      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
	      var groupCtx = scratchCanvas.context;
	      groupCtx.scale(1 / scaleX, 1 / scaleY);
	      groupCtx.translate(-offsetX, -offsetY);
	      groupCtx.transform.apply(groupCtx, currentTransform);

	      if (group.smask) {
	        this.smaskStack.push({
	          canvas: scratchCanvas.canvas,
	          context: groupCtx,
	          offsetX: offsetX,
	          offsetY: offsetY,
	          scaleX: scaleX,
	          scaleY: scaleY,
	          subtype: group.smask.subtype,
	          backdrop: group.smask.backdrop,
	          transferMap: group.smask.transferMap || null,
	          startTransformInverse: null
	        });
	      } else {
	        currentCtx.setTransform(1, 0, 0, 1, 0, 0);
	        currentCtx.translate(offsetX, offsetY);
	        currentCtx.scale(scaleX, scaleY);
	        currentCtx.save();
	      }

	      copyCtxState(currentCtx, groupCtx);
	      this.ctx = groupCtx;
	      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
	      this.groupStack.push({
	        ctx: currentCtx,
	        suspendedCtx: suspendedCtx
	      });
	      this.groupLevel++;
	    }
	  }, {
	    key: "endGroup",
	    value: function endGroup(group) {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.groupLevel--;
	      var groupCtx = this.ctx;

	      var _this$groupStack$pop = this.groupStack.pop(),
	          ctx = _this$groupStack$pop.ctx,
	          suspendedCtx = _this$groupStack$pop.suspendedCtx;

	      this.ctx = ctx;
	      this.ctx.imageSmoothingEnabled = false;

	      if (suspendedCtx) {
	        this.suspendedCtx = suspendedCtx;
	      }

	      if (group.smask) {
	        this.tempSMask = this.smaskStack.pop();
	        this.restore();
	      } else {
	        this.ctx.restore();
	        var currentMtx = this.ctx.mozCurrentTransform;
	        this.restore();
	        this.ctx.save();
	        this.ctx.setTransform.apply(this.ctx, currentMtx);

	        var dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);

	        this.ctx.drawImage(groupCtx.canvas, 0, 0);
	        this.ctx.restore();
	        this.compose(dirtyBox);
	      }
	    }
	  }, {
	    key: "beginAnnotations",
	    value: function beginAnnotations() {
	      this.save();

	      if (this.baseTransform) {
	        this.ctx.setTransform.apply(this.ctx, this.baseTransform);
	      }
	    }
	  }, {
	    key: "endAnnotations",
	    value: function endAnnotations() {
	      this.restore();
	    }
	  }, {
	    key: "beginAnnotation",
	    value: function beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
	      this.save();

	      if (Array.isArray(rect) && rect.length === 4) {
	        var width = rect[2] - rect[0];
	        var height = rect[3] - rect[1];

	        if (hasOwnCanvas && this.annotationCanvasMap) {
	          transform = transform.slice();
	          transform[4] -= rect[0];
	          transform[5] -= rect[1];
	          rect = rect.slice();
	          rect[0] = rect[1] = 0;
	          rect[2] = width;
	          rect[3] = height;

	          var _Util$singularValueDe = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform),
	              _Util$singularValueDe2 = _slicedToArray(_Util$singularValueDe, 2),
	              scaleX = _Util$singularValueDe2[0],
	              scaleY = _Util$singularValueDe2[1];

	          var viewportScale = this.viewportScale;
	          var canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
	          var canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
	          this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
	          var _this$annotationCanva = this.annotationCanvas,
	              canvas = _this$annotationCanva.canvas,
	              context = _this$annotationCanva.context;
	          canvas.style.width = "calc(".concat(width, "px * var(--viewport-scale-factor))");
	          canvas.style.height = "calc(".concat(height, "px * var(--viewport-scale-factor))");
	          this.annotationCanvasMap.set(id, canvas);
	          this.annotationCanvas.savedCtx = this.ctx;
	          this.ctx = context;
	          this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
	          addContextCurrentTransform(this.ctx);
	          resetCtxToDefault(this.ctx);
	        } else {
	          resetCtxToDefault(this.ctx);
	          this.ctx.rect(rect[0], rect[1], width, height);
	          this.clip();
	          this.endPath();
	        }
	      }

	      this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
	      this.transform.apply(this, transform);
	      this.transform.apply(this, matrix);
	    }
	  }, {
	    key: "endAnnotation",
	    value: function endAnnotation() {
	      if (this.annotationCanvas) {
	        this.ctx = this.annotationCanvas.savedCtx;
	        delete this.annotationCanvas.savedCtx;
	        delete this.annotationCanvas;
	      }

	      this.restore();
	    }
	  }, {
	    key: "paintImageMaskXObject",
	    value: function paintImageMaskXObject(img) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var ctx = this.ctx;
	      var width = img.width,
	          height = img.height;
	      var glyph = this.processingType3;

	      if (glyph && glyph.compiled === undefined) {
	        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
	          glyph.compiled = compileType3Glyph({
	            data: img.data,
	            width: width,
	            height: height
	          });
	        } else {
	          glyph.compiled = null;
	        }
	      }

	      if (glyph !== null && glyph !== void 0 && glyph.compiled) {
	        glyph.compiled(ctx);
	        return;
	      }

	      var mask = this._createMaskCanvas(img);

	      var maskCanvas = mask.canvas;
	      ctx.save();
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
	      ctx.restore();
	      this.compose();
	    }
	  }, {
	    key: "paintImageMaskXObjectRepeat",
	    value: function paintImageMaskXObjectRepeat(imgData, scaleX) {
	      var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	      var scaleY = arguments.length > 4 ? arguments[4] : undefined;
	      var positions = arguments.length > 5 ? arguments[5] : undefined;

	      if (!this.contentVisible) {
	        return;
	      }

	      var ctx = this.ctx;
	      ctx.save();
	      var currentTransform = ctx.mozCurrentTransform;
	      ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);

	      var mask = this._createMaskCanvas(imgData);

	      ctx.setTransform(1, 0, 0, 1, 0, 0);

	      for (var i = 0, ii = positions.length; i < ii; i += 2) {
	        var trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);

	        var _Util$applyTransform3 = _util.Util.applyTransform([0, 0], trans),
	            _Util$applyTransform4 = _slicedToArray(_Util$applyTransform3, 2),
	            x = _Util$applyTransform4[0],
	            y = _Util$applyTransform4[1];

	        ctx.drawImage(mask.canvas, x, y);
	      }

	      ctx.restore();
	      this.compose();
	    }
	  }, {
	    key: "paintImageMaskXObjectGroup",
	    value: function paintImageMaskXObjectGroup(images) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var ctx = this.ctx;
	      var fillColor = this.current.fillColor;
	      var isPatternFill = this.current.patternFill;

	      for (var i = 0, ii = images.length; i < ii; i++) {
	        var image = images[i];
	        var width = image.width,
	            height = image.height;
	        var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
	        var maskCtx = maskCanvas.context;
	        maskCtx.save();
	        putBinaryImageMask(maskCtx, image);
	        maskCtx.globalCompositeOperation = "source-in";
	        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;
	        maskCtx.fillRect(0, 0, width, height);
	        maskCtx.restore();
	        ctx.save();
	        ctx.transform.apply(ctx, image.transform);
	        ctx.scale(1, -1);
	        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
	        ctx.restore();
	      }

	      this.compose();
	    }
	  }, {
	    key: "paintImageXObject",
	    value: function paintImageXObject(objId) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

	      if (!imgData) {
	        (0, _util.warn)("Dependent image isn't ready yet");
	        return;
	      }

	      this.paintInlineImageXObject(imgData);
	    }
	  }, {
	    key: "paintImageXObjectRepeat",
	    value: function paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

	      if (!imgData) {
	        (0, _util.warn)("Dependent image isn't ready yet");
	        return;
	      }

	      var width = imgData.width;
	      var height = imgData.height;
	      var map = [];

	      for (var i = 0, ii = positions.length; i < ii; i += 2) {
	        map.push({
	          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
	          x: 0,
	          y: 0,
	          w: width,
	          h: height
	        });
	      }

	      this.paintInlineImageXObjectGroup(imgData, map);
	    }
	  }, {
	    key: "paintInlineImageXObject",
	    value: function paintInlineImageXObject(imgData) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var width = imgData.width;
	      var height = imgData.height;
	      var ctx = this.ctx;
	      this.save();
	      ctx.scale(1 / width, -1 / height);
	      var imgToPaint;

	      if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
	        imgToPaint = imgData;
	      } else {
	        var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
	        var tmpCtx = tmpCanvas.context;
	        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
	        imgToPaint = tmpCanvas.canvas;
	      }

	      var scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);

	      ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
	      ctx.drawImage(scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);

	      if (this.imageLayer) {
	        var position = this.getCanvasPosition(0, -height);
	        this.imageLayer.appendImage({
	          imgData: imgData,
	          left: position[0],
	          top: position[1],
	          width: width / ctx.mozCurrentTransformInverse[0],
	          height: height / ctx.mozCurrentTransformInverse[3]
	        });
	      }

	      this.compose();
	      this.restore();
	    }
	  }, {
	    key: "paintInlineImageXObjectGroup",
	    value: function paintInlineImageXObjectGroup(imgData, map) {
	      if (!this.contentVisible) {
	        return;
	      }

	      var ctx = this.ctx;
	      var w = imgData.width;
	      var h = imgData.height;
	      var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
	      var tmpCtx = tmpCanvas.context;
	      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

	      for (var i = 0, ii = map.length; i < ii; i++) {
	        var entry = map[i];
	        ctx.save();
	        ctx.transform.apply(ctx, entry.transform);
	        ctx.scale(1, -1);
	        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

	        if (this.imageLayer) {
	          var position = this.getCanvasPosition(entry.x, entry.y);
	          this.imageLayer.appendImage({
	            imgData: imgData,
	            left: position[0],
	            top: position[1],
	            width: w,
	            height: h
	          });
	        }

	        ctx.restore();
	      }

	      this.compose();
	    }
	  }, {
	    key: "paintSolidColorImageMask",
	    value: function paintSolidColorImageMask() {
	      if (!this.contentVisible) {
	        return;
	      }

	      this.ctx.fillRect(0, 0, 1, 1);
	      this.compose();
	    }
	  }, {
	    key: "markPoint",
	    value: function markPoint(tag) {}
	  }, {
	    key: "markPointProps",
	    value: function markPointProps(tag, properties) {}
	  }, {
	    key: "beginMarkedContent",
	    value: function beginMarkedContent(tag) {
	      this.markedContentStack.push({
	        visible: true
	      });
	    }
	  }, {
	    key: "beginMarkedContentProps",
	    value: function beginMarkedContentProps(tag, properties) {
	      if (tag === "OC") {
	        this.markedContentStack.push({
	          visible: this.optionalContentConfig.isVisible(properties)
	        });
	      } else {
	        this.markedContentStack.push({
	          visible: true
	        });
	      }

	      this.contentVisible = this.isContentVisible();
	    }
	  }, {
	    key: "endMarkedContent",
	    value: function endMarkedContent() {
	      this.markedContentStack.pop();
	      this.contentVisible = this.isContentVisible();
	    }
	  }, {
	    key: "beginCompat",
	    value: function beginCompat() {}
	  }, {
	    key: "endCompat",
	    value: function endCompat() {}
	  }, {
	    key: "consumePath",
	    value: function consumePath(clipBox) {
	      if (this.pendingClip) {
	        this.current.updateClipFromPath();
	      }

	      if (!this.pendingClip) {
	        this.compose(clipBox);
	      }

	      var ctx = this.ctx;

	      if (this.pendingClip) {
	        if (this.pendingClip === EO_CLIP) {
	          ctx.clip("evenodd");
	        } else {
	          ctx.clip();
	        }

	        this.pendingClip = null;
	      }

	      this.current.startNewPathAndClipBox(this.current.clipBox);
	      ctx.beginPath();
	    }
	  }, {
	    key: "getSinglePixelWidth",
	    value: function getSinglePixelWidth() {
	      if (this._cachedGetSinglePixelWidth === null) {
	        var m = this.ctx.mozCurrentTransform;
	        var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
	        var sqNorm1 = Math.pow(m[0], 2) + Math.pow(m[2], 2);
	        var sqNorm2 = Math.pow(m[1], 2) + Math.pow(m[3], 2);
	        var pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;

	        if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
	          this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
	        } else if (absDet > Number.EPSILON) {
	          this._cachedGetSinglePixelWidth = pixelHeight;
	        } else {
	          this._cachedGetSinglePixelWidth = 1;
	        }
	      }

	      return this._cachedGetSinglePixelWidth;
	    }
	  }, {
	    key: "getCanvasPosition",
	    value: function getCanvasPosition(x, y) {
	      var transform = this.ctx.mozCurrentTransform;
	      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
	    }
	  }, {
	    key: "isContentVisible",
	    value: function isContentVisible() {
	      for (var i = this.markedContentStack.length - 1; i >= 0; i--) {
	        if (!this.markedContentStack[i].visible) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }]);

	  return CanvasGraphics;
	}();

	exports.CanvasGraphics = CanvasGraphics;

	for (var op in _util.OPS) {
	  if (CanvasGraphics.prototype[op] !== undefined) {
	    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
	  }
	}

	/***/ }),
	/* 141 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.TilingPattern = exports.PathType = void 0;
	exports.getShadingPattern = getShadingPattern;

	var _util = __w_pdfjs_require__(4);

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var PathType = {
	  FILL: "Fill",
	  STROKE: "Stroke",
	  SHADING: "Shading"
	};
	exports.PathType = PathType;

	function applyBoundingBox(ctx, bbox) {
	  if (!bbox || typeof Path2D === "undefined") {
	    return;
	  }

	  var width = bbox[2] - bbox[0];
	  var height = bbox[3] - bbox[1];
	  var region = new Path2D();
	  region.rect(bbox[0], bbox[1], width, height);
	  ctx.clip(region);
	}

	var BaseShadingPattern = /*#__PURE__*/function () {
	  function BaseShadingPattern() {
	    _classCallCheck(this, BaseShadingPattern);

	    if (this.constructor === BaseShadingPattern) {
	      (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
	    }
	  }

	  _createClass(BaseShadingPattern, [{
	    key: "getPattern",
	    value: function getPattern() {
	      (0, _util.unreachable)("Abstract method `getPattern` called.");
	    }
	  }]);

	  return BaseShadingPattern;
	}();

	var RadialAxialShadingPattern = /*#__PURE__*/function (_BaseShadingPattern) {
	  _inherits(RadialAxialShadingPattern, _BaseShadingPattern);

	  var _super = _createSuper(RadialAxialShadingPattern);

	  function RadialAxialShadingPattern(IR) {
	    var _this;

	    _classCallCheck(this, RadialAxialShadingPattern);

	    _this = _super.call(this);
	    _this._type = IR[1];
	    _this._bbox = IR[2];
	    _this._colorStops = IR[3];
	    _this._p0 = IR[4];
	    _this._p1 = IR[5];
	    _this._r0 = IR[6];
	    _this._r1 = IR[7];
	    _this.matrix = null;
	    return _this;
	  }

	  _createClass(RadialAxialShadingPattern, [{
	    key: "_createGradient",
	    value: function _createGradient(ctx) {
	      var grad;

	      if (this._type === "axial") {
	        grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
	      } else if (this._type === "radial") {
	        grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
	      }

	      var _iterator = _createForOfIteratorHelper(this._colorStops),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var colorStop = _step.value;
	          grad.addColorStop(colorStop[0], colorStop[1]);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      return grad;
	    }
	  }, {
	    key: "getPattern",
	    value: function getPattern(ctx, owner, inverse, pathType) {
	      var pattern;

	      if (pathType === PathType.STROKE || pathType === PathType.FILL) {
	        var ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];
	        var width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
	        var height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
	        var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
	        var tmpCtx = tmpCanvas.context;
	        tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
	        tmpCtx.beginPath();
	        tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
	        tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
	        inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
	        tmpCtx.transform.apply(tmpCtx, owner.baseTransform);

	        if (this.matrix) {
	          tmpCtx.transform.apply(tmpCtx, this.matrix);
	        }

	        applyBoundingBox(tmpCtx, this._bbox);
	        tmpCtx.fillStyle = this._createGradient(tmpCtx);
	        tmpCtx.fill();
	        pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
	        var domMatrix = new DOMMatrix(inverse);

	        try {
	          pattern.setTransform(domMatrix);
	        } catch (ex) {
	          (0, _util.warn)("RadialAxialShadingPattern.getPattern: \"".concat(ex === null || ex === void 0 ? void 0 : ex.message, "\"."));
	        }
	      } else {
	        applyBoundingBox(ctx, this._bbox);
	        pattern = this._createGradient(ctx);
	      }

	      return pattern;
	    }
	  }]);

	  return RadialAxialShadingPattern;
	}(BaseShadingPattern);

	function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
	  var coords = context.coords,
	      colors = context.colors;
	  var bytes = data.data,
	      rowSize = data.width * 4;
	  var tmp;

	  if (coords[p1 + 1] > coords[p2 + 1]) {
	    tmp = p1;
	    p1 = p2;
	    p2 = tmp;
	    tmp = c1;
	    c1 = c2;
	    c2 = tmp;
	  }

	  if (coords[p2 + 1] > coords[p3 + 1]) {
	    tmp = p2;
	    p2 = p3;
	    p3 = tmp;
	    tmp = c2;
	    c2 = c3;
	    c3 = tmp;
	  }

	  if (coords[p1 + 1] > coords[p2 + 1]) {
	    tmp = p1;
	    p1 = p2;
	    p2 = tmp;
	    tmp = c1;
	    c1 = c2;
	    c2 = tmp;
	  }

	  var x1 = (coords[p1] + context.offsetX) * context.scaleX;
	  var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
	  var x2 = (coords[p2] + context.offsetX) * context.scaleX;
	  var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
	  var x3 = (coords[p3] + context.offsetX) * context.scaleX;
	  var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

	  if (y1 >= y3) {
	    return;
	  }

	  var c1r = colors[c1],
	      c1g = colors[c1 + 1],
	      c1b = colors[c1 + 2];
	  var c2r = colors[c2],
	      c2g = colors[c2 + 1],
	      c2b = colors[c2 + 2];
	  var c3r = colors[c3],
	      c3g = colors[c3 + 1],
	      c3b = colors[c3 + 2];
	  var minY = Math.round(y1),
	      maxY = Math.round(y3);
	  var xa, car, cag, cab;
	  var xb, cbr, cbg, cbb;

	  for (var y = minY; y <= maxY; y++) {
	    if (y < y2) {
	      var _k = void 0;

	      if (y < y1) {
	        _k = 0;
	      } else {
	        _k = (y1 - y) / (y1 - y2);
	      }

	      xa = x1 - (x1 - x2) * _k;
	      car = c1r - (c1r - c2r) * _k;
	      cag = c1g - (c1g - c2g) * _k;
	      cab = c1b - (c1b - c2b) * _k;
	    } else {
	      var _k2 = void 0;

	      if (y > y3) {
	        _k2 = 1;
	      } else if (y2 === y3) {
	        _k2 = 0;
	      } else {
	        _k2 = (y2 - y) / (y2 - y3);
	      }

	      xa = x2 - (x2 - x3) * _k2;
	      car = c2r - (c2r - c3r) * _k2;
	      cag = c2g - (c2g - c3g) * _k2;
	      cab = c2b - (c2b - c3b) * _k2;
	    }

	    var k = void 0;

	    if (y < y1) {
	      k = 0;
	    } else if (y > y3) {
	      k = 1;
	    } else {
	      k = (y1 - y) / (y1 - y3);
	    }

	    xb = x1 - (x1 - x3) * k;
	    cbr = c1r - (c1r - c3r) * k;
	    cbg = c1g - (c1g - c3g) * k;
	    cbb = c1b - (c1b - c3b) * k;
	    var x1_ = Math.round(Math.min(xa, xb));
	    var x2_ = Math.round(Math.max(xa, xb));
	    var j = rowSize * y + x1_ * 4;

	    for (var x = x1_; x <= x2_; x++) {
	      k = (xa - x) / (xa - xb);

	      if (k < 0) {
	        k = 0;
	      } else if (k > 1) {
	        k = 1;
	      }

	      bytes[j++] = car - (car - cbr) * k | 0;
	      bytes[j++] = cag - (cag - cbg) * k | 0;
	      bytes[j++] = cab - (cab - cbb) * k | 0;
	      bytes[j++] = 255;
	    }
	  }
	}

	function drawFigure(data, figure, context) {
	  var ps = figure.coords;
	  var cs = figure.colors;
	  var i, ii;

	  switch (figure.type) {
	    case "lattice":
	      var verticesPerRow = figure.verticesPerRow;
	      var rows = Math.floor(ps.length / verticesPerRow) - 1;
	      var cols = verticesPerRow - 1;

	      for (i = 0; i < rows; i++) {
	        var q = i * verticesPerRow;

	        for (var j = 0; j < cols; j++, q++) {
	          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
	          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
	        }
	      }

	      break;

	    case "triangles":
	      for (i = 0, ii = ps.length; i < ii; i += 3) {
	        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
	      }

	      break;

	    default:
	      throw new Error("illegal figure");
	  }
	}

	var MeshShadingPattern = /*#__PURE__*/function (_BaseShadingPattern2) {
	  _inherits(MeshShadingPattern, _BaseShadingPattern2);

	  var _super2 = _createSuper(MeshShadingPattern);

	  function MeshShadingPattern(IR) {
	    var _this2;

	    _classCallCheck(this, MeshShadingPattern);

	    _this2 = _super2.call(this);
	    _this2._coords = IR[2];
	    _this2._colors = IR[3];
	    _this2._figures = IR[4];
	    _this2._bounds = IR[5];
	    _this2._bbox = IR[7];
	    _this2._background = IR[8];
	    _this2.matrix = null;
	    return _this2;
	  }

	  _createClass(MeshShadingPattern, [{
	    key: "_createMeshCanvas",
	    value: function _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
	      var EXPECTED_SCALE = 1.1;
	      var MAX_PATTERN_SIZE = 3000;
	      var BORDER_SIZE = 2;
	      var offsetX = Math.floor(this._bounds[0]);
	      var offsetY = Math.floor(this._bounds[1]);
	      var boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
	      var boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
	      var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
	      var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
	      var scaleX = boundsWidth / width;
	      var scaleY = boundsHeight / height;
	      var context = {
	        coords: this._coords,
	        colors: this._colors,
	        offsetX: -offsetX,
	        offsetY: -offsetY,
	        scaleX: 1 / scaleX,
	        scaleY: 1 / scaleY
	      };
	      var paddedWidth = width + BORDER_SIZE * 2;
	      var paddedHeight = height + BORDER_SIZE * 2;
	      var tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
	      var tmpCtx = tmpCanvas.context;
	      var data = tmpCtx.createImageData(width, height);

	      if (backgroundColor) {
	        var bytes = data.data;

	        for (var i = 0, ii = bytes.length; i < ii; i += 4) {
	          bytes[i] = backgroundColor[0];
	          bytes[i + 1] = backgroundColor[1];
	          bytes[i + 2] = backgroundColor[2];
	          bytes[i + 3] = 255;
	        }
	      }

	      var _iterator2 = _createForOfIteratorHelper(this._figures),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var figure = _step2.value;
	          drawFigure(data, figure, context);
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
	      var canvas = tmpCanvas.canvas;
	      return {
	        canvas: canvas,
	        offsetX: offsetX - BORDER_SIZE * scaleX,
	        offsetY: offsetY - BORDER_SIZE * scaleY,
	        scaleX: scaleX,
	        scaleY: scaleY
	      };
	    }
	  }, {
	    key: "getPattern",
	    value: function getPattern(ctx, owner, inverse, pathType) {
	      applyBoundingBox(ctx, this._bbox);
	      var scale;

	      if (pathType === PathType.SHADING) {
	        scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
	      } else {
	        scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

	        if (this.matrix) {
	          var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

	          scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
	        }
	      }

	      var temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);

	      if (pathType !== PathType.SHADING) {
	        ctx.setTransform.apply(ctx, owner.baseTransform);

	        if (this.matrix) {
	          ctx.transform.apply(ctx, this.matrix);
	        }
	      }

	      ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
	      ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
	      return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
	    }
	  }]);

	  return MeshShadingPattern;
	}(BaseShadingPattern);

	var DummyShadingPattern = /*#__PURE__*/function (_BaseShadingPattern3) {
	  _inherits(DummyShadingPattern, _BaseShadingPattern3);

	  var _super3 = _createSuper(DummyShadingPattern);

	  function DummyShadingPattern() {
	    _classCallCheck(this, DummyShadingPattern);

	    return _super3.apply(this, arguments);
	  }

	  _createClass(DummyShadingPattern, [{
	    key: "getPattern",
	    value: function getPattern() {
	      return "hotpink";
	    }
	  }]);

	  return DummyShadingPattern;
	}(BaseShadingPattern);

	function getShadingPattern(IR) {
	  switch (IR[0]) {
	    case "RadialAxial":
	      return new RadialAxialShadingPattern(IR);

	    case "Mesh":
	      return new MeshShadingPattern(IR);

	    case "Dummy":
	      return new DummyShadingPattern();
	  }

	  throw new Error("Unknown IR type: ".concat(IR[0]));
	}

	var PaintType = {
	  COLORED: 1,
	  UNCOLORED: 2
	};

	var TilingPattern = /*#__PURE__*/function () {
	  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
	    _classCallCheck(this, TilingPattern);

	    this.operatorList = IR[2];
	    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
	    this.bbox = IR[4];
	    this.xstep = IR[5];
	    this.ystep = IR[6];
	    this.paintType = IR[7];
	    this.tilingType = IR[8];
	    this.color = color;
	    this.ctx = ctx;
	    this.canvasGraphicsFactory = canvasGraphicsFactory;
	    this.baseTransform = baseTransform;
	  }

	  _createClass(TilingPattern, [{
	    key: "createPatternCanvas",
	    value: function createPatternCanvas(owner) {
	      var operatorList = this.operatorList;
	      var bbox = this.bbox;
	      var xstep = this.xstep;
	      var ystep = this.ystep;
	      var paintType = this.paintType;
	      var tilingType = this.tilingType;
	      var color = this.color;
	      var canvasGraphicsFactory = this.canvasGraphicsFactory;
	      (0, _util.info)("TilingType: " + tilingType);
	      var x0 = bbox[0],
	          y0 = bbox[1],
	          x1 = bbox[2],
	          y1 = bbox[3];

	      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

	      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

	      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
	      var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
	      var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
	      var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
	      var tmpCtx = tmpCanvas.context;
	      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
	      graphics.groupLevel = owner.groupLevel;
	      this.setFillAndStrokeStyleToContext(graphics, paintType, color);
	      var adjustedX0 = x0;
	      var adjustedY0 = y0;
	      var adjustedX1 = x1;
	      var adjustedY1 = y1;

	      if (x0 < 0) {
	        adjustedX0 = 0;
	        adjustedX1 += Math.abs(x0);
	      }

	      if (y0 < 0) {
	        adjustedY0 = 0;
	        adjustedY1 += Math.abs(y0);
	      }

	      tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
	      graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
	      this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
	      graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
	      graphics.executeOperatorList(operatorList);
	      graphics.endDrawing();
	      return {
	        canvas: tmpCanvas.canvas,
	        scaleX: dimx.scale,
	        scaleY: dimy.scale,
	        offsetX: adjustedX0,
	        offsetY: adjustedY0
	      };
	    }
	  }, {
	    key: "getSizeAndScale",
	    value: function getSizeAndScale(step, realOutputSize, scale) {
	      step = Math.abs(step);
	      var maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
	      var size = Math.ceil(step * scale);

	      if (size >= maxSize) {
	        size = maxSize;
	      } else {
	        scale = size / step;
	      }

	      return {
	        scale: scale,
	        size: size
	      };
	    }
	  }, {
	    key: "clipBbox",
	    value: function clipBbox(graphics, x0, y0, x1, y1) {
	      var bboxWidth = x1 - x0;
	      var bboxHeight = y1 - y0;
	      graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
	      graphics.clip();
	      graphics.endPath();
	    }
	  }, {
	    key: "setFillAndStrokeStyleToContext",
	    value: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
	      var context = graphics.ctx,
	          current = graphics.current;

	      switch (paintType) {
	        case PaintType.COLORED:
	          var ctx = this.ctx;
	          context.fillStyle = ctx.fillStyle;
	          context.strokeStyle = ctx.strokeStyle;
	          current.fillColor = ctx.fillStyle;
	          current.strokeColor = ctx.strokeStyle;
	          break;

	        case PaintType.UNCOLORED:
	          var cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

	          context.fillStyle = cssColor;
	          context.strokeStyle = cssColor;
	          current.fillColor = cssColor;
	          current.strokeColor = cssColor;
	          break;

	        default:
	          throw new _util.FormatError("Unsupported paint type: ".concat(paintType));
	      }
	    }
	  }, {
	    key: "getPattern",
	    value: function getPattern(ctx, owner, inverse, pathType) {
	      var matrix = inverse;

	      if (pathType !== PathType.SHADING) {
	        matrix = _util.Util.transform(matrix, owner.baseTransform);

	        if (this.matrix) {
	          matrix = _util.Util.transform(matrix, this.matrix);
	        }
	      }

	      var temporaryPatternCanvas = this.createPatternCanvas(owner);
	      var domMatrix = new DOMMatrix(matrix);
	      domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
	      domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
	      var pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");

	      try {
	        pattern.setTransform(domMatrix);
	      } catch (ex) {
	        (0, _util.warn)("TilingPattern.getPattern: \"".concat(ex === null || ex === void 0 ? void 0 : ex.message, "\"."));
	      }

	      return pattern;
	    }
	  }], [{
	    key: "MAX_PATTERN_SIZE",
	    get: function get() {
	      return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
	    }
	  }]);

	  return TilingPattern;
	}();

	exports.TilingPattern = TilingPattern;

	/***/ }),
	/* 142 */
	/***/ ((__unused_webpack_module, exports) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.GlobalWorkerOptions = void 0;
	var GlobalWorkerOptions = Object.create(null);
	exports.GlobalWorkerOptions = GlobalWorkerOptions;
	GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
	GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

	/***/ }),
	/* 143 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.MessageHandler = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var CallbackKind = {
	  UNKNOWN: 0,
	  DATA: 1,
	  ERROR: 2
	};
	var StreamKind = {
	  UNKNOWN: 0,
	  CANCEL: 1,
	  CANCEL_COMPLETE: 2,
	  CLOSE: 3,
	  ENQUEUE: 4,
	  ERROR: 5,
	  PULL: 6,
	  PULL_COMPLETE: 7,
	  START_COMPLETE: 8
	};

	function wrapReason(reason) {
	  if (!(reason instanceof Error || _typeof(reason) === "object" && reason !== null)) {
	    (0, _util.warn)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
	    return reason;
	  }

	  switch (reason.name) {
	    case "AbortException":
	      return new _util.AbortException(reason.message);

	    case "MissingPDFException":
	      return new _util.MissingPDFException(reason.message);

	    case "PasswordException":
	      return new _util.PasswordException(reason.message, reason.code);

	    case "UnexpectedResponseException":
	      return new _util.UnexpectedResponseException(reason.message, reason.status);

	    case "UnknownErrorException":
	      return new _util.UnknownErrorException(reason.message, reason.details);

	    default:
	      return new _util.UnknownErrorException(reason.message, reason.toString());
	  }
	}

	var MessageHandler = /*#__PURE__*/function () {
	  function MessageHandler(sourceName, targetName, comObj) {
	    var _this = this;

	    _classCallCheck(this, MessageHandler);

	    this.sourceName = sourceName;
	    this.targetName = targetName;
	    this.comObj = comObj;
	    this.callbackId = 1;
	    this.streamId = 1;
	    this.streamSinks = Object.create(null);
	    this.streamControllers = Object.create(null);
	    this.callbackCapabilities = Object.create(null);
	    this.actionHandler = Object.create(null);

	    this._onComObjOnMessage = function (event) {
	      var data = event.data;

	      if (data.targetName !== _this.sourceName) {
	        return;
	      }

	      if (data.stream) {
	        _this._processStreamMessage(data);

	        return;
	      }

	      if (data.callback) {
	        var callbackId = data.callbackId;
	        var capability = _this.callbackCapabilities[callbackId];

	        if (!capability) {
	          throw new Error("Cannot resolve callback ".concat(callbackId));
	        }

	        delete _this.callbackCapabilities[callbackId];

	        if (data.callback === CallbackKind.DATA) {
	          capability.resolve(data.data);
	        } else if (data.callback === CallbackKind.ERROR) {
	          capability.reject(wrapReason(data.reason));
	        } else {
	          throw new Error("Unexpected callback case");
	        }

	        return;
	      }

	      var action = _this.actionHandler[data.action];

	      if (!action) {
	        throw new Error("Unknown action from worker: ".concat(data.action));
	      }

	      if (data.callbackId) {
	        var cbSourceName = _this.sourceName;
	        var cbTargetName = data.sourceName;
	        new Promise(function (resolve) {
	          resolve(action(data.data));
	        }).then(function (result) {
	          comObj.postMessage({
	            sourceName: cbSourceName,
	            targetName: cbTargetName,
	            callback: CallbackKind.DATA,
	            callbackId: data.callbackId,
	            data: result
	          });
	        }, function (reason) {
	          comObj.postMessage({
	            sourceName: cbSourceName,
	            targetName: cbTargetName,
	            callback: CallbackKind.ERROR,
	            callbackId: data.callbackId,
	            reason: wrapReason(reason)
	          });
	        });
	        return;
	      }

	      if (data.streamId) {
	        _this._createStreamSink(data);

	        return;
	      }

	      action(data.data);
	    };

	    comObj.addEventListener("message", this._onComObjOnMessage);
	  }

	  _createClass(MessageHandler, [{
	    key: "on",
	    value: function on(actionName, handler) {
	      var ah = this.actionHandler;

	      if (ah[actionName]) {
	        throw new Error("There is already an actionName called \"".concat(actionName, "\""));
	      }

	      ah[actionName] = handler;
	    }
	  }, {
	    key: "send",
	    value: function send(actionName, data, transfers) {
	      this.comObj.postMessage({
	        sourceName: this.sourceName,
	        targetName: this.targetName,
	        action: actionName,
	        data: data
	      }, transfers);
	    }
	  }, {
	    key: "sendWithPromise",
	    value: function sendWithPromise(actionName, data, transfers) {
	      var callbackId = this.callbackId++;
	      var capability = (0, _util.createPromiseCapability)();
	      this.callbackCapabilities[callbackId] = capability;

	      try {
	        this.comObj.postMessage({
	          sourceName: this.sourceName,
	          targetName: this.targetName,
	          action: actionName,
	          callbackId: callbackId,
	          data: data
	        }, transfers);
	      } catch (ex) {
	        capability.reject(ex);
	      }

	      return capability.promise;
	    }
	  }, {
	    key: "sendWithStream",
	    value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
	      var _this2 = this;

	      var streamId = this.streamId++,
	          sourceName = this.sourceName,
	          targetName = this.targetName,
	          comObj = this.comObj;
	      return new ReadableStream({
	        start: function start(controller) {
	          var startCapability = (0, _util.createPromiseCapability)();
	          _this2.streamControllers[streamId] = {
	            controller: controller,
	            startCall: startCapability,
	            pullCall: null,
	            cancelCall: null,
	            isClosed: false
	          };
	          comObj.postMessage({
	            sourceName: sourceName,
	            targetName: targetName,
	            action: actionName,
	            streamId: streamId,
	            data: data,
	            desiredSize: controller.desiredSize
	          }, transfers);
	          return startCapability.promise;
	        },
	        pull: function pull(controller) {
	          var pullCapability = (0, _util.createPromiseCapability)();
	          _this2.streamControllers[streamId].pullCall = pullCapability;
	          comObj.postMessage({
	            sourceName: sourceName,
	            targetName: targetName,
	            stream: StreamKind.PULL,
	            streamId: streamId,
	            desiredSize: controller.desiredSize
	          });
	          return pullCapability.promise;
	        },
	        cancel: function cancel(reason) {
	          (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
	          var cancelCapability = (0, _util.createPromiseCapability)();
	          _this2.streamControllers[streamId].cancelCall = cancelCapability;
	          _this2.streamControllers[streamId].isClosed = true;
	          comObj.postMessage({
	            sourceName: sourceName,
	            targetName: targetName,
	            stream: StreamKind.CANCEL,
	            streamId: streamId,
	            reason: wrapReason(reason)
	          });
	          return cancelCapability.promise;
	        }
	      }, queueingStrategy);
	    }
	  }, {
	    key: "_createStreamSink",
	    value: function _createStreamSink(data) {
	      var streamId = data.streamId,
	          sourceName = this.sourceName,
	          targetName = data.sourceName,
	          comObj = this.comObj;
	      var self = this,
	          action = this.actionHandler[data.action];
	      var streamSink = {
	        enqueue: function enqueue(chunk) {
	          var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	          var transfers = arguments.length > 2 ? arguments[2] : undefined;

	          if (this.isCancelled) {
	            return;
	          }

	          var lastDesiredSize = this.desiredSize;
	          this.desiredSize -= size;

	          if (lastDesiredSize > 0 && this.desiredSize <= 0) {
	            this.sinkCapability = (0, _util.createPromiseCapability)();
	            this.ready = this.sinkCapability.promise;
	          }

	          comObj.postMessage({
	            sourceName: sourceName,
	            targetName: targetName,
	            stream: StreamKind.ENQUEUE,
	            streamId: streamId,
	            chunk: chunk
	          }, transfers);
	        },
	        close: function close() {
	          if (this.isCancelled) {
	            return;
	          }

	          this.isCancelled = true;
	          comObj.postMessage({
	            sourceName: sourceName,
	            targetName: targetName,
	            stream: StreamKind.CLOSE,
	            streamId: streamId
	          });
	          delete self.streamSinks[streamId];
	        },
	        error: function error(reason) {
	          (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

	          if (this.isCancelled) {
	            return;
	          }

	          this.isCancelled = true;
	          comObj.postMessage({
	            sourceName: sourceName,
	            targetName: targetName,
	            stream: StreamKind.ERROR,
	            streamId: streamId,
	            reason: wrapReason(reason)
	          });
	        },
	        sinkCapability: (0, _util.createPromiseCapability)(),
	        onPull: null,
	        onCancel: null,
	        isCancelled: false,
	        desiredSize: data.desiredSize,
	        ready: null
	      };
	      streamSink.sinkCapability.resolve();
	      streamSink.ready = streamSink.sinkCapability.promise;
	      this.streamSinks[streamId] = streamSink;
	      new Promise(function (resolve) {
	        resolve(action(data.data, streamSink));
	      }).then(function () {
	        comObj.postMessage({
	          sourceName: sourceName,
	          targetName: targetName,
	          stream: StreamKind.START_COMPLETE,
	          streamId: streamId,
	          success: true
	        });
	      }, function (reason) {
	        comObj.postMessage({
	          sourceName: sourceName,
	          targetName: targetName,
	          stream: StreamKind.START_COMPLETE,
	          streamId: streamId,
	          reason: wrapReason(reason)
	        });
	      });
	    }
	  }, {
	    key: "_processStreamMessage",
	    value: function _processStreamMessage(data) {
	      var streamId = data.streamId,
	          sourceName = this.sourceName,
	          targetName = data.sourceName,
	          comObj = this.comObj;
	      var streamController = this.streamControllers[streamId],
	          streamSink = this.streamSinks[streamId];

	      switch (data.stream) {
	        case StreamKind.START_COMPLETE:
	          if (data.success) {
	            streamController.startCall.resolve();
	          } else {
	            streamController.startCall.reject(wrapReason(data.reason));
	          }

	          break;

	        case StreamKind.PULL_COMPLETE:
	          if (data.success) {
	            streamController.pullCall.resolve();
	          } else {
	            streamController.pullCall.reject(wrapReason(data.reason));
	          }

	          break;

	        case StreamKind.PULL:
	          if (!streamSink) {
	            comObj.postMessage({
	              sourceName: sourceName,
	              targetName: targetName,
	              stream: StreamKind.PULL_COMPLETE,
	              streamId: streamId,
	              success: true
	            });
	            break;
	          }

	          if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
	            streamSink.sinkCapability.resolve();
	          }

	          streamSink.desiredSize = data.desiredSize;
	          new Promise(function (resolve) {
	            resolve(streamSink.onPull && streamSink.onPull());
	          }).then(function () {
	            comObj.postMessage({
	              sourceName: sourceName,
	              targetName: targetName,
	              stream: StreamKind.PULL_COMPLETE,
	              streamId: streamId,
	              success: true
	            });
	          }, function (reason) {
	            comObj.postMessage({
	              sourceName: sourceName,
	              targetName: targetName,
	              stream: StreamKind.PULL_COMPLETE,
	              streamId: streamId,
	              reason: wrapReason(reason)
	            });
	          });
	          break;

	        case StreamKind.ENQUEUE:
	          (0, _util.assert)(streamController, "enqueue should have stream controller");

	          if (streamController.isClosed) {
	            break;
	          }

	          streamController.controller.enqueue(data.chunk);
	          break;

	        case StreamKind.CLOSE:
	          (0, _util.assert)(streamController, "close should have stream controller");

	          if (streamController.isClosed) {
	            break;
	          }

	          streamController.isClosed = true;
	          streamController.controller.close();

	          this._deleteStreamController(streamController, streamId);

	          break;

	        case StreamKind.ERROR:
	          (0, _util.assert)(streamController, "error should have stream controller");
	          streamController.controller.error(wrapReason(data.reason));

	          this._deleteStreamController(streamController, streamId);

	          break;

	        case StreamKind.CANCEL_COMPLETE:
	          if (data.success) {
	            streamController.cancelCall.resolve();
	          } else {
	            streamController.cancelCall.reject(wrapReason(data.reason));
	          }

	          this._deleteStreamController(streamController, streamId);

	          break;

	        case StreamKind.CANCEL:
	          if (!streamSink) {
	            break;
	          }

	          new Promise(function (resolve) {
	            resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
	          }).then(function () {
	            comObj.postMessage({
	              sourceName: sourceName,
	              targetName: targetName,
	              stream: StreamKind.CANCEL_COMPLETE,
	              streamId: streamId,
	              success: true
	            });
	          }, function (reason) {
	            comObj.postMessage({
	              sourceName: sourceName,
	              targetName: targetName,
	              stream: StreamKind.CANCEL_COMPLETE,
	              streamId: streamId,
	              reason: wrapReason(reason)
	            });
	          });
	          streamSink.sinkCapability.reject(wrapReason(data.reason));
	          streamSink.isCancelled = true;
	          delete this.streamSinks[streamId];
	          break;

	        default:
	          throw new Error("Unexpected stream case");
	      }
	    }
	  }, {
	    key: "_deleteStreamController",
	    value: function () {
	      var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(streamController, streamId) {
	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);

	              case 2:
	                delete this.streamControllers[streamId];

	              case 3:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function _deleteStreamController(_x, _x2) {
	        return _deleteStreamController2.apply(this, arguments);
	      }

	      return _deleteStreamController;
	    }()
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.comObj.removeEventListener("message", this._onComObjOnMessage);
	    }
	  }]);

	  return MessageHandler;
	}();

	exports.MessageHandler = MessageHandler;

	/***/ }),
	/* 144 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.Metadata = void 0;

	var _util = __w_pdfjs_require__(4);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

	function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

	function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

	function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

	function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

	function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

	function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

	var _metadataMap = /*#__PURE__*/new WeakMap();

	var _data = /*#__PURE__*/new WeakMap();

	var Metadata = /*#__PURE__*/function () {
	  function Metadata(_ref) {
	    var parsedData = _ref.parsedData,
	        rawData = _ref.rawData;

	    _classCallCheck(this, Metadata);

	    _classPrivateFieldInitSpec(this, _metadataMap, {
	      writable: true,
	      value: void 0
	    });

	    _classPrivateFieldInitSpec(this, _data, {
	      writable: true,
	      value: void 0
	    });

	    _classPrivateFieldSet(this, _metadataMap, parsedData);

	    _classPrivateFieldSet(this, _data, rawData);
	  }

	  _createClass(Metadata, [{
	    key: "getRaw",
	    value: function getRaw() {
	      return _classPrivateFieldGet(this, _data);
	    }
	  }, {
	    key: "get",
	    value: function get(name) {
	      var _classPrivateFieldGet2;

	      return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _metadataMap).get(name)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
	    }
	  }, {
	    key: "getAll",
	    value: function getAll() {
	      return (0, _util.objectFromMap)(_classPrivateFieldGet(this, _metadataMap));
	    }
	  }, {
	    key: "has",
	    value: function has(name) {
	      return _classPrivateFieldGet(this, _metadataMap).has(name);
	    }
	  }]);

	  return Metadata;
	}();

	exports.Metadata = Metadata;

	/***/ }),
	/* 145 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.OptionalContentConfig = void 0;

	var _util = __w_pdfjs_require__(4);

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var OptionalContentGroup = function OptionalContentGroup(name, intent) {
	  _classCallCheck(this, OptionalContentGroup);

	  this.visible = true;
	  this.name = name;
	  this.intent = intent;
	};

	var OptionalContentConfig = /*#__PURE__*/function () {
	  function OptionalContentConfig(data) {
	    _classCallCheck(this, OptionalContentConfig);

	    this.name = null;
	    this.creator = null;
	    this._order = null;
	    this._groups = new Map();

	    if (data === null) {
	      return;
	    }

	    this.name = data.name;
	    this.creator = data.creator;
	    this._order = data.order;

	    var _iterator = _createForOfIteratorHelper(data.groups),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _group = _step.value;

	        this._groups.set(_group.id, new OptionalContentGroup(_group.name, _group.intent));
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }

	    if (data.baseState === "OFF") {
	      var _iterator2 = _createForOfIteratorHelper(this._groups),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var group = _step2.value;
	          group.visible = false;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }

	    var _iterator3 = _createForOfIteratorHelper(data.on),
	        _step3;

	    try {
	      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	        var on = _step3.value;
	        this._groups.get(on).visible = true;
	      }
	    } catch (err) {
	      _iterator3.e(err);
	    } finally {
	      _iterator3.f();
	    }

	    var _iterator4 = _createForOfIteratorHelper(data.off),
	        _step4;

	    try {
	      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	        var off = _step4.value;
	        this._groups.get(off).visible = false;
	      }
	    } catch (err) {
	      _iterator4.e(err);
	    } finally {
	      _iterator4.f();
	    }
	  }

	  _createClass(OptionalContentConfig, [{
	    key: "_evaluateVisibilityExpression",
	    value: function _evaluateVisibilityExpression(array) {
	      var length = array.length;

	      if (length < 2) {
	        return true;
	      }

	      var operator = array[0];

	      for (var i = 1; i < length; i++) {
	        var element = array[i];
	        var state = void 0;

	        if (Array.isArray(element)) {
	          state = this._evaluateVisibilityExpression(element);
	        } else if (this._groups.has(element)) {
	          state = this._groups.get(element).visible;
	        } else {
	          (0, _util.warn)("Optional content group not found: ".concat(element));
	          return true;
	        }

	        switch (operator) {
	          case "And":
	            if (!state) {
	              return false;
	            }

	            break;

	          case "Or":
	            if (state) {
	              return true;
	            }

	            break;

	          case "Not":
	            return !state;

	          default:
	            return true;
	        }
	      }

	      return operator === "And";
	    }
	  }, {
	    key: "isVisible",
	    value: function isVisible(group) {
	      if (this._groups.size === 0) {
	        return true;
	      }

	      if (!group) {
	        (0, _util.warn)("Optional content group not defined.");
	        return true;
	      }

	      if (group.type === "OCG") {
	        if (!this._groups.has(group.id)) {
	          (0, _util.warn)("Optional content group not found: ".concat(group.id));
	          return true;
	        }

	        return this._groups.get(group.id).visible;
	      } else if (group.type === "OCMD") {
	        if (group.expression) {
	          return this._evaluateVisibilityExpression(group.expression);
	        }

	        if (!group.policy || group.policy === "AnyOn") {
	          var _iterator5 = _createForOfIteratorHelper(group.ids),
	              _step5;

	          try {
	            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	              var id = _step5.value;

	              if (!this._groups.has(id)) {
	                (0, _util.warn)("Optional content group not found: ".concat(id));
	                return true;
	              }

	              if (this._groups.get(id).visible) {
	                return true;
	              }
	            }
	          } catch (err) {
	            _iterator5.e(err);
	          } finally {
	            _iterator5.f();
	          }

	          return false;
	        } else if (group.policy === "AllOn") {
	          var _iterator6 = _createForOfIteratorHelper(group.ids),
	              _step6;

	          try {
	            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	              var _id = _step6.value;

	              if (!this._groups.has(_id)) {
	                (0, _util.warn)("Optional content group not found: ".concat(_id));
	                return true;
	              }

	              if (!this._groups.get(_id).visible) {
	                return false;
	              }
	            }
	          } catch (err) {
	            _iterator6.e(err);
	          } finally {
	            _iterator6.f();
	          }

	          return true;
	        } else if (group.policy === "AnyOff") {
	          var _iterator7 = _createForOfIteratorHelper(group.ids),
	              _step7;

	          try {
	            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	              var _id2 = _step7.value;

	              if (!this._groups.has(_id2)) {
	                (0, _util.warn)("Optional content group not found: ".concat(_id2));
	                return true;
	              }

	              if (!this._groups.get(_id2).visible) {
	                return true;
	              }
	            }
	          } catch (err) {
	            _iterator7.e(err);
	          } finally {
	            _iterator7.f();
	          }

	          return false;
	        } else if (group.policy === "AllOff") {
	          var _iterator8 = _createForOfIteratorHelper(group.ids),
	              _step8;

	          try {
	            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
	              var _id3 = _step8.value;

	              if (!this._groups.has(_id3)) {
	                (0, _util.warn)("Optional content group not found: ".concat(_id3));
	                return true;
	              }

	              if (this._groups.get(_id3).visible) {
	                return false;
	              }
	            }
	          } catch (err) {
	            _iterator8.e(err);
	          } finally {
	            _iterator8.f();
	          }

	          return true;
	        }

	        (0, _util.warn)("Unknown optional content policy ".concat(group.policy, "."));
	        return true;
	      }

	      (0, _util.warn)("Unknown group type ".concat(group.type, "."));
	      return true;
	    }
	  }, {
	    key: "setVisibility",
	    value: function setVisibility(id) {
	      var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      if (!this._groups.has(id)) {
	        (0, _util.warn)("Optional content group not found: ".concat(id));
	        return;
	      }

	      this._groups.get(id).visible = !!visible;
	    }
	  }, {
	    key: "getOrder",
	    value: function getOrder() {
	      if (!this._groups.size) {
	        return null;
	      }

	      if (this._order) {
	        return this._order.slice();
	      }

	      return Array.from(this._groups.keys());
	    }
	  }, {
	    key: "getGroups",
	    value: function getGroups() {
	      return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;
	    }
	  }, {
	    key: "getGroup",
	    value: function getGroup(id) {
	      return this._groups.get(id) || null;
	    }
	  }]);

	  return OptionalContentConfig;
	}();

	exports.OptionalContentConfig = OptionalContentConfig;

	/***/ }),
	/* 146 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFDataTransportStream = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	var _display_utils = __w_pdfjs_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var PDFDataTransportStream = /*#__PURE__*/function () {
	  function PDFDataTransportStream(params, pdfDataRangeTransport) {
	    var _this = this;

	    _classCallCheck(this, PDFDataTransportStream);

	    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
	    this._queuedChunks = [];
	    this._progressiveDone = params.progressiveDone || false;
	    this._contentDispositionFilename = params.contentDispositionFilename || null;
	    var initialData = params.initialData;

	    if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
	      var buffer = new Uint8Array(initialData).buffer;

	      this._queuedChunks.push(buffer);
	    }

	    this._pdfDataRangeTransport = pdfDataRangeTransport;
	    this._isStreamingSupported = !params.disableStream;
	    this._isRangeSupported = !params.disableRange;
	    this._contentLength = params.length;
	    this._fullRequestReader = null;
	    this._rangeReaders = [];

	    this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
	      _this._onReceiveData({
	        begin: begin,
	        chunk: chunk
	      });
	    });

	    this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {
	      _this._onProgress({
	        loaded: loaded,
	        total: total
	      });
	    });

	    this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
	      _this._onReceiveData({
	        chunk: chunk
	      });
	    });

	    this._pdfDataRangeTransport.addProgressiveDoneListener(function () {
	      _this._onProgressiveDone();
	    });

	    this._pdfDataRangeTransport.transportReady();
	  }

	  _createClass(PDFDataTransportStream, [{
	    key: "_onReceiveData",
	    value: function _onReceiveData(args) {
	      var buffer = new Uint8Array(args.chunk).buffer;

	      if (args.begin === undefined) {
	        if (this._fullRequestReader) {
	          this._fullRequestReader._enqueue(buffer);
	        } else {
	          this._queuedChunks.push(buffer);
	        }
	      } else {
	        var found = this._rangeReaders.some(function (rangeReader) {
	          if (rangeReader._begin !== args.begin) {
	            return false;
	          }

	          rangeReader._enqueue(buffer);

	          return true;
	        });

	        (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
	      }
	    }
	  }, {
	    key: "_progressiveDataLength",
	    get: function get() {
	      var _this$_fullRequestRea, _this$_fullRequestRea2;

	      return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
	    }
	  }, {
	    key: "_onProgress",
	    value: function _onProgress(evt) {
	      if (evt.total === undefined) {
	        var firstReader = this._rangeReaders[0];

	        if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
	          firstReader.onProgress({
	            loaded: evt.loaded
	          });
	        }
	      } else {
	        var fullReader = this._fullRequestReader;

	        if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
	          fullReader.onProgress({
	            loaded: evt.loaded,
	            total: evt.total
	          });
	        }
	      }
	    }
	  }, {
	    key: "_onProgressiveDone",
	    value: function _onProgressiveDone() {
	      if (this._fullRequestReader) {
	        this._fullRequestReader.progressiveDone();
	      }

	      this._progressiveDone = true;
	    }
	  }, {
	    key: "_removeRangeReader",
	    value: function _removeRangeReader(reader) {
	      var i = this._rangeReaders.indexOf(reader);

	      if (i >= 0) {
	        this._rangeReaders.splice(i, 1);
	      }
	    }
	  }, {
	    key: "getFullReader",
	    value: function getFullReader() {
	      (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
	      var queuedChunks = this._queuedChunks;
	      this._queuedChunks = null;
	      return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
	    }
	  }, {
	    key: "getRangeReader",
	    value: function getRangeReader(begin, end) {
	      if (end <= this._progressiveDataLength) {
	        return null;
	      }

	      var reader = new PDFDataTransportStreamRangeReader(this, begin, end);

	      this._pdfDataRangeTransport.requestDataRange(begin, end);

	      this._rangeReaders.push(reader);

	      return reader;
	    }
	  }, {
	    key: "cancelAllRequests",
	    value: function cancelAllRequests(reason) {
	      if (this._fullRequestReader) {
	        this._fullRequestReader.cancel(reason);
	      }

	      var _iterator = _createForOfIteratorHelper(this._rangeReaders.slice(0)),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var reader = _step.value;
	          reader.cancel(reason);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      this._pdfDataRangeTransport.abort();
	    }
	  }]);

	  return PDFDataTransportStream;
	}();

	exports.PDFDataTransportStream = PDFDataTransportStream;

	var PDFDataTransportStreamReader = /*#__PURE__*/function () {
	  function PDFDataTransportStreamReader(stream, queuedChunks) {
	    var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	    _classCallCheck(this, PDFDataTransportStreamReader);

	    this._stream = stream;
	    this._done = progressiveDone || false;
	    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
	    this._queuedChunks = queuedChunks || [];
	    this._loaded = 0;

	    var _iterator2 = _createForOfIteratorHelper(this._queuedChunks),
	        _step2;

	    try {
	      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	        var chunk = _step2.value;
	        this._loaded += chunk.byteLength;
	      }
	    } catch (err) {
	      _iterator2.e(err);
	    } finally {
	      _iterator2.f();
	    }

	    this._requests = [];
	    this._headersReady = Promise.resolve();
	    stream._fullRequestReader = this;
	    this.onProgress = null;
	  }

	  _createClass(PDFDataTransportStreamReader, [{
	    key: "_enqueue",
	    value: function _enqueue(chunk) {
	      if (this._done) {
	        return;
	      }

	      if (this._requests.length > 0) {
	        var requestCapability = this._requests.shift();

	        requestCapability.resolve({
	          value: chunk,
	          done: false
	        });
	      } else {
	        this._queuedChunks.push(chunk);
	      }

	      this._loaded += chunk.byteLength;
	    }
	  }, {
	    key: "headersReady",
	    get: function get() {
	      return this._headersReady;
	    }
	  }, {
	    key: "filename",
	    get: function get() {
	      return this._filename;
	    }
	  }, {
	    key: "isRangeSupported",
	    get: function get() {
	      return this._stream._isRangeSupported;
	    }
	  }, {
	    key: "isStreamingSupported",
	    get: function get() {
	      return this._stream._isStreamingSupported;
	    }
	  }, {
	    key: "contentLength",
	    get: function get() {
	      return this._stream._contentLength;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
	        var chunk, requestCapability;
	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(this._queuedChunks.length > 0)) {
	                  _context.next = 3;
	                  break;
	                }

	                chunk = this._queuedChunks.shift();
	                return _context.abrupt("return", {
	                  value: chunk,
	                  done: false
	                });

	              case 3:
	                if (!this._done) {
	                  _context.next = 5;
	                  break;
	                }

	                return _context.abrupt("return", {
	                  value: undefined,
	                  done: true
	                });

	              case 5:
	                requestCapability = (0, _util.createPromiseCapability)();

	                this._requests.push(requestCapability);

	                return _context.abrupt("return", requestCapability.promise);

	              case 8:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function read() {
	        return _read.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      this._done = true;

	      var _iterator3 = _createForOfIteratorHelper(this._requests),
	          _step3;

	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var requestCapability = _step3.value;
	          requestCapability.resolve({
	            value: undefined,
	            done: true
	          });
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }

	      this._requests.length = 0;
	    }
	  }, {
	    key: "progressiveDone",
	    value: function progressiveDone() {
	      if (this._done) {
	        return;
	      }

	      this._done = true;
	    }
	  }]);

	  return PDFDataTransportStreamReader;
	}();

	var PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {
	  function PDFDataTransportStreamRangeReader(stream, begin, end) {
	    _classCallCheck(this, PDFDataTransportStreamRangeReader);

	    this._stream = stream;
	    this._begin = begin;
	    this._end = end;
	    this._queuedChunk = null;
	    this._requests = [];
	    this._done = false;
	    this.onProgress = null;
	  }

	  _createClass(PDFDataTransportStreamRangeReader, [{
	    key: "_enqueue",
	    value: function _enqueue(chunk) {
	      if (this._done) {
	        return;
	      }

	      if (this._requests.length === 0) {
	        this._queuedChunk = chunk;
	      } else {
	        var requestsCapability = this._requests.shift();

	        requestsCapability.resolve({
	          value: chunk,
	          done: false
	        });

	        var _iterator4 = _createForOfIteratorHelper(this._requests),
	            _step4;

	        try {
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var requestCapability = _step4.value;
	            requestCapability.resolve({
	              value: undefined,
	              done: true
	            });
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }

	        this._requests.length = 0;
	      }

	      this._done = true;

	      this._stream._removeRangeReader(this);
	    }
	  }, {
	    key: "isStreamingSupported",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
	        var chunk, requestCapability;
	        return _regenerator["default"].wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!this._queuedChunk) {
	                  _context2.next = 4;
	                  break;
	                }

	                chunk = this._queuedChunk;
	                this._queuedChunk = null;
	                return _context2.abrupt("return", {
	                  value: chunk,
	                  done: false
	                });

	              case 4:
	                if (!this._done) {
	                  _context2.next = 6;
	                  break;
	                }

	                return _context2.abrupt("return", {
	                  value: undefined,
	                  done: true
	                });

	              case 6:
	                requestCapability = (0, _util.createPromiseCapability)();

	                this._requests.push(requestCapability);

	                return _context2.abrupt("return", requestCapability.promise);

	              case 9:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function read() {
	        return _read2.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      this._done = true;

	      var _iterator5 = _createForOfIteratorHelper(this._requests),
	          _step5;

	      try {
	        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	          var requestCapability = _step5.value;
	          requestCapability.resolve({
	            value: undefined,
	            done: true
	          });
	        }
	      } catch (err) {
	        _iterator5.e(err);
	      } finally {
	        _iterator5.f();
	      }

	      this._requests.length = 0;

	      this._stream._removeRangeReader(this);
	    }
	  }]);

	  return PDFDataTransportStreamRangeReader;
	}();

	/***/ }),
	/* 147 */
	/***/ ((__unused_webpack_module, exports) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.XfaText = void 0;

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var XfaText = /*#__PURE__*/function () {
	  function XfaText() {
	    _classCallCheck(this, XfaText);
	  }

	  _createClass(XfaText, null, [{
	    key: "textContent",
	    value: function textContent(xfa) {
	      var items = [];
	      var output = {
	        items: items,
	        styles: Object.create(null)
	      };

	      function walk(node) {
	        var _node$attributes;

	        if (!node) {
	          return;
	        }

	        var str = null;
	        var name = node.name;

	        if (name === "#text") {
	          str = node.value;
	        } else if (!XfaText.shouldBuildText(name)) {
	          return;
	        } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
	          str = node.attributes.textContent;
	        } else if (node.value) {
	          str = node.value;
	        }

	        if (str !== null) {
	          items.push({
	            str: str
	          });
	        }

	        if (!node.children) {
	          return;
	        }

	        var _iterator = _createForOfIteratorHelper(node.children),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var child = _step.value;
	            walk(child);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	      }

	      walk(xfa);
	      return output;
	    }
	  }, {
	    key: "shouldBuildText",
	    value: function shouldBuildText(name) {
	      return !(name === "textarea" || name === "input" || name === "option" || name === "select");
	    }
	  }]);

	  return XfaText;
	}();

	exports.XfaText = XfaText;

	/***/ }),
	/* 148 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.AnnotationLayer = void 0;

	var _util = __w_pdfjs_require__(4);

	var _display_utils = __w_pdfjs_require__(1);

	var _annotation_storage = __w_pdfjs_require__(139);

	var _scripting_utils = __w_pdfjs_require__(149);

	var _xfa_layer = __w_pdfjs_require__(150);

	function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

	function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

	function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

	function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var DEFAULT_TAB_INDEX = 1000;
	var GetElementsByNameSet = new WeakSet();

	var AnnotationElementFactory = /*#__PURE__*/function () {
	  function AnnotationElementFactory() {
	    _classCallCheck(this, AnnotationElementFactory);
	  }

	  _createClass(AnnotationElementFactory, null, [{
	    key: "create",
	    value: function create(parameters) {
	      var subtype = parameters.data.annotationType;

	      switch (subtype) {
	        case _util.AnnotationType.LINK:
	          return new LinkAnnotationElement(parameters);

	        case _util.AnnotationType.TEXT:
	          return new TextAnnotationElement(parameters);

	        case _util.AnnotationType.WIDGET:
	          var fieldType = parameters.data.fieldType;

	          switch (fieldType) {
	            case "Tx":
	              return new TextWidgetAnnotationElement(parameters);

	            case "Btn":
	              if (parameters.data.radioButton) {
	                return new RadioButtonWidgetAnnotationElement(parameters);
	              } else if (parameters.data.checkBox) {
	                return new CheckboxWidgetAnnotationElement(parameters);
	              }

	              return new PushButtonWidgetAnnotationElement(parameters);

	            case "Ch":
	              return new ChoiceWidgetAnnotationElement(parameters);
	          }

	          return new WidgetAnnotationElement(parameters);

	        case _util.AnnotationType.POPUP:
	          return new PopupAnnotationElement(parameters);

	        case _util.AnnotationType.FREETEXT:
	          return new FreeTextAnnotationElement(parameters);

	        case _util.AnnotationType.LINE:
	          return new LineAnnotationElement(parameters);

	        case _util.AnnotationType.SQUARE:
	          return new SquareAnnotationElement(parameters);

	        case _util.AnnotationType.CIRCLE:
	          return new CircleAnnotationElement(parameters);

	        case _util.AnnotationType.POLYLINE:
	          return new PolylineAnnotationElement(parameters);

	        case _util.AnnotationType.CARET:
	          return new CaretAnnotationElement(parameters);

	        case _util.AnnotationType.INK:
	          return new InkAnnotationElement(parameters);

	        case _util.AnnotationType.POLYGON:
	          return new PolygonAnnotationElement(parameters);

	        case _util.AnnotationType.HIGHLIGHT:
	          return new HighlightAnnotationElement(parameters);

	        case _util.AnnotationType.UNDERLINE:
	          return new UnderlineAnnotationElement(parameters);

	        case _util.AnnotationType.SQUIGGLY:
	          return new SquigglyAnnotationElement(parameters);

	        case _util.AnnotationType.STRIKEOUT:
	          return new StrikeOutAnnotationElement(parameters);

	        case _util.AnnotationType.STAMP:
	          return new StampAnnotationElement(parameters);

	        case _util.AnnotationType.FILEATTACHMENT:
	          return new FileAttachmentAnnotationElement(parameters);

	        default:
	          return new AnnotationElement(parameters);
	      }
	    }
	  }]);

	  return AnnotationElementFactory;
	}();

	var AnnotationElement = /*#__PURE__*/function () {
	  function AnnotationElement(parameters) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref$isRenderable = _ref.isRenderable,
	        isRenderable = _ref$isRenderable === void 0 ? false : _ref$isRenderable,
	        _ref$ignoreBorder = _ref.ignoreBorder,
	        ignoreBorder = _ref$ignoreBorder === void 0 ? false : _ref$ignoreBorder,
	        _ref$createQuadrilate = _ref.createQuadrilaterals,
	        createQuadrilaterals = _ref$createQuadrilate === void 0 ? false : _ref$createQuadrilate;

	    _classCallCheck(this, AnnotationElement);

	    this.isRenderable = isRenderable;
	    this.data = parameters.data;
	    this.layer = parameters.layer;
	    this.page = parameters.page;
	    this.viewport = parameters.viewport;
	    this.linkService = parameters.linkService;
	    this.downloadManager = parameters.downloadManager;
	    this.imageResourcesPath = parameters.imageResourcesPath;
	    this.renderForms = parameters.renderForms;
	    this.svgFactory = parameters.svgFactory;
	    this.annotationStorage = parameters.annotationStorage;
	    this.enableScripting = parameters.enableScripting;
	    this.hasJSActions = parameters.hasJSActions;
	    this._fieldObjects = parameters.fieldObjects;
	    this._mouseState = parameters.mouseState;

	    if (isRenderable) {
	      this.container = this._createContainer(ignoreBorder);
	    }

	    if (createQuadrilaterals) {
	      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
	    }
	  }

	  _createClass(AnnotationElement, [{
	    key: "_createContainer",
	    value: function _createContainer() {
	      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      var data = this.data,
	          page = this.page,
	          viewport = this.viewport;
	      var container = document.createElement("section");
	      var width = data.rect[2] - data.rect[0];
	      var height = data.rect[3] - data.rect[1];
	      container.setAttribute("data-annotation-id", data.id);

	      var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

	      if (data.hasOwnCanvas) {
	        var transform = viewport.transform.slice();

	        var _Util$singularValueDe = _util.Util.singularValueDecompose2dScale(transform),
	            _Util$singularValueDe2 = _slicedToArray(_Util$singularValueDe, 2),
	            scaleX = _Util$singularValueDe2[0],
	            scaleY = _Util$singularValueDe2[1];

	        width = Math.ceil(width * scaleX);
	        height = Math.ceil(height * scaleY);
	        rect[0] *= scaleX;
	        rect[1] *= scaleY;

	        for (var i = 0; i < 4; i++) {
	          transform[i] = Math.sign(transform[i]);
	        }

	        container.style.transform = "matrix(".concat(transform.join(","), ")");
	      } else {
	        container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
	      }

	      container.style.transformOrigin = "".concat(-rect[0], "px ").concat(-rect[1], "px");

	      if (!ignoreBorder && data.borderStyle.width > 0) {
	        container.style.borderWidth = "".concat(data.borderStyle.width, "px");

	        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
	          width -= 2 * data.borderStyle.width;
	          height -= 2 * data.borderStyle.width;
	        }

	        var horizontalRadius = data.borderStyle.horizontalCornerRadius;
	        var verticalRadius = data.borderStyle.verticalCornerRadius;

	        if (horizontalRadius > 0 || verticalRadius > 0) {
	          var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
	          container.style.borderRadius = radius;
	        }

	        switch (data.borderStyle.style) {
	          case _util.AnnotationBorderStyleType.SOLID:
	            container.style.borderStyle = "solid";
	            break;

	          case _util.AnnotationBorderStyleType.DASHED:
	            container.style.borderStyle = "dashed";
	            break;

	          case _util.AnnotationBorderStyleType.BEVELED:
	            (0, _util.warn)("Unimplemented border style: beveled");
	            break;

	          case _util.AnnotationBorderStyleType.INSET:
	            (0, _util.warn)("Unimplemented border style: inset");
	            break;

	          case _util.AnnotationBorderStyleType.UNDERLINE:
	            container.style.borderBottomStyle = "solid";
	            break;
	        }

	        var borderColor = data.borderColor || data.color || null;

	        if (borderColor) {
	          container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
	        } else {
	          container.style.borderWidth = 0;
	        }
	      }

	      container.style.left = "".concat(rect[0], "px");
	      container.style.top = "".concat(rect[1], "px");

	      if (data.hasOwnCanvas) {
	        container.style.width = container.style.height = "auto";
	      } else {
	        container.style.width = "".concat(width, "px");
	        container.style.height = "".concat(height, "px");
	      }

	      return container;
	    }
	  }, {
	    key: "_createQuadrilaterals",
	    value: function _createQuadrilaterals() {
	      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (!this.data.quadPoints) {
	        return null;
	      }

	      var quadrilaterals = [];
	      var savedRect = this.data.rect;

	      var _iterator = _createForOfIteratorHelper(this.data.quadPoints),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var quadPoint = _step.value;
	          this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
	          quadrilaterals.push(this._createContainer(ignoreBorder));
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      this.data.rect = savedRect;
	      return quadrilaterals;
	    }
	  }, {
	    key: "_createPopup",
	    value: function _createPopup(trigger, data) {
	      var container = this.container;

	      if (this.quadrilaterals) {
	        trigger = trigger || this.quadrilaterals;
	        container = this.quadrilaterals[0];
	      }

	      if (!trigger) {
	        trigger = document.createElement("div");
	        trigger.style.height = container.style.height;
	        trigger.style.width = container.style.width;
	        container.appendChild(trigger);
	      }

	      var popupElement = new PopupElement({
	        container: container,
	        trigger: trigger,
	        color: data.color,
	        titleObj: data.titleObj,
	        modificationDate: data.modificationDate,
	        contentsObj: data.contentsObj,
	        richText: data.richText,
	        hideWrapper: true
	      });
	      var popup = popupElement.render();
	      popup.style.left = container.style.width;
	      container.appendChild(popup);
	    }
	  }, {
	    key: "_renderQuadrilaterals",
	    value: function _renderQuadrilaterals(className) {
	      var _iterator2 = _createForOfIteratorHelper(this.quadrilaterals),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var quadrilateral = _step2.value;
	          quadrilateral.className = className;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      return this.quadrilaterals;
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
	    }
	  }, {
	    key: "_getElementsByName",
	    value: function _getElementsByName(name) {
	      var skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var fields = [];

	      if (this._fieldObjects) {
	        var fieldObj = this._fieldObjects[name];

	        if (fieldObj) {
	          var _iterator3 = _createForOfIteratorHelper(fieldObj),
	              _step3;

	          try {
	            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	              var _step3$value = _step3.value,
	                  page = _step3$value.page,
	                  id = _step3$value.id,
	                  exportValues = _step3$value.exportValues;

	              if (page === -1) {
	                continue;
	              }

	              if (id === skipId) {
	                continue;
	              }

	              var exportValue = typeof exportValues === "string" ? exportValues : null;
	              var domElement = document.getElementById(id);

	              if (domElement && !GetElementsByNameSet.has(domElement)) {
	                (0, _util.warn)("_getElementsByName - element not allowed: ".concat(id));
	                continue;
	              }

	              fields.push({
	                id: id,
	                exportValue: exportValue,
	                domElement: domElement
	              });
	            }
	          } catch (err) {
	            _iterator3.e(err);
	          } finally {
	            _iterator3.f();
	          }
	        }

	        return fields;
	      }

	      var _iterator4 = _createForOfIteratorHelper(document.getElementsByName(name)),
	          _step4;

	      try {
	        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	          var _domElement = _step4.value;
	          var _id = _domElement.id,
	              _exportValue = _domElement.exportValue;

	          if (_id === skipId) {
	            continue;
	          }

	          if (!GetElementsByNameSet.has(_domElement)) {
	            continue;
	          }

	          fields.push({
	            id: _id,
	            exportValue: _exportValue,
	            domElement: _domElement
	          });
	        }
	      } catch (err) {
	        _iterator4.e(err);
	      } finally {
	        _iterator4.f();
	      }

	      return fields;
	    }
	  }], [{
	    key: "platform",
	    get: function get() {
	      var platform = typeof navigator !== "undefined" ? navigator.platform : "";
	      return (0, _util.shadow)(this, "platform", {
	        isWin: platform.includes("Win"),
	        isMac: platform.includes("Mac")
	      });
	    }
	  }]);

	  return AnnotationElement;
	}();

	var LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {
	  _inherits(LinkAnnotationElement, _AnnotationElement);

	  var _super = _createSuper(LinkAnnotationElement);

	  function LinkAnnotationElement(parameters) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, LinkAnnotationElement);

	    var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
	    return _super.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
	      createQuadrilaterals: true
	    });
	  }

	  _createClass(LinkAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var data = this.data,
	          linkService = this.linkService;
	      var link = document.createElement("a");

	      if (data.url) {
	        var _linkService$addLinkA;

	        if (!linkService.addLinkAttributes) {
	          (0, _util.warn)("LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.");
	        }

	        (_linkService$addLinkA = linkService.addLinkAttributes) === null || _linkService$addLinkA === void 0 ? void 0 : _linkService$addLinkA.call(linkService, link, data.url, data.newWindow);
	      } else if (data.action) {
	        this._bindNamedAction(link, data.action);
	      } else if (data.dest) {
	        this._bindLink(link, data.dest);
	      } else {
	        var hasClickAction = false;

	        if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
	          hasClickAction = true;

	          this._bindJSAction(link, data);
	        }

	        if (data.resetForm) {
	          this._bindResetFormAction(link, data.resetForm);
	        } else if (!hasClickAction) {
	          this._bindLink(link, "");
	        }
	      }

	      if (this.quadrilaterals) {
	        return this._renderQuadrilaterals("linkAnnotation").map(function (quadrilateral, index) {
	          var linkElement = index === 0 ? link : link.cloneNode();
	          quadrilateral.appendChild(linkElement);
	          return quadrilateral;
	        });
	      }

	      this.container.className = "linkAnnotation";
	      this.container.appendChild(link);
	      return this.container;
	    }
	  }, {
	    key: "_bindLink",
	    value: function _bindLink(link, destination) {
	      var _this = this;

	      link.href = this.linkService.getDestinationHash(destination);

	      link.onclick = function () {
	        if (destination) {
	          _this.linkService.goToDestination(destination);
	        }

	        return false;
	      };

	      if (destination || destination === "") {
	        link.className = "internalLink";
	      }
	    }
	  }, {
	    key: "_bindNamedAction",
	    value: function _bindNamedAction(link, action) {
	      var _this2 = this;

	      link.href = this.linkService.getAnchorUrl("");

	      link.onclick = function () {
	        _this2.linkService.executeNamedAction(action);

	        return false;
	      };

	      link.className = "internalLink";
	    }
	  }, {
	    key: "_bindJSAction",
	    value: function _bindJSAction(link, data) {
	      var _this3 = this;

	      link.href = this.linkService.getAnchorUrl("");
	      var map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

	      var _loop = function _loop() {
	        var name = _Object$keys[_i2];
	        var jsName = map.get(name);

	        if (!jsName) {
	          return "continue";
	        }

	        link[jsName] = function () {
	          var _this3$linkService$ev;

	          (_this3$linkService$ev = _this3.linkService.eventBus) === null || _this3$linkService$ev === void 0 ? void 0 : _this3$linkService$ev.dispatch("dispatcheventinsandbox", {
	            source: _this3,
	            detail: {
	              id: data.id,
	              name: name
	            }
	          });
	          return false;
	        };
	      };

	      for (var _i2 = 0, _Object$keys = Object.keys(data.actions); _i2 < _Object$keys.length; _i2++) {
	        var _ret = _loop();

	        if (_ret === "continue") continue;
	      }

	      if (!link.onclick) {
	        link.onclick = function () {
	          return false;
	        };
	      }

	      link.className = "internalLink";
	    }
	  }, {
	    key: "_bindResetFormAction",
	    value: function _bindResetFormAction(link, resetForm) {
	      var _this4 = this;

	      var otherClickAction = link.onclick;

	      if (!otherClickAction) {
	        link.href = this.linkService.getAnchorUrl("");
	      }

	      link.className = "internalLink";

	      if (!this._fieldObjects) {
	        (0, _util.warn)("_bindResetFormAction - \"resetForm\" action not supported, " + "ensure that the `fieldObjects` parameter is provided.");

	        if (!otherClickAction) {
	          link.onclick = function () {
	            return false;
	          };
	        }

	        return;
	      }

	      link.onclick = function () {
	        if (otherClickAction) {
	          otherClickAction();
	        }

	        var resetFormFields = resetForm.fields,
	            resetFormRefs = resetForm.refs,
	            include = resetForm.include;
	        var allFields = [];

	        if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
	          var fieldIds = new Set(resetFormRefs);

	          var _iterator5 = _createForOfIteratorHelper(resetFormFields),
	              _step5;

	          try {
	            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	              var fieldName = _step5.value;

	              var _fields = _this4._fieldObjects[fieldName] || [];

	              var _iterator7 = _createForOfIteratorHelper(_fields),
	                  _step7;

	              try {
	                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	                  var id = _step7.value.id;
	                  fieldIds.add(id);
	                }
	              } catch (err) {
	                _iterator7.e(err);
	              } finally {
	                _iterator7.f();
	              }
	            }
	          } catch (err) {
	            _iterator5.e(err);
	          } finally {
	            _iterator5.f();
	          }

	          for (var _i3 = 0, _Object$values = Object.values(_this4._fieldObjects); _i3 < _Object$values.length; _i3++) {
	            var fields = _Object$values[_i3];

	            var _iterator6 = _createForOfIteratorHelper(fields),
	                _step6;

	            try {
	              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	                var field = _step6.value;

	                if (fieldIds.has(field.id) === include) {
	                  allFields.push(field);
	                }
	              }
	            } catch (err) {
	              _iterator6.e(err);
	            } finally {
	              _iterator6.f();
	            }
	          }
	        } else {
	          for (var _i4 = 0, _Object$values2 = Object.values(_this4._fieldObjects); _i4 < _Object$values2.length; _i4++) {
	            var _fields2 = _Object$values2[_i4];
	            allFields.push.apply(allFields, _toConsumableArray(_fields2));
	          }
	        }

	        var storage = _this4.annotationStorage;
	        var allIds = [];

	        for (var _i5 = 0, _allFields = allFields; _i5 < _allFields.length; _i5++) {
	          var _field = _allFields[_i5];
	          var _id2 = _field.id;
	          allIds.push(_id2);

	          switch (_field.type) {
	            case "text":
	              {
	                var value = _field.defaultValue || "";
	                storage.setValue(_id2, {
	                  value: value,
	                  valueAsString: value
	                });
	                break;
	              }

	            case "checkbox":
	            case "radiobutton":
	              {
	                var _value = _field.defaultValue === _field.exportValues;

	                storage.setValue(_id2, {
	                  value: _value
	                });
	                break;
	              }

	            case "combobox":
	            case "listbox":
	              {
	                var _value2 = _field.defaultValue || "";

	                storage.setValue(_id2, {
	                  value: _value2
	                });
	                break;
	              }

	            default:
	              continue;
	          }

	          var domElement = document.getElementById(_id2);

	          if (!domElement || !GetElementsByNameSet.has(domElement)) {
	            continue;
	          }

	          domElement.dispatchEvent(new Event("resetform"));
	        }

	        if (_this4.enableScripting) {
	          var _this4$linkService$ev;

	          (_this4$linkService$ev = _this4.linkService.eventBus) === null || _this4$linkService$ev === void 0 ? void 0 : _this4$linkService$ev.dispatch("dispatcheventinsandbox", {
	            source: _this4,
	            detail: {
	              id: "app",
	              ids: allIds,
	              name: "ResetForm"
	            }
	          });
	        }

	        return false;
	      };
	    }
	  }]);

	  return LinkAnnotationElement;
	}(AnnotationElement);

	var TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {
	  _inherits(TextAnnotationElement, _AnnotationElement2);

	  var _super2 = _createSuper(TextAnnotationElement);

	  function TextAnnotationElement(parameters) {
	    var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;

	    _classCallCheck(this, TextAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);
	    return _super2.call(this, parameters, {
	      isRenderable: isRenderable
	    });
	  }

	  _createClass(TextAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "textAnnotation";
	      var image = document.createElement("img");
	      image.style.height = this.container.style.height;
	      image.style.width = this.container.style.width;
	      image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
	      image.alt = "[{{type}} Annotation]";
	      image.dataset.l10nId = "text_annotation_type";
	      image.dataset.l10nArgs = JSON.stringify({
	        type: this.data.name
	      });

	      if (!this.data.hasPopup) {
	        this._createPopup(image, this.data);
	      }

	      this.container.appendChild(image);
	      return this.container;
	    }
	  }]);

	  return TextAnnotationElement;
	}(AnnotationElement);

	var WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {
	  _inherits(WidgetAnnotationElement, _AnnotationElement3);

	  var _super3 = _createSuper(WidgetAnnotationElement);

	  function WidgetAnnotationElement() {
	    _classCallCheck(this, WidgetAnnotationElement);

	    return _super3.apply(this, arguments);
	  }

	  _createClass(WidgetAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      if (this.data.alternativeText) {
	        this.container.title = this.data.alternativeText;
	      }

	      return this.container;
	    }
	  }, {
	    key: "_getKeyModifier",
	    value: function _getKeyModifier(event) {
	      var _AnnotationElement$pl = AnnotationElement.platform,
	          isWin = _AnnotationElement$pl.isWin,
	          isMac = _AnnotationElement$pl.isMac;
	      return isWin && event.ctrlKey || isMac && event.metaKey;
	    }
	  }, {
	    key: "_setEventListener",
	    value: function _setEventListener(element, baseName, eventName, valueGetter) {
	      var _this5 = this;

	      if (baseName.includes("mouse")) {
	        element.addEventListener(baseName, function (event) {
	          var _this5$linkService$ev;

	          (_this5$linkService$ev = _this5.linkService.eventBus) === null || _this5$linkService$ev === void 0 ? void 0 : _this5$linkService$ev.dispatch("dispatcheventinsandbox", {
	            source: _this5,
	            detail: {
	              id: _this5.data.id,
	              name: eventName,
	              value: valueGetter(event),
	              shift: event.shiftKey,
	              modifier: _this5._getKeyModifier(event)
	            }
	          });
	        });
	      } else {
	        element.addEventListener(baseName, function (event) {
	          var _this5$linkService$ev2;

	          (_this5$linkService$ev2 = _this5.linkService.eventBus) === null || _this5$linkService$ev2 === void 0 ? void 0 : _this5$linkService$ev2.dispatch("dispatcheventinsandbox", {
	            source: _this5,
	            detail: {
	              id: _this5.data.id,
	              name: eventName,
	              value: event.target.checked
	            }
	          });
	        });
	      }
	    }
	  }, {
	    key: "_setEventListeners",
	    value: function _setEventListeners(element, names, getter) {
	      var _iterator8 = _createForOfIteratorHelper(names),
	          _step8;

	      try {
	        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
	          var _this$data$actions;

	          var _step8$value = _slicedToArray(_step8.value, 2),
	              baseName = _step8$value[0],
	              eventName = _step8$value[1];

	          if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
	            this._setEventListener(element, baseName, eventName, getter);
	          }
	        }
	      } catch (err) {
	        _iterator8.e(err);
	      } finally {
	        _iterator8.f();
	      }
	    }
	  }, {
	    key: "_setBackgroundColor",
	    value: function _setBackgroundColor(element) {
	      var color = this.data.backgroundColor || null;
	      element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
	    }
	  }, {
	    key: "_dispatchEventFromSandbox",
	    value: function _dispatchEventFromSandbox(actions, jsEvent) {
	      var _this6 = this;

	      var setColor = function setColor(jsName, styleName, event) {
	        var color = event.detail[jsName];
	        event.target.style[styleName] = _scripting_utils.ColorConverters["".concat(color[0], "_HTML")](color.slice(1));
	      };

	      var commonActions = {
	        display: function display(event) {
	          var hidden = event.detail.display % 2 === 1;
	          event.target.style.visibility = hidden ? "hidden" : "visible";

	          _this6.annotationStorage.setValue(_this6.data.id, {
	            hidden: hidden,
	            print: event.detail.display === 0 || event.detail.display === 3
	          });
	        },
	        print: function print(event) {
	          _this6.annotationStorage.setValue(_this6.data.id, {
	            print: event.detail.print
	          });
	        },
	        hidden: function hidden(event) {
	          event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";

	          _this6.annotationStorage.setValue(_this6.data.id, {
	            hidden: event.detail.hidden
	          });
	        },
	        focus: function focus(event) {
	          setTimeout(function () {
	            return event.target.focus({
	              preventScroll: false
	            });
	          }, 0);
	        },
	        userName: function userName(event) {
	          event.target.title = event.detail.userName;
	        },
	        readonly: function readonly(event) {
	          if (event.detail.readonly) {
	            event.target.setAttribute("readonly", "");
	          } else {
	            event.target.removeAttribute("readonly");
	          }
	        },
	        required: function required(event) {
	          if (event.detail.required) {
	            event.target.setAttribute("required", "");
	          } else {
	            event.target.removeAttribute("required");
	          }
	        },
	        bgColor: function bgColor(event) {
	          setColor("bgColor", "backgroundColor", event);
	        },
	        fillColor: function fillColor(event) {
	          setColor("fillColor", "backgroundColor", event);
	        },
	        fgColor: function fgColor(event) {
	          setColor("fgColor", "color", event);
	        },
	        textColor: function textColor(event) {
	          setColor("textColor", "color", event);
	        },
	        borderColor: function borderColor(event) {
	          setColor("borderColor", "borderColor", event);
	        },
	        strokeColor: function strokeColor(event) {
	          setColor("strokeColor", "borderColor", event);
	        }
	      };

	      for (var _i6 = 0, _Object$keys2 = Object.keys(jsEvent.detail); _i6 < _Object$keys2.length; _i6++) {
	        var name = _Object$keys2[_i6];
	        var action = actions[name] || commonActions[name];

	        if (action) {
	          action(jsEvent);
	        }
	      }
	    }
	  }]);

	  return WidgetAnnotationElement;
	}(AnnotationElement);

	var TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {
	  _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);

	  var _super4 = _createSuper(TextWidgetAnnotationElement);

	  function TextWidgetAnnotationElement(parameters) {
	    _classCallCheck(this, TextWidgetAnnotationElement);

	    var isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
	    return _super4.call(this, parameters, {
	      isRenderable: isRenderable
	    });
	  }

	  _createClass(TextWidgetAnnotationElement, [{
	    key: "setPropertyOnSiblings",
	    value: function setPropertyOnSiblings(base, key, value, keyInStorage) {
	      var storage = this.annotationStorage;

	      var _iterator9 = _createForOfIteratorHelper(this._getElementsByName(base.name, base.id)),
	          _step9;

	      try {
	        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
	          var element = _step9.value;

	          if (element.domElement) {
	            element.domElement[key] = value;
	          }

	          storage.setValue(element.id, _defineProperty({}, keyInStorage, value));
	        }
	      } catch (err) {
	        _iterator9.e(err);
	      } finally {
	        _iterator9.f();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this7 = this;

	      var storage = this.annotationStorage;
	      var id = this.data.id;
	      this.container.className = "textWidgetAnnotation";
	      var element = null;

	      if (this.renderForms) {
	        var storedData = storage.getValue(id, {
	          value: this.data.fieldValue,
	          valueAsString: this.data.fieldValue
	        });
	        var textContent = storedData.valueAsString || storedData.value || "";
	        var elementData = {
	          userValue: null,
	          formattedValue: null,
	          beforeInputSelectionRange: null,
	          beforeInputValue: null
	        };

	        if (this.data.multiLine) {
	          element = document.createElement("textarea");
	          element.textContent = textContent;
	        } else {
	          element = document.createElement("input");
	          element.type = "text";
	          element.setAttribute("value", textContent);
	        }

	        GetElementsByNameSet.add(element);
	        element.disabled = this.data.readOnly;
	        element.name = this.data.fieldName;
	        element.tabIndex = DEFAULT_TAB_INDEX;
	        elementData.userValue = textContent;
	        element.setAttribute("id", id);
	        element.addEventListener("input", function (event) {
	          storage.setValue(id, {
	            value: event.target.value
	          });

	          _this7.setPropertyOnSiblings(element, "value", event.target.value, "value");
	        });
	        element.addEventListener("resetform", function (event) {
	          var defaultValue = _this7.data.defaultFieldValue || "";
	          element.value = elementData.userValue = defaultValue;
	          delete elementData.formattedValue;
	        });

	        var blurListener = function blurListener(event) {
	          if (elementData.formattedValue) {
	            event.target.value = elementData.formattedValue;
	          }

	          event.target.scrollLeft = 0;
	          elementData.beforeInputSelectionRange = null;
	        };

	        if (this.enableScripting && this.hasJSActions) {
	          var _this$data$actions2;

	          element.addEventListener("focus", function (event) {
	            if (elementData.userValue) {
	              event.target.value = elementData.userValue;
	            }
	          });
	          element.addEventListener("updatefromsandbox", function (jsEvent) {
	            var actions = {
	              value: function value(event) {
	                elementData.userValue = event.detail.value || "";
	                storage.setValue(id, {
	                  value: elementData.userValue.toString()
	                });

	                if (!elementData.formattedValue) {
	                  event.target.value = elementData.userValue;
	                }
	              },
	              valueAsString: function valueAsString(event) {
	                elementData.formattedValue = event.detail.valueAsString || "";

	                if (event.target !== document.activeElement) {
	                  event.target.value = elementData.formattedValue;
	                }

	                storage.setValue(id, {
	                  formattedValue: elementData.formattedValue
	                });
	              },
	              selRange: function selRange(event) {
	                var _event$detail$selRang = _slicedToArray(event.detail.selRange, 2),
	                    selStart = _event$detail$selRang[0],
	                    selEnd = _event$detail$selRang[1];

	                if (selStart >= 0 && selEnd < event.target.value.length) {
	                  event.target.setSelectionRange(selStart, selEnd);
	                }
	              }
	            };

	            _this7._dispatchEventFromSandbox(actions, jsEvent);
	          });
	          element.addEventListener("keydown", function (event) {
	            var _this7$linkService$ev;

	            elementData.beforeInputValue = event.target.value;
	            var commitKey = -1;

	            if (event.key === "Escape") {
	              commitKey = 0;
	            } else if (event.key === "Enter") {
	              commitKey = 2;
	            } else if (event.key === "Tab") {
	              commitKey = 3;
	            }

	            if (commitKey === -1) {
	              return;
	            }

	            elementData.userValue = event.target.value;
	            (_this7$linkService$ev = _this7.linkService.eventBus) === null || _this7$linkService$ev === void 0 ? void 0 : _this7$linkService$ev.dispatch("dispatcheventinsandbox", {
	              source: _this7,
	              detail: {
	                id: id,
	                name: "Keystroke",
	                value: event.target.value,
	                willCommit: true,
	                commitKey: commitKey,
	                selStart: event.target.selectionStart,
	                selEnd: event.target.selectionEnd
	              }
	            });
	          });
	          var _blurListener = blurListener;
	          blurListener = null;
	          element.addEventListener("blur", function (event) {
	            if (_this7._mouseState.isDown) {
	              var _this7$linkService$ev2;

	              elementData.userValue = event.target.value;
	              (_this7$linkService$ev2 = _this7.linkService.eventBus) === null || _this7$linkService$ev2 === void 0 ? void 0 : _this7$linkService$ev2.dispatch("dispatcheventinsandbox", {
	                source: _this7,
	                detail: {
	                  id: id,
	                  name: "Keystroke",
	                  value: event.target.value,
	                  willCommit: true,
	                  commitKey: 1,
	                  selStart: event.target.selectionStart,
	                  selEnd: event.target.selectionEnd
	                }
	              });
	            }

	            _blurListener(event);
	          });
	          element.addEventListener("mousedown", function (event) {
	            elementData.beforeInputValue = event.target.value;
	            elementData.beforeInputSelectionRange = null;
	          });
	          element.addEventListener("keyup", function (event) {
	            if (event.target.selectionStart === event.target.selectionEnd) {
	              elementData.beforeInputSelectionRange = null;
	            }
	          });
	          element.addEventListener("select", function (event) {
	            elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
	          });

	          if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
	            element.addEventListener("input", function (event) {
	              var _this7$linkService$ev3;

	              var selStart = -1;
	              var selEnd = -1;

	              if (elementData.beforeInputSelectionRange) {
	                var _elementData$beforeIn = _slicedToArray(elementData.beforeInputSelectionRange, 2);

	                selStart = _elementData$beforeIn[0];
	                selEnd = _elementData$beforeIn[1];
	              }

	              (_this7$linkService$ev3 = _this7.linkService.eventBus) === null || _this7$linkService$ev3 === void 0 ? void 0 : _this7$linkService$ev3.dispatch("dispatcheventinsandbox", {
	                source: _this7,
	                detail: {
	                  id: id,
	                  name: "Keystroke",
	                  value: elementData.beforeInputValue,
	                  change: event.data,
	                  willCommit: false,
	                  selStart: selStart,
	                  selEnd: selEnd
	                }
	              });
	            });
	          }

	          this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
	            return event.target.value;
	          });
	        }

	        if (blurListener) {
	          element.addEventListener("blur", blurListener);
	        }

	        if (this.data.maxLen !== null) {
	          element.maxLength = this.data.maxLen;
	        }

	        if (this.data.comb) {
	          var fieldWidth = this.data.rect[2] - this.data.rect[0];
	          var combWidth = fieldWidth / this.data.maxLen;
	          element.classList.add("comb");
	          element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
	        }
	      } else {
	        element = document.createElement("div");
	        element.textContent = this.data.fieldValue;
	        element.style.verticalAlign = "middle";
	        element.style.display = "table-cell";
	      }

	      this._setTextStyle(element);

	      this._setBackgroundColor(element);

	      this.container.appendChild(element);
	      return this.container;
	    }
	  }, {
	    key: "_setTextStyle",
	    value: function _setTextStyle(element) {
	      var TEXT_ALIGNMENT = ["left", "center", "right"];
	      var _this$data$defaultApp = this.data.defaultAppearanceData,
	          fontSize = _this$data$defaultApp.fontSize,
	          fontColor = _this$data$defaultApp.fontColor;
	      var style = element.style;

	      if (fontSize) {
	        style.fontSize = "".concat(fontSize, "px");
	      }

	      style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

	      if (this.data.textAlignment !== null) {
	        style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
	      }
	    }
	  }]);

	  return TextWidgetAnnotationElement;
	}(WidgetAnnotationElement);

	var CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {
	  _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);

	  var _super5 = _createSuper(CheckboxWidgetAnnotationElement);

	  function CheckboxWidgetAnnotationElement(parameters) {
	    _classCallCheck(this, CheckboxWidgetAnnotationElement);

	    return _super5.call(this, parameters, {
	      isRenderable: parameters.renderForms
	    });
	  }

	  _createClass(CheckboxWidgetAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var _this8 = this;

	      var storage = this.annotationStorage;
	      var data = this.data;
	      var id = data.id;
	      var value = storage.getValue(id, {
	        value: data.exportValue === data.fieldValue
	      }).value;

	      if (typeof value === "string") {
	        value = value !== "Off";
	        storage.setValue(id, {
	          value: value
	        });
	      }

	      this.container.className = "buttonWidgetAnnotation checkBox";
	      var element = document.createElement("input");
	      GetElementsByNameSet.add(element);
	      element.disabled = data.readOnly;
	      element.type = "checkbox";
	      element.name = data.fieldName;

	      if (value) {
	        element.setAttribute("checked", true);
	      }

	      element.setAttribute("id", id);
	      element.setAttribute("exportValue", data.exportValue);
	      element.tabIndex = DEFAULT_TAB_INDEX;
	      element.addEventListener("change", function (event) {
	        var _event$target = event.target,
	            name = _event$target.name,
	            checked = _event$target.checked;

	        var _iterator10 = _createForOfIteratorHelper(_this8._getElementsByName(name, id)),
	            _step10;

	        try {
	          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
	            var checkbox = _step10.value;
	            var curChecked = checked && checkbox.exportValue === data.exportValue;

	            if (checkbox.domElement) {
	              checkbox.domElement.checked = curChecked;
	            }

	            storage.setValue(checkbox.id, {
	              value: curChecked
	            });
	          }
	        } catch (err) {
	          _iterator10.e(err);
	        } finally {
	          _iterator10.f();
	        }

	        storage.setValue(id, {
	          value: checked
	        });
	      });
	      element.addEventListener("resetform", function (event) {
	        var defaultValue = data.defaultFieldValue || "Off";
	        event.target.checked = defaultValue === data.exportValue;
	      });

	      if (this.enableScripting && this.hasJSActions) {
	        element.addEventListener("updatefromsandbox", function (jsEvent) {
	          var actions = {
	            value: function value(event) {
	              event.target.checked = event.detail.value !== "Off";
	              storage.setValue(id, {
	                value: event.target.checked
	              });
	            }
	          };

	          _this8._dispatchEventFromSandbox(actions, jsEvent);
	        });

	        this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
	          return event.target.checked;
	        });
	      }

	      this._setBackgroundColor(element);

	      this.container.appendChild(element);
	      return this.container;
	    }
	  }]);

	  return CheckboxWidgetAnnotationElement;
	}(WidgetAnnotationElement);

	var RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {
	  _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);

	  var _super6 = _createSuper(RadioButtonWidgetAnnotationElement);

	  function RadioButtonWidgetAnnotationElement(parameters) {
	    _classCallCheck(this, RadioButtonWidgetAnnotationElement);

	    return _super6.call(this, parameters, {
	      isRenderable: parameters.renderForms
	    });
	  }

	  _createClass(RadioButtonWidgetAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var _this9 = this;

	      this.container.className = "buttonWidgetAnnotation radioButton";
	      var storage = this.annotationStorage;
	      var data = this.data;
	      var id = data.id;
	      var value = storage.getValue(id, {
	        value: data.fieldValue === data.buttonValue
	      }).value;

	      if (typeof value === "string") {
	        value = value !== data.buttonValue;
	        storage.setValue(id, {
	          value: value
	        });
	      }

	      var element = document.createElement("input");
	      GetElementsByNameSet.add(element);
	      element.disabled = data.readOnly;
	      element.type = "radio";
	      element.name = data.fieldName;

	      if (value) {
	        element.setAttribute("checked", true);
	      }

	      element.setAttribute("id", id);
	      element.tabIndex = DEFAULT_TAB_INDEX;
	      element.addEventListener("change", function (event) {
	        var _event$target2 = event.target,
	            name = _event$target2.name,
	            checked = _event$target2.checked;

	        var _iterator11 = _createForOfIteratorHelper(_this9._getElementsByName(name, id)),
	            _step11;

	        try {
	          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
	            var radio = _step11.value;
	            storage.setValue(radio.id, {
	              value: false
	            });
	          }
	        } catch (err) {
	          _iterator11.e(err);
	        } finally {
	          _iterator11.f();
	        }

	        storage.setValue(id, {
	          value: checked
	        });
	      });
	      element.addEventListener("resetform", function (event) {
	        var defaultValue = data.defaultFieldValue;
	        event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
	      });

	      if (this.enableScripting && this.hasJSActions) {
	        var pdfButtonValue = data.buttonValue;
	        element.addEventListener("updatefromsandbox", function (jsEvent) {
	          var actions = {
	            value: function value(event) {
	              var checked = pdfButtonValue === event.detail.value;

	              var _iterator12 = _createForOfIteratorHelper(_this9._getElementsByName(event.target.name)),
	                  _step12;

	              try {
	                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
	                  var radio = _step12.value;
	                  var curChecked = checked && radio.id === id;

	                  if (radio.domElement) {
	                    radio.domElement.checked = curChecked;
	                  }

	                  storage.setValue(radio.id, {
	                    value: curChecked
	                  });
	                }
	              } catch (err) {
	                _iterator12.e(err);
	              } finally {
	                _iterator12.f();
	              }
	            }
	          };

	          _this9._dispatchEventFromSandbox(actions, jsEvent);
	        });

	        this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
	          return event.target.checked;
	        });
	      }

	      this._setBackgroundColor(element);

	      this.container.appendChild(element);
	      return this.container;
	    }
	  }]);

	  return RadioButtonWidgetAnnotationElement;
	}(WidgetAnnotationElement);

	var PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {
	  _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);

	  var _super7 = _createSuper(PushButtonWidgetAnnotationElement);

	  function PushButtonWidgetAnnotationElement(parameters) {
	    _classCallCheck(this, PushButtonWidgetAnnotationElement);

	    return _super7.call(this, parameters, {
	      ignoreBorder: parameters.data.hasAppearance
	    });
	  }

	  _createClass(PushButtonWidgetAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), "render", this).call(this);

	      container.className = "buttonWidgetAnnotation pushButton";

	      if (this.data.alternativeText) {
	        container.title = this.data.alternativeText;
	      }

	      return container;
	    }
	  }]);

	  return PushButtonWidgetAnnotationElement;
	}(LinkAnnotationElement);

	var ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {
	  _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);

	  var _super8 = _createSuper(ChoiceWidgetAnnotationElement);

	  function ChoiceWidgetAnnotationElement(parameters) {
	    _classCallCheck(this, ChoiceWidgetAnnotationElement);

	    return _super8.call(this, parameters, {
	      isRenderable: parameters.renderForms
	    });
	  }

	  _createClass(ChoiceWidgetAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var _this10 = this;

	      this.container.className = "choiceWidgetAnnotation";
	      var storage = this.annotationStorage;
	      var id = this.data.id;
	      storage.getValue(id, {
	        value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined
	      });
	      var fontSize = this.data.defaultAppearanceData.fontSize;

	      if (!fontSize) {
	        fontSize = 9;
	      }

	      var fontSizeStyle = "calc(".concat(fontSize, "px * var(--zoom-factor))");
	      var selectElement = document.createElement("select");
	      GetElementsByNameSet.add(selectElement);
	      selectElement.disabled = this.data.readOnly;
	      selectElement.name = this.data.fieldName;
	      selectElement.setAttribute("id", id);
	      selectElement.tabIndex = DEFAULT_TAB_INDEX;
	      selectElement.style.fontSize = "".concat(fontSize, "px");

	      if (!this.data.combo) {
	        selectElement.size = this.data.options.length;

	        if (this.data.multiSelect) {
	          selectElement.multiple = true;
	        }
	      }

	      selectElement.addEventListener("resetform", function (event) {
	        var defaultValue = _this10.data.defaultFieldValue;

	        var _iterator13 = _createForOfIteratorHelper(selectElement.options),
	            _step13;

	        try {
	          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
	            var option = _step13.value;
	            option.selected = option.value === defaultValue;
	          }
	        } catch (err) {
	          _iterator13.e(err);
	        } finally {
	          _iterator13.f();
	        }
	      });

	      var _iterator14 = _createForOfIteratorHelper(this.data.options),
	          _step14;

	      try {
	        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
	          var option = _step14.value;
	          var optionElement = document.createElement("option");
	          optionElement.textContent = option.displayValue;
	          optionElement.value = option.exportValue;

	          if (this.data.combo) {
	            optionElement.style.fontSize = fontSizeStyle;
	          }

	          if (this.data.fieldValue.includes(option.exportValue)) {
	            optionElement.setAttribute("selected", true);
	          }

	          selectElement.appendChild(optionElement);
	        }
	      } catch (err) {
	        _iterator14.e(err);
	      } finally {
	        _iterator14.f();
	      }

	      var getValue = function getValue(event, isExport) {
	        var name = isExport ? "value" : "textContent";
	        var options = event.target.options;

	        if (!event.target.multiple) {
	          return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
	        }

	        return Array.prototype.filter.call(options, function (option) {
	          return option.selected;
	        }).map(function (option) {
	          return option[name];
	        });
	      };

	      var getItems = function getItems(event) {
	        var options = event.target.options;
	        return Array.prototype.map.call(options, function (option) {
	          return {
	            displayValue: option.textContent,
	            exportValue: option.value
	          };
	        });
	      };

	      if (this.enableScripting && this.hasJSActions) {
	        selectElement.addEventListener("updatefromsandbox", function (jsEvent) {
	          var actions = {
	            value: function value(event) {
	              var value = event.detail.value;
	              var values = new Set(Array.isArray(value) ? value : [value]);

	              var _iterator15 = _createForOfIteratorHelper(selectElement.options),
	                  _step15;

	              try {
	                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
	                  var option = _step15.value;
	                  option.selected = values.has(option.value);
	                }
	              } catch (err) {
	                _iterator15.e(err);
	              } finally {
	                _iterator15.f();
	              }

	              storage.setValue(id, {
	                value: getValue(event, true)
	              });
	            },
	            multipleSelection: function multipleSelection(event) {
	              selectElement.multiple = true;
	            },
	            remove: function remove(event) {
	              var options = selectElement.options;
	              var index = event.detail.remove;
	              options[index].selected = false;
	              selectElement.remove(index);

	              if (options.length > 0) {
	                var i = Array.prototype.findIndex.call(options, function (option) {
	                  return option.selected;
	                });

	                if (i === -1) {
	                  options[0].selected = true;
	                }
	              }

	              storage.setValue(id, {
	                value: getValue(event, true),
	                items: getItems(event)
	              });
	            },
	            clear: function clear(event) {
	              while (selectElement.length !== 0) {
	                selectElement.remove(0);
	              }

	              storage.setValue(id, {
	                value: null,
	                items: []
	              });
	            },
	            insert: function insert(event) {
	              var _event$detail$insert = event.detail.insert,
	                  index = _event$detail$insert.index,
	                  displayValue = _event$detail$insert.displayValue,
	                  exportValue = _event$detail$insert.exportValue;
	              var optionElement = document.createElement("option");
	              optionElement.textContent = displayValue;
	              optionElement.value = exportValue;
	              selectElement.insertBefore(optionElement, selectElement.children[index]);
	              storage.setValue(id, {
	                value: getValue(event, true),
	                items: getItems(event)
	              });
	            },
	            items: function items(event) {
	              var items = event.detail.items;

	              while (selectElement.length !== 0) {
	                selectElement.remove(0);
	              }

	              var _iterator16 = _createForOfIteratorHelper(items),
	                  _step16;

	              try {
	                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
	                  var item = _step16.value;
	                  var displayValue = item.displayValue,
	                      exportValue = item.exportValue;
	                  var optionElement = document.createElement("option");
	                  optionElement.textContent = displayValue;
	                  optionElement.value = exportValue;
	                  selectElement.appendChild(optionElement);
	                }
	              } catch (err) {
	                _iterator16.e(err);
	              } finally {
	                _iterator16.f();
	              }

	              if (selectElement.options.length > 0) {
	                selectElement.options[0].selected = true;
	              }

	              storage.setValue(id, {
	                value: getValue(event, true),
	                items: getItems(event)
	              });
	            },
	            indices: function indices(event) {
	              var indices = new Set(event.detail.indices);

	              var _iterator17 = _createForOfIteratorHelper(event.target.options),
	                  _step17;

	              try {
	                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
	                  var option = _step17.value;
	                  option.selected = indices.has(option.index);
	                }
	              } catch (err) {
	                _iterator17.e(err);
	              } finally {
	                _iterator17.f();
	              }

	              storage.setValue(id, {
	                value: getValue(event, true)
	              });
	            },
	            editable: function editable(event) {
	              event.target.disabled = !event.detail.editable;
	            }
	          };

	          _this10._dispatchEventFromSandbox(actions, jsEvent);
	        });
	        selectElement.addEventListener("input", function (event) {
	          var _this10$linkService$e;

	          var exportValue = getValue(event, true);
	          var value = getValue(event, false);
	          storage.setValue(id, {
	            value: exportValue
	          });
	          (_this10$linkService$e = _this10.linkService.eventBus) === null || _this10$linkService$e === void 0 ? void 0 : _this10$linkService$e.dispatch("dispatcheventinsandbox", {
	            source: _this10,
	            detail: {
	              id: id,
	              name: "Keystroke",
	              value: value,
	              changeEx: exportValue,
	              willCommit: true,
	              commitKey: 1,
	              keyDown: false
	            }
	          });
	        });

	        this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], function (event) {
	          return event.target.checked;
	        });
	      } else {
	        selectElement.addEventListener("input", function (event) {
	          storage.setValue(id, {
	            value: getValue(event)
	          });
	        });
	      }

	      this._setBackgroundColor(selectElement);

	      this.container.appendChild(selectElement);
	      return this.container;
	    }
	  }]);

	  return ChoiceWidgetAnnotationElement;
	}(WidgetAnnotationElement);

	var PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {
	  _inherits(PopupAnnotationElement, _AnnotationElement4);

	  var _super9 = _createSuper(PopupAnnotationElement);

	  function PopupAnnotationElement(parameters) {
	    var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;

	    _classCallCheck(this, PopupAnnotationElement);

	    var isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);
	    return _super9.call(this, parameters, {
	      isRenderable: isRenderable
	    });
	  }

	  _createClass(PopupAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
	      this.container.className = "popupAnnotation";

	      if (IGNORE_TYPES.includes(this.data.parentType)) {
	        return this.container;
	      }

	      var selector = "[data-annotation-id=\"".concat(this.data.parentId, "\"]");
	      var parentElements = this.layer.querySelectorAll(selector);

	      if (parentElements.length === 0) {
	        return this.container;
	      }

	      var popup = new PopupElement({
	        container: this.container,
	        trigger: Array.from(parentElements),
	        color: this.data.color,
	        titleObj: this.data.titleObj,
	        modificationDate: this.data.modificationDate,
	        contentsObj: this.data.contentsObj,
	        richText: this.data.richText
	      });
	      var page = this.page;

	      var rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

	      var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
	      var popupTop = rect[1];
	      this.container.style.transformOrigin = "".concat(-popupLeft, "px ").concat(-popupTop, "px");
	      this.container.style.left = "".concat(popupLeft, "px");
	      this.container.style.top = "".concat(popupTop, "px");
	      this.container.appendChild(popup.render());
	      return this.container;
	    }
	  }]);

	  return PopupAnnotationElement;
	}(AnnotationElement);

	var PopupElement = /*#__PURE__*/function () {
	  function PopupElement(parameters) {
	    _classCallCheck(this, PopupElement);

	    this.container = parameters.container;
	    this.trigger = parameters.trigger;
	    this.color = parameters.color;
	    this.titleObj = parameters.titleObj;
	    this.modificationDate = parameters.modificationDate;
	    this.contentsObj = parameters.contentsObj;
	    this.richText = parameters.richText;
	    this.hideWrapper = parameters.hideWrapper || false;
	    this.pinned = false;
	  }

	  _createClass(PopupElement, [{
	    key: "render",
	    value: function render() {
	      var _this$richText, _this$contentsObj;

	      var BACKGROUND_ENLIGHT = 0.7;
	      var wrapper = document.createElement("div");
	      wrapper.className = "popupWrapper";
	      this.hideElement = this.hideWrapper ? wrapper : this.container;
	      this.hideElement.hidden = true;
	      var popup = document.createElement("div");
	      popup.className = "popup";
	      var color = this.color;

	      if (color) {
	        var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
	        var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
	        var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
	        popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
	      }

	      var title = document.createElement("h1");
	      title.dir = this.titleObj.dir;
	      title.textContent = this.titleObj.str;
	      popup.appendChild(title);

	      var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

	      if (dateObject) {
	        var modificationDate = document.createElement("span");
	        modificationDate.className = "popupDate";
	        modificationDate.textContent = "{{date}}, {{time}}";
	        modificationDate.dataset.l10nId = "annotation_date_string";
	        modificationDate.dataset.l10nArgs = JSON.stringify({
	          date: dateObject.toLocaleDateString(),
	          time: dateObject.toLocaleTimeString()
	        });
	        popup.appendChild(modificationDate);
	      }

	      if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {
	        _xfa_layer.XfaLayer.render({
	          xfaHtml: this.richText.html,
	          intent: "richText",
	          div: popup
	        });

	        popup.lastChild.className = "richText popupContent";
	      } else {
	        var contents = this._formatContents(this.contentsObj);

	        popup.appendChild(contents);
	      }

	      if (!Array.isArray(this.trigger)) {
	        this.trigger = [this.trigger];
	      }

	      var _iterator18 = _createForOfIteratorHelper(this.trigger),
	          _step18;

	      try {
	        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
	          var element = _step18.value;
	          element.addEventListener("click", this._toggle.bind(this));
	          element.addEventListener("mouseover", this._show.bind(this, false));
	          element.addEventListener("mouseout", this._hide.bind(this, false));
	        }
	      } catch (err) {
	        _iterator18.e(err);
	      } finally {
	        _iterator18.f();
	      }

	      popup.addEventListener("click", this._hide.bind(this, true));
	      wrapper.appendChild(popup);
	      return wrapper;
	    }
	  }, {
	    key: "_formatContents",
	    value: function _formatContents(_ref2) {
	      var str = _ref2.str,
	          dir = _ref2.dir;
	      var p = document.createElement("p");
	      p.className = "popupContent";
	      p.dir = dir;
	      var lines = str.split(/(?:\r\n?|\n)/);

	      for (var i = 0, ii = lines.length; i < ii; ++i) {
	        var line = lines[i];
	        p.appendChild(document.createTextNode(line));

	        if (i < ii - 1) {
	          p.appendChild(document.createElement("br"));
	        }
	      }

	      return p;
	    }
	  }, {
	    key: "_toggle",
	    value: function _toggle() {
	      if (this.pinned) {
	        this._hide(true);
	      } else {
	        this._show(true);
	      }
	    }
	  }, {
	    key: "_show",
	    value: function _show() {
	      var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (pin) {
	        this.pinned = true;
	      }

	      if (this.hideElement.hidden) {
	        this.hideElement.hidden = false;
	        this.container.style.zIndex += 1;
	      }
	    }
	  }, {
	    key: "_hide",
	    value: function _hide() {
	      var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	      if (unpin) {
	        this.pinned = false;
	      }

	      if (!this.hideElement.hidden && !this.pinned) {
	        this.hideElement.hidden = true;
	        this.container.style.zIndex -= 1;
	      }
	    }
	  }]);

	  return PopupElement;
	}();

	var FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {
	  _inherits(FreeTextAnnotationElement, _AnnotationElement5);

	  var _super10 = _createSuper(FreeTextAnnotationElement);

	  function FreeTextAnnotationElement(parameters) {
	    var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;

	    _classCallCheck(this, FreeTextAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);
	    return _super10.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	  }

	  _createClass(FreeTextAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "freeTextAnnotation";

	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      return this.container;
	    }
	  }]);

	  return FreeTextAnnotationElement;
	}(AnnotationElement);

	var LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {
	  _inherits(LineAnnotationElement, _AnnotationElement6);

	  var _super11 = _createSuper(LineAnnotationElement);

	  function LineAnnotationElement(parameters) {
	    var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;

	    _classCallCheck(this, LineAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);
	    return _super11.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	  }

	  _createClass(LineAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "lineAnnotation";
	      var data = this.data;
	      var width = data.rect[2] - data.rect[0];
	      var height = data.rect[3] - data.rect[1];
	      var svg = this.svgFactory.create(width, height);
	      var line = this.svgFactory.createElement("svg:line");
	      line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
	      line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
	      line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
	      line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
	      line.setAttribute("stroke-width", data.borderStyle.width || 1);
	      line.setAttribute("stroke", "transparent");
	      line.setAttribute("fill", "transparent");
	      svg.appendChild(line);
	      this.container.append(svg);

	      this._createPopup(line, data);

	      return this.container;
	    }
	  }]);

	  return LineAnnotationElement;
	}(AnnotationElement);

	var SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {
	  _inherits(SquareAnnotationElement, _AnnotationElement7);

	  var _super12 = _createSuper(SquareAnnotationElement);

	  function SquareAnnotationElement(parameters) {
	    var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;

	    _classCallCheck(this, SquareAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);
	    return _super12.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	  }

	  _createClass(SquareAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "squareAnnotation";
	      var data = this.data;
	      var width = data.rect[2] - data.rect[0];
	      var height = data.rect[3] - data.rect[1];
	      var svg = this.svgFactory.create(width, height);
	      var borderWidth = data.borderStyle.width;
	      var square = this.svgFactory.createElement("svg:rect");
	      square.setAttribute("x", borderWidth / 2);
	      square.setAttribute("y", borderWidth / 2);
	      square.setAttribute("width", width - borderWidth);
	      square.setAttribute("height", height - borderWidth);
	      square.setAttribute("stroke-width", borderWidth || 1);
	      square.setAttribute("stroke", "transparent");
	      square.setAttribute("fill", "transparent");
	      svg.appendChild(square);
	      this.container.append(svg);

	      this._createPopup(square, data);

	      return this.container;
	    }
	  }]);

	  return SquareAnnotationElement;
	}(AnnotationElement);

	var CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {
	  _inherits(CircleAnnotationElement, _AnnotationElement8);

	  var _super13 = _createSuper(CircleAnnotationElement);

	  function CircleAnnotationElement(parameters) {
	    var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;

	    _classCallCheck(this, CircleAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);
	    return _super13.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	  }

	  _createClass(CircleAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "circleAnnotation";
	      var data = this.data;
	      var width = data.rect[2] - data.rect[0];
	      var height = data.rect[3] - data.rect[1];
	      var svg = this.svgFactory.create(width, height);
	      var borderWidth = data.borderStyle.width;
	      var circle = this.svgFactory.createElement("svg:ellipse");
	      circle.setAttribute("cx", width / 2);
	      circle.setAttribute("cy", height / 2);
	      circle.setAttribute("rx", width / 2 - borderWidth / 2);
	      circle.setAttribute("ry", height / 2 - borderWidth / 2);
	      circle.setAttribute("stroke-width", borderWidth || 1);
	      circle.setAttribute("stroke", "transparent");
	      circle.setAttribute("fill", "transparent");
	      svg.appendChild(circle);
	      this.container.append(svg);

	      this._createPopup(circle, data);

	      return this.container;
	    }
	  }]);

	  return CircleAnnotationElement;
	}(AnnotationElement);

	var PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {
	  _inherits(PolylineAnnotationElement, _AnnotationElement9);

	  var _super14 = _createSuper(PolylineAnnotationElement);

	  function PolylineAnnotationElement(parameters) {
	    var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;

	    var _this11;

	    _classCallCheck(this, PolylineAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);
	    _this11 = _super14.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	    _this11.containerClassName = "polylineAnnotation";
	    _this11.svgElementName = "svg:polyline";
	    return _this11;
	  }

	  _createClass(PolylineAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = this.containerClassName;
	      var data = this.data;
	      var width = data.rect[2] - data.rect[0];
	      var height = data.rect[3] - data.rect[1];
	      var svg = this.svgFactory.create(width, height);
	      var points = [];

	      var _iterator19 = _createForOfIteratorHelper(data.vertices),
	          _step19;

	      try {
	        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
	          var coordinate = _step19.value;
	          var x = coordinate.x - data.rect[0];
	          var y = data.rect[3] - coordinate.y;
	          points.push(x + "," + y);
	        }
	      } catch (err) {
	        _iterator19.e(err);
	      } finally {
	        _iterator19.f();
	      }

	      points = points.join(" ");
	      var polyline = this.svgFactory.createElement(this.svgElementName);
	      polyline.setAttribute("points", points);
	      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
	      polyline.setAttribute("stroke", "transparent");
	      polyline.setAttribute("fill", "transparent");
	      svg.appendChild(polyline);
	      this.container.append(svg);

	      this._createPopup(polyline, data);

	      return this.container;
	    }
	  }]);

	  return PolylineAnnotationElement;
	}(AnnotationElement);

	var PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {
	  _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);

	  var _super15 = _createSuper(PolygonAnnotationElement);

	  function PolygonAnnotationElement(parameters) {
	    var _this12;

	    _classCallCheck(this, PolygonAnnotationElement);

	    _this12 = _super15.call(this, parameters);
	    _this12.containerClassName = "polygonAnnotation";
	    _this12.svgElementName = "svg:polygon";
	    return _this12;
	  }

	  return PolygonAnnotationElement;
	}(PolylineAnnotationElement);

	var CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {
	  _inherits(CaretAnnotationElement, _AnnotationElement10);

	  var _super16 = _createSuper(CaretAnnotationElement);

	  function CaretAnnotationElement(parameters) {
	    var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;

	    _classCallCheck(this, CaretAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);
	    return _super16.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	  }

	  _createClass(CaretAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "caretAnnotation";

	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      return this.container;
	    }
	  }]);

	  return CaretAnnotationElement;
	}(AnnotationElement);

	var InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {
	  _inherits(InkAnnotationElement, _AnnotationElement11);

	  var _super17 = _createSuper(InkAnnotationElement);

	  function InkAnnotationElement(parameters) {
	    var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;

	    var _this13;

	    _classCallCheck(this, InkAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);
	    _this13 = _super17.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	    _this13.containerClassName = "inkAnnotation";
	    _this13.svgElementName = "svg:polyline";
	    return _this13;
	  }

	  _createClass(InkAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = this.containerClassName;
	      var data = this.data;
	      var width = data.rect[2] - data.rect[0];
	      var height = data.rect[3] - data.rect[1];
	      var svg = this.svgFactory.create(width, height);

	      var _iterator20 = _createForOfIteratorHelper(data.inkLists),
	          _step20;

	      try {
	        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
	          var inkList = _step20.value;
	          var points = [];

	          var _iterator21 = _createForOfIteratorHelper(inkList),
	              _step21;

	          try {
	            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
	              var coordinate = _step21.value;
	              var x = coordinate.x - data.rect[0];
	              var y = data.rect[3] - coordinate.y;
	              points.push("".concat(x, ",").concat(y));
	            }
	          } catch (err) {
	            _iterator21.e(err);
	          } finally {
	            _iterator21.f();
	          }

	          points = points.join(" ");
	          var polyline = this.svgFactory.createElement(this.svgElementName);
	          polyline.setAttribute("points", points);
	          polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
	          polyline.setAttribute("stroke", "transparent");
	          polyline.setAttribute("fill", "transparent");

	          this._createPopup(polyline, data);

	          svg.appendChild(polyline);
	        }
	      } catch (err) {
	        _iterator20.e(err);
	      } finally {
	        _iterator20.f();
	      }

	      this.container.append(svg);
	      return this.container;
	    }
	  }]);

	  return InkAnnotationElement;
	}(AnnotationElement);

	var HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {
	  _inherits(HighlightAnnotationElement, _AnnotationElement12);

	  var _super18 = _createSuper(HighlightAnnotationElement);

	  function HighlightAnnotationElement(parameters) {
	    var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;

	    _classCallCheck(this, HighlightAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);
	    return _super18.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  _createClass(HighlightAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      if (this.quadrilaterals) {
	        return this._renderQuadrilaterals("highlightAnnotation");
	      }

	      this.container.className = "highlightAnnotation";
	      return this.container;
	    }
	  }]);

	  return HighlightAnnotationElement;
	}(AnnotationElement);

	var UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {
	  _inherits(UnderlineAnnotationElement, _AnnotationElement13);

	  var _super19 = _createSuper(UnderlineAnnotationElement);

	  function UnderlineAnnotationElement(parameters) {
	    var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;

	    _classCallCheck(this, UnderlineAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);
	    return _super19.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  _createClass(UnderlineAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      if (this.quadrilaterals) {
	        return this._renderQuadrilaterals("underlineAnnotation");
	      }

	      this.container.className = "underlineAnnotation";
	      return this.container;
	    }
	  }]);

	  return UnderlineAnnotationElement;
	}(AnnotationElement);

	var SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {
	  _inherits(SquigglyAnnotationElement, _AnnotationElement14);

	  var _super20 = _createSuper(SquigglyAnnotationElement);

	  function SquigglyAnnotationElement(parameters) {
	    var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;

	    _classCallCheck(this, SquigglyAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);
	    return _super20.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  _createClass(SquigglyAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      if (this.quadrilaterals) {
	        return this._renderQuadrilaterals("squigglyAnnotation");
	      }

	      this.container.className = "squigglyAnnotation";
	      return this.container;
	    }
	  }]);

	  return SquigglyAnnotationElement;
	}(AnnotationElement);

	var StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {
	  _inherits(StrikeOutAnnotationElement, _AnnotationElement15);

	  var _super21 = _createSuper(StrikeOutAnnotationElement);

	  function StrikeOutAnnotationElement(parameters) {
	    var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;

	    _classCallCheck(this, StrikeOutAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);
	    return _super21.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true,
	      createQuadrilaterals: true
	    });
	  }

	  _createClass(StrikeOutAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      if (this.quadrilaterals) {
	        return this._renderQuadrilaterals("strikeoutAnnotation");
	      }

	      this.container.className = "strikeoutAnnotation";
	      return this.container;
	    }
	  }]);

	  return StrikeOutAnnotationElement;
	}(AnnotationElement);

	var StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {
	  _inherits(StampAnnotationElement, _AnnotationElement16);

	  var _super22 = _createSuper(StampAnnotationElement);

	  function StampAnnotationElement(parameters) {
	    var _parameters$data$titl14, _parameters$data$cont14, _parameters$data$rich14;

	    _classCallCheck(this, StampAnnotationElement);

	    var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str || (_parameters$data$rich14 = parameters.data.richText) !== null && _parameters$data$rich14 !== void 0 && _parameters$data$rich14.str);
	    return _super22.call(this, parameters, {
	      isRenderable: isRenderable,
	      ignoreBorder: true
	    });
	  }

	  _createClass(StampAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      this.container.className = "stampAnnotation";

	      if (!this.data.hasPopup) {
	        this._createPopup(null, this.data);
	      }

	      return this.container;
	    }
	  }]);

	  return StampAnnotationElement;
	}(AnnotationElement);

	var FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {
	  _inherits(FileAttachmentAnnotationElement, _AnnotationElement17);

	  var _super23 = _createSuper(FileAttachmentAnnotationElement);

	  function FileAttachmentAnnotationElement(parameters) {
	    var _this14$linkService$e;

	    var _this14;

	    _classCallCheck(this, FileAttachmentAnnotationElement);

	    _this14 = _super23.call(this, parameters, {
	      isRenderable: true
	    });
	    var _this14$data$file = _this14.data.file,
	        filename = _this14$data$file.filename,
	        content = _this14$data$file.content;
	    _this14.filename = (0, _display_utils.getFilenameFromUrl)(filename);
	    _this14.content = content;
	    (_this14$linkService$e = _this14.linkService.eventBus) === null || _this14$linkService$e === void 0 ? void 0 : _this14$linkService$e.dispatch("fileattachmentannotation", {
	      source: _assertThisInitialized(_this14),
	      id: (0, _util.stringToPDFString)(filename),
	      filename: filename,
	      content: content
	    });
	    return _this14;
	  }

	  _createClass(FileAttachmentAnnotationElement, [{
	    key: "render",
	    value: function render() {
	      var _this$data$titleObj, _this$data$contentsOb;

	      this.container.className = "fileAttachmentAnnotation";
	      var trigger = document.createElement("div");
	      trigger.style.height = this.container.style.height;
	      trigger.style.width = this.container.style.width;
	      trigger.addEventListener("dblclick", this._download.bind(this));

	      if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {
	        this._createPopup(trigger, this.data);
	      }

	      this.container.appendChild(trigger);
	      return this.container;
	    }
	  }, {
	    key: "_download",
	    value: function _download() {
	      var _this$downloadManager;

	      (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
	    }
	  }]);

	  return FileAttachmentAnnotationElement;
	}(AnnotationElement);

	var AnnotationLayer = /*#__PURE__*/function () {
	  function AnnotationLayer() {
	    _classCallCheck(this, AnnotationLayer);
	  }

	  _createClass(AnnotationLayer, null, [{
	    key: "render",
	    value: function render(parameters) {
	      var sortedAnnotations = [],
	          popupAnnotations = [];

	      var _iterator22 = _createForOfIteratorHelper(parameters.annotations),
	          _step22;

	      try {
	        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
	          var _data = _step22.value;

	          if (!_data) {
	            continue;
	          }

	          if (_data.annotationType === _util.AnnotationType.POPUP) {
	            popupAnnotations.push(_data);
	            continue;
	          }

	          sortedAnnotations.push(_data);
	        }
	      } catch (err) {
	        _iterator22.e(err);
	      } finally {
	        _iterator22.f();
	      }

	      if (popupAnnotations.length) {
	        sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);
	      }

	      var div = parameters.div;

	      for (var _i7 = 0, _sortedAnnotations = sortedAnnotations; _i7 < _sortedAnnotations.length; _i7++) {
	        var data = _sortedAnnotations[_i7];
	        var element = AnnotationElementFactory.create({
	          data: data,
	          layer: div,
	          page: parameters.page,
	          viewport: parameters.viewport,
	          linkService: parameters.linkService,
	          downloadManager: parameters.downloadManager,
	          imageResourcesPath: parameters.imageResourcesPath || "",
	          renderForms: parameters.renderForms !== false,
	          svgFactory: new _display_utils.DOMSVGFactory(),
	          annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
	          enableScripting: parameters.enableScripting,
	          hasJSActions: parameters.hasJSActions,
	          fieldObjects: parameters.fieldObjects,
	          mouseState: parameters.mouseState || {
	            isDown: false
	          }
	        });

	        if (element.isRenderable) {
	          var rendered = element.render();

	          if (data.hidden) {
	            rendered.style.visibility = "hidden";
	          }

	          if (Array.isArray(rendered)) {
	            var _iterator23 = _createForOfIteratorHelper(rendered),
	                _step23;

	            try {
	              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
	                var renderedElement = _step23.value;
	                div.appendChild(renderedElement);
	              }
	            } catch (err) {
	              _iterator23.e(err);
	            } finally {
	              _iterator23.f();
	            }
	          } else {
	            if (element instanceof PopupAnnotationElement) {
	              div.prepend(rendered);
	            } else {
	              div.appendChild(rendered);
	            }
	          }
	        }
	      }

	      _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, parameters.annotationCanvasMap);
	    }
	  }, {
	    key: "update",
	    value: function update(parameters) {
	      var page = parameters.page,
	          viewport = parameters.viewport,
	          annotations = parameters.annotations,
	          annotationCanvasMap = parameters.annotationCanvasMap,
	          div = parameters.div;
	      var transform = viewport.transform;
	      var matrix = "matrix(".concat(transform.join(","), ")");
	      var scale, ownMatrix;

	      var _iterator24 = _createForOfIteratorHelper(annotations),
	          _step24;

	      try {
	        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
	          var data = _step24.value;
	          var elements = div.querySelectorAll("[data-annotation-id=\"".concat(data.id, "\"]"));

	          if (elements) {
	            var _iterator25 = _createForOfIteratorHelper(elements),
	                _step25;

	            try {
	              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
	                var element = _step25.value;

	                if (data.hasOwnCanvas) {
	                  var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

	                  if (!ownMatrix) {
	                    scale = Math.abs(transform[0] || transform[1]);
	                    var ownTransform = transform.slice();

	                    for (var i = 0; i < 4; i++) {
	                      ownTransform[i] = Math.sign(ownTransform[i]);
	                    }

	                    ownMatrix = "matrix(".concat(ownTransform.join(","), ")");
	                  }

	                  var left = rect[0] * scale;
	                  var top = rect[1] * scale;
	                  element.style.left = "".concat(left, "px");
	                  element.style.top = "".concat(top, "px");
	                  element.style.transformOrigin = "".concat(-left, "px ").concat(-top, "px");
	                  element.style.transform = ownMatrix;
	                } else {
	                  element.style.transform = matrix;
	                }
	              }
	            } catch (err) {
	              _iterator25.e(err);
	            } finally {
	              _iterator25.f();
	            }
	          }
	        }
	      } catch (err) {
	        _iterator24.e(err);
	      } finally {
	        _iterator24.f();
	      }

	      _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);

	      div.hidden = false;
	    }
	  }]);

	  return AnnotationLayer;
	}();

	exports.AnnotationLayer = AnnotationLayer;

	function _setAnnotationCanvasMap(div, annotationCanvasMap) {
	  if (!annotationCanvasMap) {
	    return;
	  }

	  var _iterator26 = _createForOfIteratorHelper(annotationCanvasMap),
	      _step26;

	  try {
	    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
	      var _step26$value = _slicedToArray(_step26.value, 2),
	          id = _step26$value[0],
	          canvas = _step26$value[1];

	      var element = div.querySelector("[data-annotation-id=\"".concat(id, "\"]"));

	      if (!element) {
	        continue;
	      }

	      var firstChild = element.firstChild;

	      if (firstChild.nodeName === "CANVAS") {
	        element.replaceChild(canvas, firstChild);
	      } else {
	        element.insertBefore(canvas, firstChild);
	      }
	    }
	  } catch (err) {
	    _iterator26.e(err);
	  } finally {
	    _iterator26.f();
	  }

	  annotationCanvasMap.clear();
	}

	/***/ }),
	/* 149 */
	/***/ ((__unused_webpack_module, exports) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.ColorConverters = void 0;

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function makeColorComp(n) {
	  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
	}

	var ColorConverters = /*#__PURE__*/function () {
	  function ColorConverters() {
	    _classCallCheck(this, ColorConverters);
	  }

	  _createClass(ColorConverters, null, [{
	    key: "CMYK_G",
	    value: function CMYK_G(_ref) {
	      var _ref2 = _slicedToArray(_ref, 4),
	          c = _ref2[0],
	          y = _ref2[1],
	          m = _ref2[2],
	          k = _ref2[3];

	      return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
	    }
	  }, {
	    key: "G_CMYK",
	    value: function G_CMYK(_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 1),
	          g = _ref4[0];

	      return ["CMYK", 0, 0, 0, 1 - g];
	    }
	  }, {
	    key: "G_RGB",
	    value: function G_RGB(_ref5) {
	      var _ref6 = _slicedToArray(_ref5, 1),
	          g = _ref6[0];

	      return ["RGB", g, g, g];
	    }
	  }, {
	    key: "G_HTML",
	    value: function G_HTML(_ref7) {
	      var _ref8 = _slicedToArray(_ref7, 1),
	          g = _ref8[0];

	      var G = makeColorComp(g);
	      return "#".concat(G).concat(G).concat(G);
	    }
	  }, {
	    key: "RGB_G",
	    value: function RGB_G(_ref9) {
	      var _ref10 = _slicedToArray(_ref9, 3),
	          r = _ref10[0],
	          g = _ref10[1],
	          b = _ref10[2];

	      return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
	    }
	  }, {
	    key: "RGB_HTML",
	    value: function RGB_HTML(_ref11) {
	      var _ref12 = _slicedToArray(_ref11, 3),
	          r = _ref12[0],
	          g = _ref12[1],
	          b = _ref12[2];

	      var R = makeColorComp(r);
	      var G = makeColorComp(g);
	      var B = makeColorComp(b);
	      return "#".concat(R).concat(G).concat(B);
	    }
	  }, {
	    key: "T_HTML",
	    value: function T_HTML() {
	      return "#00000000";
	    }
	  }, {
	    key: "CMYK_RGB",
	    value: function CMYK_RGB(_ref13) {
	      var _ref14 = _slicedToArray(_ref13, 4),
	          c = _ref14[0],
	          y = _ref14[1],
	          m = _ref14[2],
	          k = _ref14[3];

	      return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
	    }
	  }, {
	    key: "CMYK_HTML",
	    value: function CMYK_HTML(components) {
	      return this.RGB_HTML(this.CMYK_RGB(components));
	    }
	  }, {
	    key: "RGB_CMYK",
	    value: function RGB_CMYK(_ref15) {
	      var _ref16 = _slicedToArray(_ref15, 3),
	          r = _ref16[0],
	          g = _ref16[1],
	          b = _ref16[2];

	      var c = 1 - r;
	      var m = 1 - g;
	      var y = 1 - b;
	      var k = Math.min(c, m, y);
	      return ["CMYK", c, m, y, k];
	    }
	  }]);

	  return ColorConverters;
	}();

	exports.ColorConverters = ColorConverters;

	/***/ }),
	/* 150 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.XfaLayer = void 0;

	var _util = __w_pdfjs_require__(4);

	var _xfa_text = __w_pdfjs_require__(147);

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var XfaLayer = /*#__PURE__*/function () {
	  function XfaLayer() {
	    _classCallCheck(this, XfaLayer);
	  }

	  _createClass(XfaLayer, null, [{
	    key: "setupStorage",
	    value: function setupStorage(html, id, element, storage, intent) {
	      var storedData = storage.getValue(id, {
	        value: null
	      });

	      switch (element.name) {
	        case "textarea":
	          if (storedData.value !== null) {
	            html.textContent = storedData.value;
	          }

	          if (intent === "print") {
	            break;
	          }

	          html.addEventListener("input", function (event) {
	            storage.setValue(id, {
	              value: event.target.value
	            });
	          });
	          break;

	        case "input":
	          if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
	            if (storedData.value === element.attributes.xfaOn) {
	              html.setAttribute("checked", true);
	            } else if (storedData.value === element.attributes.xfaOff) {
	              html.removeAttribute("checked");
	            }

	            if (intent === "print") {
	              break;
	            }

	            html.addEventListener("change", function (event) {
	              storage.setValue(id, {
	                value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
	              });
	            });
	          } else {
	            if (storedData.value !== null) {
	              html.setAttribute("value", storedData.value);
	            }

	            if (intent === "print") {
	              break;
	            }

	            html.addEventListener("input", function (event) {
	              storage.setValue(id, {
	                value: event.target.value
	              });
	            });
	          }

	          break;

	        case "select":
	          if (storedData.value !== null) {
	            var _iterator = _createForOfIteratorHelper(element.children),
	                _step;

	            try {
	              for (_iterator.s(); !(_step = _iterator.n()).done;) {
	                var option = _step.value;

	                if (option.attributes.value === storedData.value) {
	                  option.attributes.selected = true;
	                }
	              }
	            } catch (err) {
	              _iterator.e(err);
	            } finally {
	              _iterator.f();
	            }
	          }

	          html.addEventListener("input", function (event) {
	            var options = event.target.options;
	            var value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
	            storage.setValue(id, {
	              value: value
	            });
	          });
	          break;
	      }
	    }
	  }, {
	    key: "setAttributes",
	    value: function setAttributes(_ref) {
	      var html = _ref.html,
	          element = _ref.element,
	          _ref$storage = _ref.storage,
	          storage = _ref$storage === void 0 ? null : _ref$storage,
	          intent = _ref.intent,
	          linkService = _ref.linkService;
	      var attributes = element.attributes;
	      var isHTMLAnchorElement = html instanceof HTMLAnchorElement;

	      if (attributes.type === "radio") {
	        attributes.name = "".concat(attributes.name, "-").concat(intent);
	      }

	      for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
	        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
	            key = _Object$entries$_i[0],
	            value = _Object$entries$_i[1];

	        if (value === null || value === undefined || key === "dataId") {
	          continue;
	        }

	        if (key !== "style") {
	          if (key === "textContent") {
	            html.textContent = value;
	          } else if (key === "class") {
	            if (value.length) {
	              html.setAttribute(key, value.join(" "));
	            }
	          } else {
	            if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
	              continue;
	            }

	            html.setAttribute(key, value);
	          }
	        } else {
	          Object.assign(html.style, value);
	        }
	      }

	      if (isHTMLAnchorElement) {
	        var _linkService$addLinkA;

	        if (!linkService.addLinkAttributes) {
	          (0, _util.warn)("XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.");
	        }

	        (_linkService$addLinkA = linkService.addLinkAttributes) === null || _linkService$addLinkA === void 0 ? void 0 : _linkService$addLinkA.call(linkService, html, attributes.href, attributes.newWindow);
	      }

	      if (storage && attributes.dataId) {
	        this.setupStorage(html, attributes.dataId, element, storage);
	      }
	    }
	  }, {
	    key: "render",
	    value: function render(parameters) {
	      var storage = parameters.annotationStorage;
	      var linkService = parameters.linkService;
	      var root = parameters.xfaHtml;
	      var intent = parameters.intent || "display";
	      var rootHtml = document.createElement(root.name);

	      if (root.attributes) {
	        this.setAttributes({
	          html: rootHtml,
	          element: root,
	          intent: intent,
	          linkService: linkService
	        });
	      }

	      var stack = [[root, -1, rootHtml]];
	      var rootDiv = parameters.div;
	      rootDiv.appendChild(rootHtml);

	      if (parameters.viewport) {
	        var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
	        rootDiv.style.transform = transform;
	      }

	      if (intent !== "richText") {
	        rootDiv.setAttribute("class", "xfaLayer xfaFont");
	      }

	      var textDivs = [];

	      while (stack.length > 0) {
	        var _child$attributes;

	        var _stack = _slicedToArray(stack[stack.length - 1], 3),
	            parent = _stack[0],
	            i = _stack[1],
	            html = _stack[2];

	        if (i + 1 === parent.children.length) {
	          stack.pop();
	          continue;
	        }

	        var child = parent.children[++stack[stack.length - 1][1]];

	        if (child === null) {
	          continue;
	        }

	        var name = child.name;

	        if (name === "#text") {
	          var node = document.createTextNode(child.value);
	          textDivs.push(node);
	          html.appendChild(node);
	          continue;
	        }

	        var childHtml = void 0;

	        if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
	          childHtml = document.createElementNS(child.attributes.xmlns, name);
	        } else {
	          childHtml = document.createElement(name);
	        }

	        html.appendChild(childHtml);

	        if (child.attributes) {
	          this.setAttributes({
	            html: childHtml,
	            element: child,
	            storage: storage,
	            intent: intent,
	            linkService: linkService
	          });
	        }

	        if (child.children && child.children.length > 0) {
	          stack.push([child, -1, childHtml]);
	        } else if (child.value) {
	          var _node = document.createTextNode(child.value);

	          if (_xfa_text.XfaText.shouldBuildText(name)) {
	            textDivs.push(_node);
	          }

	          childHtml.appendChild(_node);
	        }
	      }

	      var _iterator2 = _createForOfIteratorHelper(rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var el = _step2.value;
	          el.setAttribute("readOnly", true);
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      return {
	        textDivs: textDivs
	      };
	    }
	  }, {
	    key: "update",
	    value: function update(parameters) {
	      var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
	      parameters.div.style.transform = transform;
	      parameters.div.hidden = false;
	    }
	  }]);

	  return XfaLayer;
	}();

	exports.XfaLayer = XfaLayer;

	/***/ }),
	/* 151 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.renderTextLayer = renderTextLayer;

	var _util = __w_pdfjs_require__(4);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	var MAX_TEXT_DIVS_TO_RENDER = 100000;
	var DEFAULT_FONT_SIZE = 30;
	var DEFAULT_FONT_ASCENT = 0.8;
	var ascentCache = new Map();
	var AllWhitespaceRegexp = /^\s+$/g;

	function getAscent(fontFamily, ctx) {
	  var cachedAscent = ascentCache.get(fontFamily);

	  if (cachedAscent) {
	    return cachedAscent;
	  }

	  ctx.save();
	  ctx.font = "".concat(DEFAULT_FONT_SIZE, "px ").concat(fontFamily);
	  var metrics = ctx.measureText("");
	  var ascent = metrics.fontBoundingBoxAscent;
	  var descent = Math.abs(metrics.fontBoundingBoxDescent);

	  if (ascent) {
	    ctx.restore();
	    var ratio = ascent / (ascent + descent);
	    ascentCache.set(fontFamily, ratio);
	    return ratio;
	  }

	  ctx.strokeStyle = "red";
	  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
	  ctx.strokeText("g", 0, 0);
	  var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
	  descent = 0;

	  for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {
	    if (pixels[i] > 0) {
	      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
	      break;
	    }
	  }

	  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
	  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
	  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
	  ascent = 0;

	  for (var _i = 0, ii = pixels.length; _i < ii; _i += 4) {
	    if (pixels[_i] > 0) {
	      ascent = DEFAULT_FONT_SIZE - Math.floor(_i / 4 / DEFAULT_FONT_SIZE);
	      break;
	    }
	  }

	  ctx.restore();

	  if (ascent) {
	    var _ratio = ascent / (ascent + descent);

	    ascentCache.set(fontFamily, _ratio);
	    return _ratio;
	  }

	  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
	  return DEFAULT_FONT_ASCENT;
	}

	function appendText(task, geom, styles, ctx) {
	  var textDiv = document.createElement("span");
	  var textDivProperties = task._enhanceTextSelection ? {
	    angle: 0,
	    canvasWidth: 0,
	    hasText: geom.str !== "",
	    hasEOL: geom.hasEOL,
	    originalTransform: null,
	    paddingBottom: 0,
	    paddingLeft: 0,
	    paddingRight: 0,
	    paddingTop: 0,
	    scale: 1
	  } : {
	    angle: 0,
	    canvasWidth: 0,
	    hasText: geom.str !== "",
	    hasEOL: geom.hasEOL
	  };

	  task._textDivs.push(textDiv);

	  var tx = _util.Util.transform(task._viewport.transform, geom.transform);

	  var angle = Math.atan2(tx[1], tx[0]);
	  var style = styles[geom.fontName];

	  if (style.vertical) {
	    angle += Math.PI / 2;
	  }

	  var fontHeight = Math.hypot(tx[2], tx[3]);
	  var fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
	  var left, top;

	  if (angle === 0) {
	    left = tx[4];
	    top = tx[5] - fontAscent;
	  } else {
	    left = tx[4] + fontAscent * Math.sin(angle);
	    top = tx[5] - fontAscent * Math.cos(angle);
	  }

	  textDiv.style.left = "".concat(left, "px");
	  textDiv.style.top = "".concat(top, "px");
	  textDiv.style.fontSize = "".concat(fontHeight, "px");
	  textDiv.style.fontFamily = style.fontFamily;
	  textDiv.setAttribute("role", "presentation");
	  textDiv.textContent = geom.str;
	  textDiv.dir = geom.dir;

	  if (task._fontInspectorEnabled) {
	    textDiv.dataset.fontName = geom.fontName;
	  }

	  if (angle !== 0) {
	    textDivProperties.angle = angle * (180 / Math.PI);
	  }

	  var shouldScaleText = false;

	  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
	    shouldScaleText = true;
	  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
	    var absScaleX = Math.abs(geom.transform[0]),
	        absScaleY = Math.abs(geom.transform[3]);

	    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
	      shouldScaleText = true;
	    }
	  }

	  if (shouldScaleText) {
	    if (style.vertical) {
	      textDivProperties.canvasWidth = geom.height * task._viewport.scale;
	    } else {
	      textDivProperties.canvasWidth = geom.width * task._viewport.scale;
	    }
	  }

	  task._textDivProperties.set(textDiv, textDivProperties);

	  if (task._textContentStream) {
	    task._layoutText(textDiv);
	  }

	  if (task._enhanceTextSelection && textDivProperties.hasText) {
	    var angleCos = 1,
	        angleSin = 0;

	    if (angle !== 0) {
	      angleCos = Math.cos(angle);
	      angleSin = Math.sin(angle);
	    }

	    var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
	    var divHeight = fontHeight;
	    var m, b;

	    if (angle !== 0) {
	      m = [angleCos, angleSin, -angleSin, angleCos, left, top];
	      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
	    } else {
	      b = [left, top, left + divWidth, top + divHeight];
	    }

	    task._bounds.push({
	      left: b[0],
	      top: b[1],
	      right: b[2],
	      bottom: b[3],
	      div: textDiv,
	      size: [divWidth, divHeight],
	      m: m
	    });
	  }
	}

	function render(task) {
	  if (task._canceled) {
	    return;
	  }

	  var textDivs = task._textDivs;
	  var capability = task._capability;
	  var textDivsLength = textDivs.length;

	  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
	    task._renderingDone = true;
	    capability.resolve();
	    return;
	  }

	  if (!task._textContentStream) {
	    for (var i = 0; i < textDivsLength; i++) {
	      task._layoutText(textDivs[i]);
	    }
	  }

	  task._renderingDone = true;
	  capability.resolve();
	}

	function findPositiveMin(ts, offset, count) {
	  var result = 0;

	  for (var i = 0; i < count; i++) {
	    var t = ts[offset++];

	    if (t > 0) {
	      result = result ? Math.min(t, result) : t;
	    }
	  }

	  return result;
	}

	function expand(task) {
	  var bounds = task._bounds;
	  var viewport = task._viewport;
	  var expanded = expandBounds(viewport.width, viewport.height, bounds);

	  for (var i = 0; i < expanded.length; i++) {
	    var div = bounds[i].div;

	    var divProperties = task._textDivProperties.get(div);

	    if (divProperties.angle === 0) {
	      divProperties.paddingLeft = bounds[i].left - expanded[i].left;
	      divProperties.paddingTop = bounds[i].top - expanded[i].top;
	      divProperties.paddingRight = expanded[i].right - bounds[i].right;
	      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

	      task._textDivProperties.set(div, divProperties);

	      continue;
	    }

	    var e = expanded[i],
	        b = bounds[i];
	    var m = b.m,
	        c = m[0],
	        s = m[1];
	    var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
	    var ts = new Float64Array(64);

	    for (var j = 0, jj = points.length; j < jj; j++) {
	      var t = _util.Util.applyTransform(points[j], m);

	      ts[j + 0] = c && (e.left - t[0]) / c;
	      ts[j + 4] = s && (e.top - t[1]) / s;
	      ts[j + 8] = c && (e.right - t[0]) / c;
	      ts[j + 12] = s && (e.bottom - t[1]) / s;
	      ts[j + 16] = s && (e.left - t[0]) / -s;
	      ts[j + 20] = c && (e.top - t[1]) / c;
	      ts[j + 24] = s && (e.right - t[0]) / -s;
	      ts[j + 28] = c && (e.bottom - t[1]) / c;
	      ts[j + 32] = c && (e.left - t[0]) / -c;
	      ts[j + 36] = s && (e.top - t[1]) / -s;
	      ts[j + 40] = c && (e.right - t[0]) / -c;
	      ts[j + 44] = s && (e.bottom - t[1]) / -s;
	      ts[j + 48] = s && (e.left - t[0]) / s;
	      ts[j + 52] = c && (e.top - t[1]) / -c;
	      ts[j + 56] = s && (e.right - t[0]) / s;
	      ts[j + 60] = c && (e.bottom - t[1]) / -c;
	    }

	    var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
	    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
	    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
	    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
	    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

	    task._textDivProperties.set(div, divProperties);
	  }
	}

	function expandBounds(width, height, boxes) {
	  var bounds = boxes.map(function (box, i) {
	    return {
	      x1: box.left,
	      y1: box.top,
	      x2: box.right,
	      y2: box.bottom,
	      index: i,
	      x1New: undefined,
	      x2New: undefined
	    };
	  });
	  expandBoundsLTR(width, bounds);
	  var expanded = new Array(boxes.length);

	  var _iterator = _createForOfIteratorHelper(bounds),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var b = _step.value;
	      var i = b.index;
	      expanded[i] = {
	        left: b.x1New,
	        top: 0,
	        right: b.x2New,
	        bottom: 0
	      };
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  boxes.map(function (box, i) {
	    var e = expanded[i],
	        b = bounds[i];
	    b.x1 = box.top;
	    b.y1 = width - e.right;
	    b.x2 = box.bottom;
	    b.y2 = width - e.left;
	    b.index = i;
	    b.x1New = undefined;
	    b.x2New = undefined;
	  });
	  expandBoundsLTR(height, bounds);

	  var _iterator2 = _createForOfIteratorHelper(bounds),
	      _step2;

	  try {
	    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	      var _b = _step2.value;
	      var _i2 = _b.index;
	      expanded[_i2].top = _b.x1New;
	      expanded[_i2].bottom = _b.x2New;
	    }
	  } catch (err) {
	    _iterator2.e(err);
	  } finally {
	    _iterator2.f();
	  }

	  return expanded;
	}

	function expandBoundsLTR(width, bounds) {
	  bounds.sort(function (a, b) {
	    return a.x1 - b.x1 || a.index - b.index;
	  });
	  var fakeBoundary = {
	    x1: -Infinity,
	    y1: -Infinity,
	    x2: 0,
	    y2: Infinity,
	    index: -1,
	    x1New: 0,
	    x2New: 0
	  };
	  var horizon = [{
	    start: -Infinity,
	    end: Infinity,
	    boundary: fakeBoundary
	  }];

	  var _iterator3 = _createForOfIteratorHelper(bounds),
	      _step3;

	  try {
	    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	      var boundary = _step3.value;
	      var i = 0;

	      while (i < horizon.length && horizon[i].end <= boundary.y1) {
	        i++;
	      }

	      var j = horizon.length - 1;

	      while (j >= 0 && horizon[j].start >= boundary.y2) {
	        j--;
	      }

	      var _horizonPart = void 0,
	          _affectedBoundary = void 0;

	      var q = void 0,
	          k = void 0,
	          maxXNew = -Infinity;

	      for (q = i; q <= j; q++) {
	        _horizonPart = horizon[q];
	        _affectedBoundary = _horizonPart.boundary;
	        var xNew = void 0;

	        if (_affectedBoundary.x2 > boundary.x1) {
	          xNew = _affectedBoundary.index > boundary.index ? _affectedBoundary.x1New : boundary.x1;
	        } else if (_affectedBoundary.x2New === undefined) {
	          xNew = (_affectedBoundary.x2 + boundary.x1) / 2;
	        } else {
	          xNew = _affectedBoundary.x2New;
	        }

	        if (xNew > maxXNew) {
	          maxXNew = xNew;
	        }
	      }

	      boundary.x1New = maxXNew;

	      for (q = i; q <= j; q++) {
	        _horizonPart = horizon[q];
	        _affectedBoundary = _horizonPart.boundary;

	        if (_affectedBoundary.x2New === undefined) {
	          if (_affectedBoundary.x2 > boundary.x1) {
	            if (_affectedBoundary.index > boundary.index) {
	              _affectedBoundary.x2New = _affectedBoundary.x2;
	            }
	          } else {
	            _affectedBoundary.x2New = maxXNew;
	          }
	        } else if (_affectedBoundary.x2New > maxXNew) {
	          _affectedBoundary.x2New = Math.max(maxXNew, _affectedBoundary.x2);
	        }
	      }

	      var changedHorizon = [];
	      var lastBoundary = null;

	      for (q = i; q <= j; q++) {
	        _horizonPart = horizon[q];
	        _affectedBoundary = _horizonPart.boundary;
	        var useBoundary = _affectedBoundary.x2 > boundary.x2 ? _affectedBoundary : boundary;

	        if (lastBoundary === useBoundary) {
	          changedHorizon[changedHorizon.length - 1].end = _horizonPart.end;
	        } else {
	          changedHorizon.push({
	            start: _horizonPart.start,
	            end: _horizonPart.end,
	            boundary: useBoundary
	          });
	          lastBoundary = useBoundary;
	        }
	      }

	      if (horizon[i].start < boundary.y1) {
	        changedHorizon[0].start = boundary.y1;
	        changedHorizon.unshift({
	          start: horizon[i].start,
	          end: boundary.y1,
	          boundary: horizon[i].boundary
	        });
	      }

	      if (boundary.y2 < horizon[j].end) {
	        changedHorizon[changedHorizon.length - 1].end = boundary.y2;
	        changedHorizon.push({
	          start: boundary.y2,
	          end: horizon[j].end,
	          boundary: horizon[j].boundary
	        });
	      }

	      for (q = i; q <= j; q++) {
	        _horizonPart = horizon[q];
	        _affectedBoundary = _horizonPart.boundary;

	        if (_affectedBoundary.x2New !== undefined) {
	          continue;
	        }

	        var used = false;

	        for (k = i - 1; !used && k >= 0 && horizon[k].start >= _affectedBoundary.y1; k--) {
	          used = horizon[k].boundary === _affectedBoundary;
	        }

	        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= _affectedBoundary.y2; k++) {
	          used = horizon[k].boundary === _affectedBoundary;
	        }

	        for (k = 0; !used && k < changedHorizon.length; k++) {
	          used = changedHorizon[k].boundary === _affectedBoundary;
	        }

	        if (!used) {
	          _affectedBoundary.x2New = maxXNew;
	        }
	      }

	      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
	    }
	  } catch (err) {
	    _iterator3.e(err);
	  } finally {
	    _iterator3.f();
	  }

	  for (var _i3 = 0, _horizon = horizon; _i3 < _horizon.length; _i3++) {
	    var horizonPart = _horizon[_i3];
	    var affectedBoundary = horizonPart.boundary;

	    if (affectedBoundary.x2New === undefined) {
	      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
	    }
	  }
	}

	var TextLayerRenderTask = /*#__PURE__*/function () {
	  function TextLayerRenderTask(_ref) {
	    var _globalThis$FontInspe,
	        _this = this;

	    var textContent = _ref.textContent,
	        textContentStream = _ref.textContentStream,
	        container = _ref.container,
	        viewport = _ref.viewport,
	        textDivs = _ref.textDivs,
	        textContentItemsStr = _ref.textContentItemsStr,
	        enhanceTextSelection = _ref.enhanceTextSelection;

	    _classCallCheck(this, TextLayerRenderTask);

	    this._textContent = textContent;
	    this._textContentStream = textContentStream;
	    this._container = container;
	    this._document = container.ownerDocument;
	    this._viewport = viewport;
	    this._textDivs = textDivs || [];
	    this._textContentItemsStr = textContentItemsStr || [];
	    this._enhanceTextSelection = !!enhanceTextSelection;
	    this._fontInspectorEnabled = !!((_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled);
	    this._reader = null;
	    this._layoutTextLastFontSize = null;
	    this._layoutTextLastFontFamily = null;
	    this._layoutTextCtx = null;
	    this._textDivProperties = new WeakMap();
	    this._renderingDone = false;
	    this._canceled = false;
	    this._capability = (0, _util.createPromiseCapability)();
	    this._renderTimer = null;
	    this._bounds = [];

	    this._capability.promise["finally"](function () {
	      if (!_this._enhanceTextSelection) {
	        _this._textDivProperties = null;
	      }

	      if (_this._layoutTextCtx) {
	        _this._layoutTextCtx.canvas.width = 0;
	        _this._layoutTextCtx.canvas.height = 0;
	        _this._layoutTextCtx = null;
	      }
	    })["catch"](function () {});
	  }

	  _createClass(TextLayerRenderTask, [{
	    key: "promise",
	    get: function get() {
	      return this._capability.promise;
	    }
	  }, {
	    key: "cancel",
	    value: function cancel() {
	      this._canceled = true;

	      if (this._reader) {
	        this._reader.cancel(new _util.AbortException("TextLayer task cancelled."))["catch"](function () {});

	        this._reader = null;
	      }

	      if (this._renderTimer !== null) {
	        clearTimeout(this._renderTimer);
	        this._renderTimer = null;
	      }

	      this._capability.reject(new Error("TextLayer task cancelled."));
	    }
	  }, {
	    key: "_processItems",
	    value: function _processItems(items, styleCache) {
	      for (var i = 0, len = items.length; i < len; i++) {
	        if (items[i].str === undefined) {
	          if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
	            var parent = this._container;
	            this._container = document.createElement("span");

	            this._container.classList.add("markedContent");

	            if (items[i].id !== null) {
	              this._container.setAttribute("id", "".concat(items[i].id));
	            }

	            parent.appendChild(this._container);
	          } else if (items[i].type === "endMarkedContent") {
	            this._container = this._container.parentNode;
	          }

	          continue;
	        }

	        this._textContentItemsStr.push(items[i].str);

	        appendText(this, items[i], styleCache, this._layoutTextCtx);
	      }
	    }
	  }, {
	    key: "_layoutText",
	    value: function _layoutText(textDiv) {
	      var textDivProperties = this._textDivProperties.get(textDiv);

	      var transform = "";

	      if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
	        var _textDiv$style = textDiv.style,
	            fontSize = _textDiv$style.fontSize,
	            fontFamily = _textDiv$style.fontFamily;

	        if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
	          this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
	          this._layoutTextLastFontSize = fontSize;
	          this._layoutTextLastFontFamily = fontFamily;
	        }

	        var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent),
	            width = _this$_layoutTextCtx$.width;

	        if (width > 0) {
	          var scale = textDivProperties.canvasWidth / width;

	          if (this._enhanceTextSelection) {
	            textDivProperties.scale = scale;
	          }

	          transform = "scaleX(".concat(scale, ")");
	        }
	      }

	      if (textDivProperties.angle !== 0) {
	        transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
	      }

	      if (transform.length > 0) {
	        if (this._enhanceTextSelection) {
	          textDivProperties.originalTransform = transform;
	        }

	        textDiv.style.transform = transform;
	      }

	      if (textDivProperties.hasText) {
	        this._container.appendChild(textDiv);
	      }

	      if (textDivProperties.hasEOL) {
	        var br = document.createElement("br");
	        br.setAttribute("role", "presentation");

	        this._container.appendChild(br);
	      }
	    }
	  }, {
	    key: "_render",
	    value: function _render() {
	      var _this2 = this;

	      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var capability = (0, _util.createPromiseCapability)();
	      var styleCache = Object.create(null);

	      var canvas = this._document.createElement("canvas");

	      canvas.height = canvas.width = DEFAULT_FONT_SIZE;
	      canvas.mozOpaque = true;
	      this._layoutTextCtx = canvas.getContext("2d", {
	        alpha: false
	      });

	      if (this._textContent) {
	        var textItems = this._textContent.items;
	        var textStyles = this._textContent.styles;

	        this._processItems(textItems, textStyles);

	        capability.resolve();
	      } else if (this._textContentStream) {
	        var pump = function pump() {
	          _this2._reader.read().then(function (_ref2) {
	            var value = _ref2.value,
	                done = _ref2.done;

	            if (done) {
	              capability.resolve();
	              return;
	            }

	            Object.assign(styleCache, value.styles);

	            _this2._processItems(value.items, styleCache);

	            pump();
	          }, capability.reject);
	        };

	        this._reader = this._textContentStream.getReader();
	        pump();
	      } else {
	        throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
	      }

	      capability.promise.then(function () {
	        styleCache = null;

	        if (!timeout) {
	          render(_this2);
	        } else {
	          _this2._renderTimer = setTimeout(function () {
	            render(_this2);
	            _this2._renderTimer = null;
	          }, timeout);
	        }
	      }, this._capability.reject);
	    }
	  }, {
	    key: "expandTextDivs",
	    value: function expandTextDivs() {
	      var expandDivs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (!this._enhanceTextSelection || !this._renderingDone) {
	        return;
	      }

	      if (this._bounds !== null) {
	        expand(this);
	        this._bounds = null;
	      }

	      var transformBuf = [],
	          paddingBuf = [];

	      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
	        var div = this._textDivs[i];

	        var divProps = this._textDivProperties.get(div);

	        if (!divProps.hasText) {
	          continue;
	        }

	        if (expandDivs) {
	          transformBuf.length = 0;
	          paddingBuf.length = 0;

	          if (divProps.originalTransform) {
	            transformBuf.push(divProps.originalTransform);
	          }

	          if (divProps.paddingTop > 0) {
	            paddingBuf.push("".concat(divProps.paddingTop, "px"));
	            transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
	          } else {
	            paddingBuf.push(0);
	          }

	          if (divProps.paddingRight > 0) {
	            paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
	          } else {
	            paddingBuf.push(0);
	          }

	          if (divProps.paddingBottom > 0) {
	            paddingBuf.push("".concat(divProps.paddingBottom, "px"));
	          } else {
	            paddingBuf.push(0);
	          }

	          if (divProps.paddingLeft > 0) {
	            paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
	            transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
	          } else {
	            paddingBuf.push(0);
	          }

	          div.style.padding = paddingBuf.join(" ");

	          if (transformBuf.length) {
	            div.style.transform = transformBuf.join(" ");
	          }
	        } else {
	          div.style.padding = null;
	          div.style.transform = divProps.originalTransform;
	        }
	      }
	    }
	  }]);

	  return TextLayerRenderTask;
	}();

	function renderTextLayer(renderParameters) {
	  var task = new TextLayerRenderTask({
	    textContent: renderParameters.textContent,
	    textContentStream: renderParameters.textContentStream,
	    container: renderParameters.container,
	    viewport: renderParameters.viewport,
	    textDivs: renderParameters.textDivs,
	    textContentItemsStr: renderParameters.textContentItemsStr,
	    enhanceTextSelection: renderParameters.enhanceTextSelection
	  });

	  task._render(renderParameters.timeout);

	  return task;
	}

	/***/ }),
	/* 152 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.SVGGraphics = void 0;

	var _util = __w_pdfjs_require__(4);

	var _display_utils = __w_pdfjs_require__(1);

	var _is_node = __w_pdfjs_require__(6);

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SVGGraphics = function SVGGraphics() {
	  _classCallCheck(this, SVGGraphics);

	  (0, _util.unreachable)("Not implemented: SVGGraphics");
	};

	exports.SVGGraphics = SVGGraphics;
	{
	  var opListToTree = function opListToTree(opList) {
	    var opTree = [];
	    var tmp = [];

	    var _iterator = _createForOfIteratorHelper(opList),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var opListElement = _step.value;

	        if (opListElement.fn === "save") {
	          opTree.push({
	            fnId: 92,
	            fn: "group",
	            items: []
	          });
	          tmp.push(opTree);
	          opTree = opTree[opTree.length - 1].items;
	          continue;
	        }

	        if (opListElement.fn === "restore") {
	          opTree = tmp.pop();
	        } else {
	          opTree.push(opListElement);
	        }
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }

	    return opTree;
	  };

	  var pf = function pf(value) {
	    if (Number.isInteger(value)) {
	      return value.toString();
	    }

	    var s = value.toFixed(10);
	    var i = s.length - 1;

	    if (s[i] !== "0") {
	      return s;
	    }

	    do {
	      i--;
	    } while (s[i] === "0");

	    return s.substring(0, s[i] === "." ? i : i + 1);
	  };

	  var pm = function pm(m) {
	    if (m[4] === 0 && m[5] === 0) {
	      if (m[1] === 0 && m[2] === 0) {
	        if (m[0] === 1 && m[3] === 1) {
	          return "";
	        }

	        return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
	      }

	      if (m[0] === m[3] && m[1] === -m[2]) {
	        var a = Math.acos(m[0]) * 180 / Math.PI;
	        return "rotate(".concat(pf(a), ")");
	      }
	    } else {
	      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
	        return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
	      }
	    }

	    return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
	  };

	  var SVG_DEFAULTS = {
	    fontStyle: "normal",
	    fontWeight: "normal",
	    fillColor: "#000000"
	  };
	  var XML_NS = "http://www.w3.org/XML/1998/namespace";
	  var XLINK_NS = "http://www.w3.org/1999/xlink";
	  var LINE_CAP_STYLES = ["butt", "round", "square"];
	  var LINE_JOIN_STYLES = ["miter", "round", "bevel"];

	  var convertImgDataToPng = function () {
	    var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
	    var CHUNK_WRAPPER_SIZE = 12;
	    var crcTable = new Int32Array(256);

	    for (var i = 0; i < 256; i++) {
	      var c = i;

	      for (var h = 0; h < 8; h++) {
	        if (c & 1) {
	          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
	        } else {
	          c = c >> 1 & 0x7fffffff;
	        }
	      }

	      crcTable[i] = c;
	    }

	    function crc32(data, start, end) {
	      var crc = -1;

	      for (var _i = start; _i < end; _i++) {
	        var a = (crc ^ data[_i]) & 0xff;
	        var b = crcTable[a];
	        crc = crc >>> 8 ^ b;
	      }

	      return crc ^ -1;
	    }

	    function writePngChunk(type, body, data, offset) {
	      var p = offset;
	      var len = body.length;
	      data[p] = len >> 24 & 0xff;
	      data[p + 1] = len >> 16 & 0xff;
	      data[p + 2] = len >> 8 & 0xff;
	      data[p + 3] = len & 0xff;
	      p += 4;
	      data[p] = type.charCodeAt(0) & 0xff;
	      data[p + 1] = type.charCodeAt(1) & 0xff;
	      data[p + 2] = type.charCodeAt(2) & 0xff;
	      data[p + 3] = type.charCodeAt(3) & 0xff;
	      p += 4;
	      data.set(body, p);
	      p += body.length;
	      var crc = crc32(data, offset + 4, p);
	      data[p] = crc >> 24 & 0xff;
	      data[p + 1] = crc >> 16 & 0xff;
	      data[p + 2] = crc >> 8 & 0xff;
	      data[p + 3] = crc & 0xff;
	    }

	    function adler32(data, start, end) {
	      var a = 1;
	      var b = 0;

	      for (var _i2 = start; _i2 < end; ++_i2) {
	        a = (a + (data[_i2] & 0xff)) % 65521;
	        b = (b + a) % 65521;
	      }

	      return b << 16 | a;
	    }

	    function deflateSync(literals) {
	      if (!_is_node.isNodeJS) {
	        return deflateSyncUncompressed(literals);
	      }

	      try {
	        var input;

	        if (parseInt(process.versions.node) >= 8) {
	          input = literals;
	        } else {
	          input = Buffer.from(literals);
	        }

	        var output = require$$0.deflateSync(input, {
	          level: 9
	        });

	        return output instanceof Uint8Array ? output : new Uint8Array(output);
	      } catch (e) {
	        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
	      }

	      return deflateSyncUncompressed(literals);
	    }

	    function deflateSyncUncompressed(literals) {
	      var len = literals.length;
	      var maxBlockLength = 0xffff;
	      var deflateBlocks = Math.ceil(len / maxBlockLength);
	      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
	      var pi = 0;
	      idat[pi++] = 0x78;
	      idat[pi++] = 0x9c;
	      var pos = 0;

	      while (len > maxBlockLength) {
	        idat[pi++] = 0x00;
	        idat[pi++] = 0xff;
	        idat[pi++] = 0xff;
	        idat[pi++] = 0x00;
	        idat[pi++] = 0x00;
	        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
	        pi += maxBlockLength;
	        pos += maxBlockLength;
	        len -= maxBlockLength;
	      }

	      idat[pi++] = 0x01;
	      idat[pi++] = len & 0xff;
	      idat[pi++] = len >> 8 & 0xff;
	      idat[pi++] = ~len & 0xffff & 0xff;
	      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
	      idat.set(literals.subarray(pos), pi);
	      pi += literals.length - pos;
	      var adler = adler32(literals, 0, literals.length);
	      idat[pi++] = adler >> 24 & 0xff;
	      idat[pi++] = adler >> 16 & 0xff;
	      idat[pi++] = adler >> 8 & 0xff;
	      idat[pi++] = adler & 0xff;
	      return idat;
	    }

	    function encode(imgData, kind, forceDataSchema, isMask) {
	      var width = imgData.width;
	      var height = imgData.height;
	      var bitDepth, colorType, lineSize;
	      var bytes = imgData.data;

	      switch (kind) {
	        case _util.ImageKind.GRAYSCALE_1BPP:
	          colorType = 0;
	          bitDepth = 1;
	          lineSize = width + 7 >> 3;
	          break;

	        case _util.ImageKind.RGB_24BPP:
	          colorType = 2;
	          bitDepth = 8;
	          lineSize = width * 3;
	          break;

	        case _util.ImageKind.RGBA_32BPP:
	          colorType = 6;
	          bitDepth = 8;
	          lineSize = width * 4;
	          break;

	        default:
	          throw new Error("invalid format");
	      }

	      var literals = new Uint8Array((1 + lineSize) * height);
	      var offsetLiterals = 0,
	          offsetBytes = 0;

	      for (var y = 0; y < height; ++y) {
	        literals[offsetLiterals++] = 0;
	        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
	        offsetBytes += lineSize;
	        offsetLiterals += lineSize;
	      }

	      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
	        offsetLiterals = 0;

	        for (var _y = 0; _y < height; _y++) {
	          offsetLiterals++;

	          for (var _i3 = 0; _i3 < lineSize; _i3++) {
	            literals[offsetLiterals++] ^= 0xff;
	          }
	        }
	      }

	      var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
	      var idat = deflateSync(literals);
	      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
	      var data = new Uint8Array(pngLength);
	      var offset = 0;
	      data.set(PNG_HEADER, offset);
	      offset += PNG_HEADER.length;
	      writePngChunk("IHDR", ihdr, data, offset);
	      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
	      writePngChunk("IDATA", idat, data, offset);
	      offset += CHUNK_WRAPPER_SIZE + idat.length;
	      writePngChunk("IEND", new Uint8Array(0), data, offset);
	      return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
	    }

	    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
	      var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
	      return encode(imgData, kind, forceDataSchema, isMask);
	    };
	  }();

	  var SVGExtraState = /*#__PURE__*/function () {
	    function SVGExtraState() {
	      _classCallCheck(this, SVGExtraState);

	      this.fontSizeScale = 1;
	      this.fontWeight = SVG_DEFAULTS.fontWeight;
	      this.fontSize = 0;
	      this.textMatrix = _util.IDENTITY_MATRIX;
	      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
	      this.leading = 0;
	      this.textRenderingMode = _util.TextRenderingMode.FILL;
	      this.textMatrixScale = 1;
	      this.x = 0;
	      this.y = 0;
	      this.lineX = 0;
	      this.lineY = 0;
	      this.charSpacing = 0;
	      this.wordSpacing = 0;
	      this.textHScale = 1;
	      this.textRise = 0;
	      this.fillColor = SVG_DEFAULTS.fillColor;
	      this.strokeColor = "#000000";
	      this.fillAlpha = 1;
	      this.strokeAlpha = 1;
	      this.lineWidth = 1;
	      this.lineJoin = "";
	      this.lineCap = "";
	      this.miterLimit = 0;
	      this.dashArray = [];
	      this.dashPhase = 0;
	      this.dependencies = [];
	      this.activeClipUrl = null;
	      this.clipGroup = null;
	      this.maskId = "";
	    }

	    _createClass(SVGExtraState, [{
	      key: "clone",
	      value: function clone() {
	        return Object.create(this);
	      }
	    }, {
	      key: "setCurrentPoint",
	      value: function setCurrentPoint(x, y) {
	        this.x = x;
	        this.y = y;
	      }
	    }]);

	    return SVGExtraState;
	  }();

	  var clipCount = 0;
	  var maskCount = 0;
	  var shadingCount = 0;

	  exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {
	    function SVGGraphics(commonObjs, objs) {
	      var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      _classCallCheck(this, SVGGraphics);

	      this.svgFactory = new _display_utils.DOMSVGFactory();
	      this.current = new SVGExtraState();
	      this.transformMatrix = _util.IDENTITY_MATRIX;
	      this.transformStack = [];
	      this.extraStack = [];
	      this.commonObjs = commonObjs;
	      this.objs = objs;
	      this.pendingClip = null;
	      this.pendingEOFill = false;
	      this.embedFonts = false;
	      this.embeddedFonts = Object.create(null);
	      this.cssStyle = null;
	      this.forceDataSchema = !!forceDataSchema;
	      this._operatorIdMapping = [];

	      for (var op in _util.OPS) {
	        this._operatorIdMapping[_util.OPS[op]] = op;
	      }
	    }

	    _createClass(SVGGraphics, [{
	      key: "save",
	      value: function save() {
	        this.transformStack.push(this.transformMatrix);
	        var old = this.current;
	        this.extraStack.push(old);
	        this.current = old.clone();
	      }
	    }, {
	      key: "restore",
	      value: function restore() {
	        this.transformMatrix = this.transformStack.pop();
	        this.current = this.extraStack.pop();
	        this.pendingClip = null;
	        this.tgrp = null;
	      }
	    }, {
	      key: "group",
	      value: function group(items) {
	        this.save();
	        this.executeOpTree(items);
	        this.restore();
	      }
	    }, {
	      key: "loadDependencies",
	      value: function loadDependencies(operatorList) {
	        var _this = this;

	        var fnArray = operatorList.fnArray;
	        var argsArray = operatorList.argsArray;

	        for (var i = 0, ii = fnArray.length; i < ii; i++) {
	          if (fnArray[i] !== _util.OPS.dependency) {
	            continue;
	          }

	          var _iterator2 = _createForOfIteratorHelper(argsArray[i]),
	              _step2;

	          try {
	            var _loop = function _loop() {
	              var obj = _step2.value;
	              var objsPool = obj.startsWith("g_") ? _this.commonObjs : _this.objs;
	              var promise = new Promise(function (resolve) {
	                objsPool.get(obj, resolve);
	              });

	              _this.current.dependencies.push(promise);
	            };

	            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	              _loop();
	            }
	          } catch (err) {
	            _iterator2.e(err);
	          } finally {
	            _iterator2.f();
	          }
	        }

	        return Promise.all(this.current.dependencies);
	      }
	    }, {
	      key: "transform",
	      value: function transform(a, b, c, d, e, f) {
	        var transformMatrix = [a, b, c, d, e, f];
	        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
	        this.tgrp = null;
	      }
	    }, {
	      key: "getSVG",
	      value: function getSVG(operatorList, viewport) {
	        var _this2 = this;

	        this.viewport = viewport;

	        var svgElement = this._initialize(viewport);

	        return this.loadDependencies(operatorList).then(function () {
	          _this2.transformMatrix = _util.IDENTITY_MATRIX;

	          _this2.executeOpTree(_this2.convertOpList(operatorList));

	          return svgElement;
	        });
	      }
	    }, {
	      key: "convertOpList",
	      value: function convertOpList(operatorList) {
	        var operatorIdMapping = this._operatorIdMapping;
	        var argsArray = operatorList.argsArray;
	        var fnArray = operatorList.fnArray;
	        var opList = [];

	        for (var i = 0, ii = fnArray.length; i < ii; i++) {
	          var fnId = fnArray[i];
	          opList.push({
	            fnId: fnId,
	            fn: operatorIdMapping[fnId],
	            args: argsArray[i]
	          });
	        }

	        return opListToTree(opList);
	      }
	    }, {
	      key: "executeOpTree",
	      value: function executeOpTree(opTree) {
	        var _iterator3 = _createForOfIteratorHelper(opTree),
	            _step3;

	        try {
	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var opTreeElement = _step3.value;
	            var fn = opTreeElement.fn;
	            var fnId = opTreeElement.fnId;
	            var args = opTreeElement.args;

	            switch (fnId | 0) {
	              case _util.OPS.beginText:
	                this.beginText();
	                break;

	              case _util.OPS.dependency:
	                break;

	              case _util.OPS.setLeading:
	                this.setLeading(args);
	                break;

	              case _util.OPS.setLeadingMoveText:
	                this.setLeadingMoveText(args[0], args[1]);
	                break;

	              case _util.OPS.setFont:
	                this.setFont(args);
	                break;

	              case _util.OPS.showText:
	                this.showText(args[0]);
	                break;

	              case _util.OPS.showSpacedText:
	                this.showText(args[0]);
	                break;

	              case _util.OPS.endText:
	                this.endText();
	                break;

	              case _util.OPS.moveText:
	                this.moveText(args[0], args[1]);
	                break;

	              case _util.OPS.setCharSpacing:
	                this.setCharSpacing(args[0]);
	                break;

	              case _util.OPS.setWordSpacing:
	                this.setWordSpacing(args[0]);
	                break;

	              case _util.OPS.setHScale:
	                this.setHScale(args[0]);
	                break;

	              case _util.OPS.setTextMatrix:
	                this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
	                break;

	              case _util.OPS.setTextRise:
	                this.setTextRise(args[0]);
	                break;

	              case _util.OPS.setTextRenderingMode:
	                this.setTextRenderingMode(args[0]);
	                break;

	              case _util.OPS.setLineWidth:
	                this.setLineWidth(args[0]);
	                break;

	              case _util.OPS.setLineJoin:
	                this.setLineJoin(args[0]);
	                break;

	              case _util.OPS.setLineCap:
	                this.setLineCap(args[0]);
	                break;

	              case _util.OPS.setMiterLimit:
	                this.setMiterLimit(args[0]);
	                break;

	              case _util.OPS.setFillRGBColor:
	                this.setFillRGBColor(args[0], args[1], args[2]);
	                break;

	              case _util.OPS.setStrokeRGBColor:
	                this.setStrokeRGBColor(args[0], args[1], args[2]);
	                break;

	              case _util.OPS.setStrokeColorN:
	                this.setStrokeColorN(args);
	                break;

	              case _util.OPS.setFillColorN:
	                this.setFillColorN(args);
	                break;

	              case _util.OPS.shadingFill:
	                this.shadingFill(args[0]);
	                break;

	              case _util.OPS.setDash:
	                this.setDash(args[0], args[1]);
	                break;

	              case _util.OPS.setRenderingIntent:
	                this.setRenderingIntent(args[0]);
	                break;

	              case _util.OPS.setFlatness:
	                this.setFlatness(args[0]);
	                break;

	              case _util.OPS.setGState:
	                this.setGState(args[0]);
	                break;

	              case _util.OPS.fill:
	                this.fill();
	                break;

	              case _util.OPS.eoFill:
	                this.eoFill();
	                break;

	              case _util.OPS.stroke:
	                this.stroke();
	                break;

	              case _util.OPS.fillStroke:
	                this.fillStroke();
	                break;

	              case _util.OPS.eoFillStroke:
	                this.eoFillStroke();
	                break;

	              case _util.OPS.clip:
	                this.clip("nonzero");
	                break;

	              case _util.OPS.eoClip:
	                this.clip("evenodd");
	                break;

	              case _util.OPS.paintSolidColorImageMask:
	                this.paintSolidColorImageMask();
	                break;

	              case _util.OPS.paintImageXObject:
	                this.paintImageXObject(args[0]);
	                break;

	              case _util.OPS.paintInlineImageXObject:
	                this.paintInlineImageXObject(args[0]);
	                break;

	              case _util.OPS.paintImageMaskXObject:
	                this.paintImageMaskXObject(args[0]);
	                break;

	              case _util.OPS.paintFormXObjectBegin:
	                this.paintFormXObjectBegin(args[0], args[1]);
	                break;

	              case _util.OPS.paintFormXObjectEnd:
	                this.paintFormXObjectEnd();
	                break;

	              case _util.OPS.closePath:
	                this.closePath();
	                break;

	              case _util.OPS.closeStroke:
	                this.closeStroke();
	                break;

	              case _util.OPS.closeFillStroke:
	                this.closeFillStroke();
	                break;

	              case _util.OPS.closeEOFillStroke:
	                this.closeEOFillStroke();
	                break;

	              case _util.OPS.nextLine:
	                this.nextLine();
	                break;

	              case _util.OPS.transform:
	                this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
	                break;

	              case _util.OPS.constructPath:
	                this.constructPath(args[0], args[1]);
	                break;

	              case _util.OPS.endPath:
	                this.endPath();
	                break;

	              case 92:
	                this.group(opTreeElement.items);
	                break;

	              default:
	                (0, _util.warn)("Unimplemented operator ".concat(fn));
	                break;
	            }
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }
	      }
	    }, {
	      key: "setWordSpacing",
	      value: function setWordSpacing(wordSpacing) {
	        this.current.wordSpacing = wordSpacing;
	      }
	    }, {
	      key: "setCharSpacing",
	      value: function setCharSpacing(charSpacing) {
	        this.current.charSpacing = charSpacing;
	      }
	    }, {
	      key: "nextLine",
	      value: function nextLine() {
	        this.moveText(0, this.current.leading);
	      }
	    }, {
	      key: "setTextMatrix",
	      value: function setTextMatrix(a, b, c, d, e, f) {
	        var current = this.current;
	        current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
	        current.textMatrixScale = Math.hypot(a, b);
	        current.x = current.lineX = 0;
	        current.y = current.lineY = 0;
	        current.xcoords = [];
	        current.ycoords = [];
	        current.tspan = this.svgFactory.createElement("svg:tspan");
	        current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
	        current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
	        current.tspan.setAttributeNS(null, "y", pf(-current.y));
	        current.txtElement = this.svgFactory.createElement("svg:text");
	        current.txtElement.appendChild(current.tspan);
	      }
	    }, {
	      key: "beginText",
	      value: function beginText() {
	        var current = this.current;
	        current.x = current.lineX = 0;
	        current.y = current.lineY = 0;
	        current.textMatrix = _util.IDENTITY_MATRIX;
	        current.lineMatrix = _util.IDENTITY_MATRIX;
	        current.textMatrixScale = 1;
	        current.tspan = this.svgFactory.createElement("svg:tspan");
	        current.txtElement = this.svgFactory.createElement("svg:text");
	        current.txtgrp = this.svgFactory.createElement("svg:g");
	        current.xcoords = [];
	        current.ycoords = [];
	      }
	    }, {
	      key: "moveText",
	      value: function moveText(x, y) {
	        var current = this.current;
	        current.x = current.lineX += x;
	        current.y = current.lineY += y;
	        current.xcoords = [];
	        current.ycoords = [];
	        current.tspan = this.svgFactory.createElement("svg:tspan");
	        current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
	        current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
	        current.tspan.setAttributeNS(null, "y", pf(-current.y));
	      }
	    }, {
	      key: "showText",
	      value: function showText(glyphs) {
	        var current = this.current;
	        var font = current.font;
	        var fontSize = current.fontSize;

	        if (fontSize === 0) {
	          return;
	        }

	        var fontSizeScale = current.fontSizeScale;
	        var charSpacing = current.charSpacing;
	        var wordSpacing = current.wordSpacing;
	        var fontDirection = current.fontDirection;
	        var textHScale = current.textHScale * fontDirection;
	        var vertical = font.vertical;
	        var spacingDir = vertical ? 1 : -1;
	        var defaultVMetrics = font.defaultVMetrics;
	        var widthAdvanceScale = fontSize * current.fontMatrix[0];
	        var x = 0;

	        var _iterator4 = _createForOfIteratorHelper(glyphs),
	            _step4;

	        try {
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var glyph = _step4.value;

	            if (glyph === null) {
	              x += fontDirection * wordSpacing;
	              continue;
	            } else if ((0, _util.isNum)(glyph)) {
	              x += spacingDir * glyph * fontSize / 1000;
	              continue;
	            }

	            var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
	            var character = glyph.fontChar;
	            var scaledX = void 0,
	                scaledY = void 0;
	            var width = glyph.width;

	            if (vertical) {
	              var vx = void 0;
	              var vmetric = glyph.vmetric || defaultVMetrics;
	              vx = glyph.vmetric ? vmetric[1] : width * 0.5;
	              vx = -vx * widthAdvanceScale;
	              var vy = vmetric[2] * widthAdvanceScale;
	              width = vmetric ? -vmetric[0] : width;
	              scaledX = vx / fontSizeScale;
	              scaledY = (x + vy) / fontSizeScale;
	            } else {
	              scaledX = x / fontSizeScale;
	              scaledY = 0;
	            }

	            if (glyph.isInFont || font.missingFile) {
	              current.xcoords.push(current.x + scaledX);

	              if (vertical) {
	                current.ycoords.push(-current.y + scaledY);
	              }

	              current.tspan.textContent += character;
	            } else {}

	            var charWidth = void 0;

	            if (vertical) {
	              charWidth = width * widthAdvanceScale - spacing * fontDirection;
	            } else {
	              charWidth = width * widthAdvanceScale + spacing * fontDirection;
	            }

	            x += charWidth;
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }

	        current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

	        if (vertical) {
	          current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
	        } else {
	          current.tspan.setAttributeNS(null, "y", pf(-current.y));
	        }

	        if (vertical) {
	          current.y -= x;
	        } else {
	          current.x += x * textHScale;
	        }

	        current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
	        current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));

	        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
	          current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
	        }

	        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
	          current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
	        }

	        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

	        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          if (current.fillColor !== SVG_DEFAULTS.fillColor) {
	            current.tspan.setAttributeNS(null, "fill", current.fillColor);
	          }

	          if (current.fillAlpha < 1) {
	            current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
	          }
	        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
	          current.tspan.setAttributeNS(null, "fill", "transparent");
	        } else {
	          current.tspan.setAttributeNS(null, "fill", "none");
	        }

	        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
	          var lineWidthScale = 1 / (current.textMatrixScale || 1);

	          this._setStrokeAttributes(current.tspan, lineWidthScale);
	        }

	        var textMatrix = current.textMatrix;

	        if (current.textRise !== 0) {
	          textMatrix = textMatrix.slice();
	          textMatrix[5] += current.textRise;
	        }

	        current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
	        current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
	        current.txtElement.appendChild(current.tspan);
	        current.txtgrp.appendChild(current.txtElement);

	        this._ensureTransformGroup().appendChild(current.txtElement);
	      }
	    }, {
	      key: "setLeadingMoveText",
	      value: function setLeadingMoveText(x, y) {
	        this.setLeading(-y);
	        this.moveText(x, y);
	      }
	    }, {
	      key: "addFontStyle",
	      value: function addFontStyle(fontObj) {
	        if (!fontObj.data) {
	          throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
	        }

	        if (!this.cssStyle) {
	          this.cssStyle = this.svgFactory.createElement("svg:style");
	          this.cssStyle.setAttributeNS(null, "type", "text/css");
	          this.defs.appendChild(this.cssStyle);
	        }

	        var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
	        this.cssStyle.textContent += "@font-face { font-family: \"".concat(fontObj.loadedName, "\";") + " src: url(".concat(url, "); }\n");
	      }
	    }, {
	      key: "setFont",
	      value: function setFont(details) {
	        var current = this.current;
	        var fontObj = this.commonObjs.get(details[0]);
	        var size = details[1];
	        current.font = fontObj;

	        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
	          this.addFontStyle(fontObj);
	          this.embeddedFonts[fontObj.loadedName] = fontObj;
	        }

	        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
	        var bold = "normal";

	        if (fontObj.black) {
	          bold = "900";
	        } else if (fontObj.bold) {
	          bold = "bold";
	        }

	        var italic = fontObj.italic ? "italic" : "normal";

	        if (size < 0) {
	          size = -size;
	          current.fontDirection = -1;
	        } else {
	          current.fontDirection = 1;
	        }

	        current.fontSize = size;
	        current.fontFamily = fontObj.loadedName;
	        current.fontWeight = bold;
	        current.fontStyle = italic;
	        current.tspan = this.svgFactory.createElement("svg:tspan");
	        current.tspan.setAttributeNS(null, "y", pf(-current.y));
	        current.xcoords = [];
	        current.ycoords = [];
	      }
	    }, {
	      key: "endText",
	      value: function endText() {
	        var _current$txtElement;

	        var current = this.current;

	        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
	          current.element = current.txtElement;
	          this.clip("nonzero");
	          this.endPath();
	        }
	      }
	    }, {
	      key: "setLineWidth",
	      value: function setLineWidth(width) {
	        if (width > 0) {
	          this.current.lineWidth = width;
	        }
	      }
	    }, {
	      key: "setLineCap",
	      value: function setLineCap(style) {
	        this.current.lineCap = LINE_CAP_STYLES[style];
	      }
	    }, {
	      key: "setLineJoin",
	      value: function setLineJoin(style) {
	        this.current.lineJoin = LINE_JOIN_STYLES[style];
	      }
	    }, {
	      key: "setMiterLimit",
	      value: function setMiterLimit(limit) {
	        this.current.miterLimit = limit;
	      }
	    }, {
	      key: "setStrokeAlpha",
	      value: function setStrokeAlpha(strokeAlpha) {
	        this.current.strokeAlpha = strokeAlpha;
	      }
	    }, {
	      key: "setStrokeRGBColor",
	      value: function setStrokeRGBColor(r, g, b) {
	        this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
	      }
	    }, {
	      key: "setFillAlpha",
	      value: function setFillAlpha(fillAlpha) {
	        this.current.fillAlpha = fillAlpha;
	      }
	    }, {
	      key: "setFillRGBColor",
	      value: function setFillRGBColor(r, g, b) {
	        this.current.fillColor = _util.Util.makeHexColor(r, g, b);
	        this.current.tspan = this.svgFactory.createElement("svg:tspan");
	        this.current.xcoords = [];
	        this.current.ycoords = [];
	      }
	    }, {
	      key: "setStrokeColorN",
	      value: function setStrokeColorN(args) {
	        this.current.strokeColor = this._makeColorN_Pattern(args);
	      }
	    }, {
	      key: "setFillColorN",
	      value: function setFillColorN(args) {
	        this.current.fillColor = this._makeColorN_Pattern(args);
	      }
	    }, {
	      key: "shadingFill",
	      value: function shadingFill(args) {
	        var width = this.viewport.width;
	        var height = this.viewport.height;

	        var inv = _util.Util.inverseTransform(this.transformMatrix);

	        var bl = _util.Util.applyTransform([0, 0], inv);

	        var br = _util.Util.applyTransform([0, height], inv);

	        var ul = _util.Util.applyTransform([width, 0], inv);

	        var ur = _util.Util.applyTransform([width, height], inv);

	        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
	        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
	        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
	        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
	        var rect = this.svgFactory.createElement("svg:rect");
	        rect.setAttributeNS(null, "x", x0);
	        rect.setAttributeNS(null, "y", y0);
	        rect.setAttributeNS(null, "width", x1 - x0);
	        rect.setAttributeNS(null, "height", y1 - y0);
	        rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

	        if (this.current.fillAlpha < 1) {
	          rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
	        }

	        this._ensureTransformGroup().appendChild(rect);
	      }
	    }, {
	      key: "_makeColorN_Pattern",
	      value: function _makeColorN_Pattern(args) {
	        if (args[0] === "TilingPattern") {
	          return this._makeTilingPattern(args);
	        }

	        return this._makeShadingPattern(args);
	      }
	    }, {
	      key: "_makeTilingPattern",
	      value: function _makeTilingPattern(args) {
	        var color = args[1];
	        var operatorList = args[2];
	        var matrix = args[3] || _util.IDENTITY_MATRIX;

	        var _args$ = _slicedToArray(args[4], 4),
	            x0 = _args$[0],
	            y0 = _args$[1],
	            x1 = _args$[2],
	            y1 = _args$[3];

	        var xstep = args[5];
	        var ystep = args[6];
	        var paintType = args[7];
	        var tilingId = "shading".concat(shadingCount++);

	        var _Util$normalizeRect = _util.Util.normalizeRect([].concat(_toConsumableArray(_util.Util.applyTransform([x0, y0], matrix)), _toConsumableArray(_util.Util.applyTransform([x1, y1], matrix)))),
	            _Util$normalizeRect2 = _slicedToArray(_Util$normalizeRect, 4),
	            tx0 = _Util$normalizeRect2[0],
	            ty0 = _Util$normalizeRect2[1],
	            tx1 = _Util$normalizeRect2[2],
	            ty1 = _Util$normalizeRect2[3];

	        var _Util$singularValueDe = _util.Util.singularValueDecompose2dScale(matrix),
	            _Util$singularValueDe2 = _slicedToArray(_Util$singularValueDe, 2),
	            xscale = _Util$singularValueDe2[0],
	            yscale = _Util$singularValueDe2[1];

	        var txstep = xstep * xscale;
	        var tystep = ystep * yscale;
	        var tiling = this.svgFactory.createElement("svg:pattern");
	        tiling.setAttributeNS(null, "id", tilingId);
	        tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
	        tiling.setAttributeNS(null, "width", txstep);
	        tiling.setAttributeNS(null, "height", tystep);
	        tiling.setAttributeNS(null, "x", "".concat(tx0));
	        tiling.setAttributeNS(null, "y", "".concat(ty0));
	        var svg = this.svg;
	        var transformMatrix = this.transformMatrix;
	        var fillColor = this.current.fillColor;
	        var strokeColor = this.current.strokeColor;
	        var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
	        this.svg = bbox;
	        this.transformMatrix = matrix;

	        if (paintType === 2) {
	          var cssColor = _util.Util.makeHexColor.apply(_util.Util, _toConsumableArray(color));

	          this.current.fillColor = cssColor;
	          this.current.strokeColor = cssColor;
	        }

	        this.executeOpTree(this.convertOpList(operatorList));
	        this.svg = svg;
	        this.transformMatrix = transformMatrix;
	        this.current.fillColor = fillColor;
	        this.current.strokeColor = strokeColor;
	        tiling.appendChild(bbox.childNodes[0]);
	        this.defs.appendChild(tiling);
	        return "url(#".concat(tilingId, ")");
	      }
	    }, {
	      key: "_makeShadingPattern",
	      value: function _makeShadingPattern(args) {
	        if (typeof args === "string") {
	          args = this.objs.get(args);
	        }

	        switch (args[0]) {
	          case "RadialAxial":
	            var shadingId = "shading".concat(shadingCount++);
	            var colorStops = args[3];
	            var gradient;

	            switch (args[1]) {
	              case "axial":
	                var point0 = args[4];
	                var point1 = args[5];
	                gradient = this.svgFactory.createElement("svg:linearGradient");
	                gradient.setAttributeNS(null, "id", shadingId);
	                gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
	                gradient.setAttributeNS(null, "x1", point0[0]);
	                gradient.setAttributeNS(null, "y1", point0[1]);
	                gradient.setAttributeNS(null, "x2", point1[0]);
	                gradient.setAttributeNS(null, "y2", point1[1]);
	                break;

	              case "radial":
	                var focalPoint = args[4];
	                var circlePoint = args[5];
	                var focalRadius = args[6];
	                var circleRadius = args[7];
	                gradient = this.svgFactory.createElement("svg:radialGradient");
	                gradient.setAttributeNS(null, "id", shadingId);
	                gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
	                gradient.setAttributeNS(null, "cx", circlePoint[0]);
	                gradient.setAttributeNS(null, "cy", circlePoint[1]);
	                gradient.setAttributeNS(null, "r", circleRadius);
	                gradient.setAttributeNS(null, "fx", focalPoint[0]);
	                gradient.setAttributeNS(null, "fy", focalPoint[1]);
	                gradient.setAttributeNS(null, "fr", focalRadius);
	                break;

	              default:
	                throw new Error("Unknown RadialAxial type: ".concat(args[1]));
	            }

	            var _iterator5 = _createForOfIteratorHelper(colorStops),
	                _step5;

	            try {
	              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	                var colorStop = _step5.value;
	                var stop = this.svgFactory.createElement("svg:stop");
	                stop.setAttributeNS(null, "offset", colorStop[0]);
	                stop.setAttributeNS(null, "stop-color", colorStop[1]);
	                gradient.appendChild(stop);
	              }
	            } catch (err) {
	              _iterator5.e(err);
	            } finally {
	              _iterator5.f();
	            }

	            this.defs.appendChild(gradient);
	            return "url(#".concat(shadingId, ")");

	          case "Mesh":
	            (0, _util.warn)("Unimplemented pattern Mesh");
	            return null;

	          case "Dummy":
	            return "hotpink";

	          default:
	            throw new Error("Unknown IR type: ".concat(args[0]));
	        }
	      }
	    }, {
	      key: "setDash",
	      value: function setDash(dashArray, dashPhase) {
	        this.current.dashArray = dashArray;
	        this.current.dashPhase = dashPhase;
	      }
	    }, {
	      key: "constructPath",
	      value: function constructPath(ops, args) {
	        var current = this.current;
	        var x = current.x,
	            y = current.y;
	        var d = [];
	        var j = 0;

	        var _iterator6 = _createForOfIteratorHelper(ops),
	            _step6;

	        try {
	          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	            var op = _step6.value;

	            switch (op | 0) {
	              case _util.OPS.rectangle:
	                x = args[j++];
	                y = args[j++];
	                var width = args[j++];
	                var height = args[j++];
	                var xw = x + width;
	                var yh = y + height;
	                d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
	                break;

	              case _util.OPS.moveTo:
	                x = args[j++];
	                y = args[j++];
	                d.push("M", pf(x), pf(y));
	                break;

	              case _util.OPS.lineTo:
	                x = args[j++];
	                y = args[j++];
	                d.push("L", pf(x), pf(y));
	                break;

	              case _util.OPS.curveTo:
	                x = args[j + 4];
	                y = args[j + 5];
	                d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
	                j += 6;
	                break;

	              case _util.OPS.curveTo2:
	                d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
	                x = args[j + 2];
	                y = args[j + 3];
	                j += 4;
	                break;

	              case _util.OPS.curveTo3:
	                x = args[j + 2];
	                y = args[j + 3];
	                d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
	                j += 4;
	                break;

	              case _util.OPS.closePath:
	                d.push("Z");
	                break;
	            }
	          }
	        } catch (err) {
	          _iterator6.e(err);
	        } finally {
	          _iterator6.f();
	        }

	        d = d.join(" ");

	        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
	          d = current.path.getAttributeNS(null, "d") + d;
	        } else {
	          current.path = this.svgFactory.createElement("svg:path");

	          this._ensureTransformGroup().appendChild(current.path);
	        }

	        current.path.setAttributeNS(null, "d", d);
	        current.path.setAttributeNS(null, "fill", "none");
	        current.element = current.path;
	        current.setCurrentPoint(x, y);
	      }
	    }, {
	      key: "endPath",
	      value: function endPath() {
	        var current = this.current;
	        current.path = null;

	        if (!this.pendingClip) {
	          return;
	        }

	        if (!current.element) {
	          this.pendingClip = null;
	          return;
	        }

	        var clipId = "clippath".concat(clipCount++);
	        var clipPath = this.svgFactory.createElement("svg:clipPath");
	        clipPath.setAttributeNS(null, "id", clipId);
	        clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
	        var clipElement = current.element.cloneNode(true);

	        if (this.pendingClip === "evenodd") {
	          clipElement.setAttributeNS(null, "clip-rule", "evenodd");
	        } else {
	          clipElement.setAttributeNS(null, "clip-rule", "nonzero");
	        }

	        this.pendingClip = null;
	        clipPath.appendChild(clipElement);
	        this.defs.appendChild(clipPath);

	        if (current.activeClipUrl) {
	          current.clipGroup = null;

	          var _iterator7 = _createForOfIteratorHelper(this.extraStack),
	              _step7;

	          try {
	            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	              var prev = _step7.value;
	              prev.clipGroup = null;
	            }
	          } catch (err) {
	            _iterator7.e(err);
	          } finally {
	            _iterator7.f();
	          }

	          clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
	        }

	        current.activeClipUrl = "url(#".concat(clipId, ")");
	        this.tgrp = null;
	      }
	    }, {
	      key: "clip",
	      value: function clip(type) {
	        this.pendingClip = type;
	      }
	    }, {
	      key: "closePath",
	      value: function closePath() {
	        var current = this.current;

	        if (current.path) {
	          var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
	          current.path.setAttributeNS(null, "d", d);
	        }
	      }
	    }, {
	      key: "setLeading",
	      value: function setLeading(leading) {
	        this.current.leading = -leading;
	      }
	    }, {
	      key: "setTextRise",
	      value: function setTextRise(textRise) {
	        this.current.textRise = textRise;
	      }
	    }, {
	      key: "setTextRenderingMode",
	      value: function setTextRenderingMode(textRenderingMode) {
	        this.current.textRenderingMode = textRenderingMode;
	      }
	    }, {
	      key: "setHScale",
	      value: function setHScale(scale) {
	        this.current.textHScale = scale / 100;
	      }
	    }, {
	      key: "setRenderingIntent",
	      value: function setRenderingIntent(intent) {}
	    }, {
	      key: "setFlatness",
	      value: function setFlatness(flatness) {}
	    }, {
	      key: "setGState",
	      value: function setGState(states) {
	        var _iterator8 = _createForOfIteratorHelper(states),
	            _step8;

	        try {
	          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
	            var _step8$value = _slicedToArray(_step8.value, 2),
	                key = _step8$value[0],
	                value = _step8$value[1];

	            switch (key) {
	              case "LW":
	                this.setLineWidth(value);
	                break;

	              case "LC":
	                this.setLineCap(value);
	                break;

	              case "LJ":
	                this.setLineJoin(value);
	                break;

	              case "ML":
	                this.setMiterLimit(value);
	                break;

	              case "D":
	                this.setDash(value[0], value[1]);
	                break;

	              case "RI":
	                this.setRenderingIntent(value);
	                break;

	              case "FL":
	                this.setFlatness(value);
	                break;

	              case "Font":
	                this.setFont(value);
	                break;

	              case "CA":
	                this.setStrokeAlpha(value);
	                break;

	              case "ca":
	                this.setFillAlpha(value);
	                break;

	              default:
	                (0, _util.warn)("Unimplemented graphic state operator ".concat(key));
	                break;
	            }
	          }
	        } catch (err) {
	          _iterator8.e(err);
	        } finally {
	          _iterator8.f();
	        }
	      }
	    }, {
	      key: "fill",
	      value: function fill() {
	        var current = this.current;

	        if (current.element) {
	          current.element.setAttributeNS(null, "fill", current.fillColor);
	          current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
	          this.endPath();
	        }
	      }
	    }, {
	      key: "stroke",
	      value: function stroke() {
	        var current = this.current;

	        if (current.element) {
	          this._setStrokeAttributes(current.element);

	          current.element.setAttributeNS(null, "fill", "none");
	          this.endPath();
	        }
	      }
	    }, {
	      key: "_setStrokeAttributes",
	      value: function _setStrokeAttributes(element) {
	        var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	        var current = this.current;
	        var dashArray = current.dashArray;

	        if (lineWidthScale !== 1 && dashArray.length > 0) {
	          dashArray = dashArray.map(function (value) {
	            return lineWidthScale * value;
	          });
	        }

	        element.setAttributeNS(null, "stroke", current.strokeColor);
	        element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
	        element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
	        element.setAttributeNS(null, "stroke-linecap", current.lineCap);
	        element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
	        element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
	        element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
	        element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
	      }
	    }, {
	      key: "eoFill",
	      value: function eoFill() {
	        if (this.current.element) {
	          this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
	        }

	        this.fill();
	      }
	    }, {
	      key: "fillStroke",
	      value: function fillStroke() {
	        this.stroke();
	        this.fill();
	      }
	    }, {
	      key: "eoFillStroke",
	      value: function eoFillStroke() {
	        if (this.current.element) {
	          this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
	        }

	        this.fillStroke();
	      }
	    }, {
	      key: "closeStroke",
	      value: function closeStroke() {
	        this.closePath();
	        this.stroke();
	      }
	    }, {
	      key: "closeFillStroke",
	      value: function closeFillStroke() {
	        this.closePath();
	        this.fillStroke();
	      }
	    }, {
	      key: "closeEOFillStroke",
	      value: function closeEOFillStroke() {
	        this.closePath();
	        this.eoFillStroke();
	      }
	    }, {
	      key: "paintSolidColorImageMask",
	      value: function paintSolidColorImageMask() {
	        var rect = this.svgFactory.createElement("svg:rect");
	        rect.setAttributeNS(null, "x", "0");
	        rect.setAttributeNS(null, "y", "0");
	        rect.setAttributeNS(null, "width", "1px");
	        rect.setAttributeNS(null, "height", "1px");
	        rect.setAttributeNS(null, "fill", this.current.fillColor);

	        this._ensureTransformGroup().appendChild(rect);
	      }
	    }, {
	      key: "paintImageXObject",
	      value: function paintImageXObject(objId) {
	        var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

	        if (!imgData) {
	          (0, _util.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
	          return;
	        }

	        this.paintInlineImageXObject(imgData);
	      }
	    }, {
	      key: "paintInlineImageXObject",
	      value: function paintInlineImageXObject(imgData, mask) {
	        var width = imgData.width;
	        var height = imgData.height;
	        var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
	        var cliprect = this.svgFactory.createElement("svg:rect");
	        cliprect.setAttributeNS(null, "x", "0");
	        cliprect.setAttributeNS(null, "y", "0");
	        cliprect.setAttributeNS(null, "width", pf(width));
	        cliprect.setAttributeNS(null, "height", pf(height));
	        this.current.element = cliprect;
	        this.clip("nonzero");
	        var imgEl = this.svgFactory.createElement("svg:image");
	        imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
	        imgEl.setAttributeNS(null, "x", "0");
	        imgEl.setAttributeNS(null, "y", pf(-height));
	        imgEl.setAttributeNS(null, "width", pf(width) + "px");
	        imgEl.setAttributeNS(null, "height", pf(height) + "px");
	        imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));

	        if (mask) {
	          mask.appendChild(imgEl);
	        } else {
	          this._ensureTransformGroup().appendChild(imgEl);
	        }
	      }
	    }, {
	      key: "paintImageMaskXObject",
	      value: function paintImageMaskXObject(imgData) {
	        var current = this.current;
	        var width = imgData.width;
	        var height = imgData.height;
	        var fillColor = current.fillColor;
	        current.maskId = "mask".concat(maskCount++);
	        var mask = this.svgFactory.createElement("svg:mask");
	        mask.setAttributeNS(null, "id", current.maskId);
	        var rect = this.svgFactory.createElement("svg:rect");
	        rect.setAttributeNS(null, "x", "0");
	        rect.setAttributeNS(null, "y", "0");
	        rect.setAttributeNS(null, "width", pf(width));
	        rect.setAttributeNS(null, "height", pf(height));
	        rect.setAttributeNS(null, "fill", fillColor);
	        rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
	        this.defs.appendChild(mask);

	        this._ensureTransformGroup().appendChild(rect);

	        this.paintInlineImageXObject(imgData, mask);
	      }
	    }, {
	      key: "paintFormXObjectBegin",
	      value: function paintFormXObjectBegin(matrix, bbox) {
	        if (Array.isArray(matrix) && matrix.length === 6) {
	          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
	        }

	        if (bbox) {
	          var width = bbox[2] - bbox[0];
	          var height = bbox[3] - bbox[1];
	          var cliprect = this.svgFactory.createElement("svg:rect");
	          cliprect.setAttributeNS(null, "x", bbox[0]);
	          cliprect.setAttributeNS(null, "y", bbox[1]);
	          cliprect.setAttributeNS(null, "width", pf(width));
	          cliprect.setAttributeNS(null, "height", pf(height));
	          this.current.element = cliprect;
	          this.clip("nonzero");
	          this.endPath();
	        }
	      }
	    }, {
	      key: "paintFormXObjectEnd",
	      value: function paintFormXObjectEnd() {}
	    }, {
	      key: "_initialize",
	      value: function _initialize(viewport) {
	        var svg = this.svgFactory.create(viewport.width, viewport.height);
	        var definitions = this.svgFactory.createElement("svg:defs");
	        svg.appendChild(definitions);
	        this.defs = definitions;
	        var rootGroup = this.svgFactory.createElement("svg:g");
	        rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
	        svg.appendChild(rootGroup);
	        this.svg = rootGroup;
	        return svg;
	      }
	    }, {
	      key: "_ensureClipGroup",
	      value: function _ensureClipGroup() {
	        if (!this.current.clipGroup) {
	          var clipGroup = this.svgFactory.createElement("svg:g");
	          clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
	          this.svg.appendChild(clipGroup);
	          this.current.clipGroup = clipGroup;
	        }

	        return this.current.clipGroup;
	      }
	    }, {
	      key: "_ensureTransformGroup",
	      value: function _ensureTransformGroup() {
	        if (!this.tgrp) {
	          this.tgrp = this.svgFactory.createElement("svg:g");
	          this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

	          if (this.current.activeClipUrl) {
	            this._ensureClipGroup().appendChild(this.tgrp);
	          } else {
	            this.svg.appendChild(this.tgrp);
	          }
	        }

	        return this.tgrp;
	      }
	    }]);

	    return SVGGraphics;
	  }();
	}

	/***/ }),
	/* 153 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFNodeStream = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	var _network_utils = __w_pdfjs_require__(154);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var fs = require$$0;

	var http = require$$0;

	var https = require$$0;

	var url = require$$0;

	var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

	function parseUrl(sourceUrl) {
	  var parsedUrl = url.parse(sourceUrl);

	  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
	    return parsedUrl;
	  }

	  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
	    return url.parse("file:///".concat(sourceUrl));
	  }

	  if (!parsedUrl.host) {
	    parsedUrl.protocol = "file:";
	  }

	  return parsedUrl;
	}

	var PDFNodeStream = /*#__PURE__*/function () {
	  function PDFNodeStream(source) {
	    _classCallCheck(this, PDFNodeStream);

	    this.source = source;
	    this.url = parseUrl(source.url);
	    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
	    this.isFsUrl = this.url.protocol === "file:";
	    this.httpHeaders = this.isHttp && source.httpHeaders || {};
	    this._fullRequestReader = null;
	    this._rangeRequestReaders = [];
	  }

	  _createClass(PDFNodeStream, [{
	    key: "_progressiveDataLength",
	    get: function get() {
	      var _this$_fullRequestRea, _this$_fullRequestRea2;

	      return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
	    }
	  }, {
	    key: "getFullReader",
	    value: function getFullReader() {
	      (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
	      this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
	      return this._fullRequestReader;
	    }
	  }, {
	    key: "getRangeReader",
	    value: function getRangeReader(start, end) {
	      if (end <= this._progressiveDataLength) {
	        return null;
	      }

	      var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

	      this._rangeRequestReaders.push(rangeReader);

	      return rangeReader;
	    }
	  }, {
	    key: "cancelAllRequests",
	    value: function cancelAllRequests(reason) {
	      if (this._fullRequestReader) {
	        this._fullRequestReader.cancel(reason);
	      }

	      var _iterator = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var reader = _step.value;
	          reader.cancel(reason);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    }
	  }]);

	  return PDFNodeStream;
	}();

	exports.PDFNodeStream = PDFNodeStream;

	var BaseFullReader = /*#__PURE__*/function () {
	  function BaseFullReader(stream) {
	    _classCallCheck(this, BaseFullReader);

	    this._url = stream.url;
	    this._done = false;
	    this._storedError = null;
	    this.onProgress = null;
	    var source = stream.source;
	    this._contentLength = source.length;
	    this._loaded = 0;
	    this._filename = null;
	    this._disableRange = source.disableRange || false;
	    this._rangeChunkSize = source.rangeChunkSize;

	    if (!this._rangeChunkSize && !this._disableRange) {
	      this._disableRange = true;
	    }

	    this._isStreamingSupported = !source.disableStream;
	    this._isRangeSupported = !source.disableRange;
	    this._readableStream = null;
	    this._readCapability = (0, _util.createPromiseCapability)();
	    this._headersCapability = (0, _util.createPromiseCapability)();
	  }

	  _createClass(BaseFullReader, [{
	    key: "headersReady",
	    get: function get() {
	      return this._headersCapability.promise;
	    }
	  }, {
	    key: "filename",
	    get: function get() {
	      return this._filename;
	    }
	  }, {
	    key: "contentLength",
	    get: function get() {
	      return this._contentLength;
	    }
	  }, {
	    key: "isRangeSupported",
	    get: function get() {
	      return this._isRangeSupported;
	    }
	  }, {
	    key: "isStreamingSupported",
	    get: function get() {
	      return this._isStreamingSupported;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
	        var chunk, buffer;
	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return this._readCapability.promise;

	              case 2:
	                if (!this._done) {
	                  _context.next = 4;
	                  break;
	                }

	                return _context.abrupt("return", {
	                  value: undefined,
	                  done: true
	                });

	              case 4:
	                if (!this._storedError) {
	                  _context.next = 6;
	                  break;
	                }

	                throw this._storedError;

	              case 6:
	                chunk = this._readableStream.read();

	                if (!(chunk === null)) {
	                  _context.next = 10;
	                  break;
	                }

	                this._readCapability = (0, _util.createPromiseCapability)();
	                return _context.abrupt("return", this.read());

	              case 10:
	                this._loaded += chunk.length;

	                if (this.onProgress) {
	                  this.onProgress({
	                    loaded: this._loaded,
	                    total: this._contentLength
	                  });
	                }

	                buffer = new Uint8Array(chunk).buffer;
	                return _context.abrupt("return", {
	                  value: buffer,
	                  done: false
	                });

	              case 14:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function read() {
	        return _read.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      if (!this._readableStream) {
	        this._error(reason);

	        return;
	      }

	      this._readableStream.destroy(reason);
	    }
	  }, {
	    key: "_error",
	    value: function _error(reason) {
	      this._storedError = reason;

	      this._readCapability.resolve();
	    }
	  }, {
	    key: "_setReadableStream",
	    value: function _setReadableStream(readableStream) {
	      var _this = this;

	      this._readableStream = readableStream;
	      readableStream.on("readable", function () {
	        _this._readCapability.resolve();
	      });
	      readableStream.on("end", function () {
	        readableStream.destroy();
	        _this._done = true;

	        _this._readCapability.resolve();
	      });
	      readableStream.on("error", function (reason) {
	        _this._error(reason);
	      });

	      if (!this._isStreamingSupported && this._isRangeSupported) {
	        this._error(new _util.AbortException("streaming is disabled"));
	      }

	      if (this._storedError) {
	        this._readableStream.destroy(this._storedError);
	      }
	    }
	  }]);

	  return BaseFullReader;
	}();

	var BaseRangeReader = /*#__PURE__*/function () {
	  function BaseRangeReader(stream) {
	    _classCallCheck(this, BaseRangeReader);

	    this._url = stream.url;
	    this._done = false;
	    this._storedError = null;
	    this.onProgress = null;
	    this._loaded = 0;
	    this._readableStream = null;
	    this._readCapability = (0, _util.createPromiseCapability)();
	    var source = stream.source;
	    this._isStreamingSupported = !source.disableStream;
	  }

	  _createClass(BaseRangeReader, [{
	    key: "isStreamingSupported",
	    get: function get() {
	      return this._isStreamingSupported;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
	        var chunk, buffer;
	        return _regenerator["default"].wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return this._readCapability.promise;

	              case 2:
	                if (!this._done) {
	                  _context2.next = 4;
	                  break;
	                }

	                return _context2.abrupt("return", {
	                  value: undefined,
	                  done: true
	                });

	              case 4:
	                if (!this._storedError) {
	                  _context2.next = 6;
	                  break;
	                }

	                throw this._storedError;

	              case 6:
	                chunk = this._readableStream.read();

	                if (!(chunk === null)) {
	                  _context2.next = 10;
	                  break;
	                }

	                this._readCapability = (0, _util.createPromiseCapability)();
	                return _context2.abrupt("return", this.read());

	              case 10:
	                this._loaded += chunk.length;

	                if (this.onProgress) {
	                  this.onProgress({
	                    loaded: this._loaded
	                  });
	                }

	                buffer = new Uint8Array(chunk).buffer;
	                return _context2.abrupt("return", {
	                  value: buffer,
	                  done: false
	                });

	              case 14:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function read() {
	        return _read2.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      if (!this._readableStream) {
	        this._error(reason);

	        return;
	      }

	      this._readableStream.destroy(reason);
	    }
	  }, {
	    key: "_error",
	    value: function _error(reason) {
	      this._storedError = reason;

	      this._readCapability.resolve();
	    }
	  }, {
	    key: "_setReadableStream",
	    value: function _setReadableStream(readableStream) {
	      var _this2 = this;

	      this._readableStream = readableStream;
	      readableStream.on("readable", function () {
	        _this2._readCapability.resolve();
	      });
	      readableStream.on("end", function () {
	        readableStream.destroy();
	        _this2._done = true;

	        _this2._readCapability.resolve();
	      });
	      readableStream.on("error", function (reason) {
	        _this2._error(reason);
	      });

	      if (this._storedError) {
	        this._readableStream.destroy(this._storedError);
	      }
	    }
	  }]);

	  return BaseRangeReader;
	}();

	function createRequestOptions(parsedUrl, headers) {
	  return {
	    protocol: parsedUrl.protocol,
	    auth: parsedUrl.auth,
	    host: parsedUrl.hostname,
	    port: parsedUrl.port,
	    path: parsedUrl.path,
	    method: "GET",
	    headers: headers
	  };
	}

	var PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {
	  _inherits(PDFNodeStreamFullReader, _BaseFullReader);

	  var _super = _createSuper(PDFNodeStreamFullReader);

	  function PDFNodeStreamFullReader(stream) {
	    var _this3;

	    _classCallCheck(this, PDFNodeStreamFullReader);

	    _this3 = _super.call(this, stream);

	    var handleResponse = function handleResponse(response) {
	      if (response.statusCode === 404) {
	        var error = new _util.MissingPDFException("Missing PDF \"".concat(_this3._url, "\"."));
	        _this3._storedError = error;

	        _this3._headersCapability.reject(error);

	        return;
	      }

	      _this3._headersCapability.resolve();

	      _this3._setReadableStream(response);

	      var getResponseHeader = function getResponseHeader(name) {
	        return _this3._readableStream.headers[name.toLowerCase()];
	      };

	      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
	        getResponseHeader: getResponseHeader,
	        isHttp: stream.isHttp,
	        rangeChunkSize: _this3._rangeChunkSize,
	        disableRange: _this3._disableRange
	      }),
	          allowRangeRequests = _validateRangeRequest.allowRangeRequests,
	          suggestedLength = _validateRangeRequest.suggestedLength;

	      _this3._isRangeSupported = allowRangeRequests;
	      _this3._contentLength = suggestedLength || _this3._contentLength;
	      _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
	    };

	    _this3._request = null;

	    if (_this3._url.protocol === "http:") {
	      _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
	    } else {
	      _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
	    }

	    _this3._request.on("error", function (reason) {
	      _this3._storedError = reason;

	      _this3._headersCapability.reject(reason);
	    });

	    _this3._request.end();

	    return _this3;
	  }

	  return PDFNodeStreamFullReader;
	}(BaseFullReader);

	var PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {
	  _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);

	  var _super2 = _createSuper(PDFNodeStreamRangeReader);

	  function PDFNodeStreamRangeReader(stream, start, end) {
	    var _this4;

	    _classCallCheck(this, PDFNodeStreamRangeReader);

	    _this4 = _super2.call(this, stream);
	    _this4._httpHeaders = {};

	    for (var property in stream.httpHeaders) {
	      var value = stream.httpHeaders[property];

	      if (typeof value === "undefined") {
	        continue;
	      }

	      _this4._httpHeaders[property] = value;
	    }

	    _this4._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1);

	    var handleResponse = function handleResponse(response) {
	      if (response.statusCode === 404) {
	        var error = new _util.MissingPDFException("Missing PDF \"".concat(_this4._url, "\"."));
	        _this4._storedError = error;
	        return;
	      }

	      _this4._setReadableStream(response);
	    };

	    _this4._request = null;

	    if (_this4._url.protocol === "http:") {
	      _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
	    } else {
	      _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
	    }

	    _this4._request.on("error", function (reason) {
	      _this4._storedError = reason;
	    });

	    _this4._request.end();

	    return _this4;
	  }

	  return PDFNodeStreamRangeReader;
	}(BaseRangeReader);

	var PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {
	  _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);

	  var _super3 = _createSuper(PDFNodeStreamFsFullReader);

	  function PDFNodeStreamFsFullReader(stream) {
	    var _this5;

	    _classCallCheck(this, PDFNodeStreamFsFullReader);

	    _this5 = _super3.call(this, stream);
	    var path = decodeURIComponent(_this5._url.path);

	    if (fileUriRegex.test(_this5._url.href)) {
	      path = path.replace(/^\//, "");
	    }

	    fs.lstat(path, function (error, stat) {
	      if (error) {
	        if (error.code === "ENOENT") {
	          error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\"."));
	        }

	        _this5._storedError = error;

	        _this5._headersCapability.reject(error);

	        return;
	      }

	      _this5._contentLength = stat.size;

	      _this5._setReadableStream(fs.createReadStream(path));

	      _this5._headersCapability.resolve();
	    });
	    return _this5;
	  }

	  return PDFNodeStreamFsFullReader;
	}(BaseFullReader);

	var PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {
	  _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);

	  var _super4 = _createSuper(PDFNodeStreamFsRangeReader);

	  function PDFNodeStreamFsRangeReader(stream, start, end) {
	    var _this6;

	    _classCallCheck(this, PDFNodeStreamFsRangeReader);

	    _this6 = _super4.call(this, stream);
	    var path = decodeURIComponent(_this6._url.path);

	    if (fileUriRegex.test(_this6._url.href)) {
	      path = path.replace(/^\//, "");
	    }

	    _this6._setReadableStream(fs.createReadStream(path, {
	      start: start,
	      end: end - 1
	    }));

	    return _this6;
	  }

	  return PDFNodeStreamFsRangeReader;
	}(BaseRangeReader);

	/***/ }),
	/* 154 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.createResponseStatusError = createResponseStatusError;
	exports.extractFilenameFromHeader = extractFilenameFromHeader;
	exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
	exports.validateResponseStatus = validateResponseStatus;

	var _util = __w_pdfjs_require__(4);

	var _content_disposition = __w_pdfjs_require__(155);

	var _display_utils = __w_pdfjs_require__(1);

	function validateRangeRequestCapabilities(_ref) {
	  var getResponseHeader = _ref.getResponseHeader,
	      isHttp = _ref.isHttp,
	      rangeChunkSize = _ref.rangeChunkSize,
	      disableRange = _ref.disableRange;
	  (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
	  var returnValues = {
	    allowRangeRequests: false,
	    suggestedLength: undefined
	  };
	  var length = parseInt(getResponseHeader("Content-Length"), 10);

	  if (!Number.isInteger(length)) {
	    return returnValues;
	  }

	  returnValues.suggestedLength = length;

	  if (length <= 2 * rangeChunkSize) {
	    return returnValues;
	  }

	  if (disableRange || !isHttp) {
	    return returnValues;
	  }

	  if (getResponseHeader("Accept-Ranges") !== "bytes") {
	    return returnValues;
	  }

	  var contentEncoding = getResponseHeader("Content-Encoding") || "identity";

	  if (contentEncoding !== "identity") {
	    return returnValues;
	  }

	  returnValues.allowRangeRequests = true;
	  return returnValues;
	}

	function extractFilenameFromHeader(getResponseHeader) {
	  var contentDisposition = getResponseHeader("Content-Disposition");

	  if (contentDisposition) {
	    var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

	    if (filename.includes("%")) {
	      try {
	        filename = decodeURIComponent(filename);
	      } catch (ex) {}
	    }

	    if ((0, _display_utils.isPdfFile)(filename)) {
	      return filename;
	    }
	  }

	  return null;
	}

	function createResponseStatusError(status, url) {
	  if (status === 404 || status === 0 && url.startsWith("file:")) {
	    return new _util.MissingPDFException('Missing PDF "' + url + '".');
	  }

	  return new _util.UnexpectedResponseException("Unexpected server response (".concat(status, ") while retrieving PDF \"").concat(url, "\"."), status);
	}

	function validateResponseStatus(status) {
	  return status === 200 || status === 206;
	}

	/***/ }),
	/* 155 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

	var _util = __w_pdfjs_require__(4);

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function getFilenameFromContentDispositionHeader(contentDisposition) {
	  var needsEncodingFixup = true;
	  var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

	  if (tmp) {
	    tmp = tmp[1];
	    var filename = rfc2616unquote(tmp);
	    filename = unescape(filename);
	    filename = rfc5987decode(filename);
	    filename = rfc2047decode(filename);
	    return fixupEncoding(filename);
	  }

	  tmp = rfc2231getparam(contentDisposition);

	  if (tmp) {
	    var _filename = rfc2047decode(tmp);

	    return fixupEncoding(_filename);
	  }

	  tmp = toParamRegExp("filename", "i").exec(contentDisposition);

	  if (tmp) {
	    tmp = tmp[1];

	    var _filename2 = rfc2616unquote(tmp);

	    _filename2 = rfc2047decode(_filename2);
	    return fixupEncoding(_filename2);
	  }

	  function toParamRegExp(attributePattern, flags) {
	    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
	  }

	  function textdecode(encoding, value) {
	    if (encoding) {
	      if (!/^[\x00-\xFF]+$/.test(value)) {
	        return value;
	      }

	      try {
	        var decoder = new TextDecoder(encoding, {
	          fatal: true
	        });
	        var buffer = (0, _util.stringToBytes)(value);
	        value = decoder.decode(buffer);
	        needsEncodingFixup = false;
	      } catch (e) {
	        if (/^utf-?8$/i.test(encoding)) {
	          try {
	            value = decodeURIComponent(escape(value));
	            needsEncodingFixup = false;
	          } catch (err) {}
	        }
	      }
	    }

	    return value;
	  }

	  function fixupEncoding(value) {
	    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
	      value = textdecode("utf-8", value);

	      if (needsEncodingFixup) {
	        value = textdecode("iso-8859-1", value);
	      }
	    }

	    return value;
	  }

	  function rfc2231getparam(contentDispositionStr) {
	    var matches = [];
	    var match;
	    var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

	    while ((match = iter.exec(contentDispositionStr)) !== null) {
	      var _match = match,
	          _match2 = _slicedToArray(_match, 4),
	          n = _match2[1],
	          quot = _match2[2],
	          part = _match2[3];

	      n = parseInt(n, 10);

	      if (n in matches) {
	        if (n === 0) {
	          break;
	        }

	        continue;
	      }

	      matches[n] = [quot, part];
	    }

	    var parts = [];

	    for (var _n2 = 0; _n2 < matches.length; ++_n2) {
	      if (!(_n2 in matches)) {
	        break;
	      }

	      var _matches$_n = _slicedToArray(matches[_n2], 2),
	          _quot = _matches$_n[0],
	          _part = _matches$_n[1];

	      _part = rfc2616unquote(_part);

	      if (_quot) {
	        _part = unescape(_part);

	        if (_n2 === 0) {
	          _part = rfc5987decode(_part);
	        }
	      }

	      parts.push(_part);
	    }

	    return parts.join("");
	  }

	  function rfc2616unquote(value) {
	    if (value.startsWith('"')) {
	      var parts = value.slice(1).split('\\"');

	      for (var i = 0; i < parts.length; ++i) {
	        var quotindex = parts[i].indexOf('"');

	        if (quotindex !== -1) {
	          parts[i] = parts[i].slice(0, quotindex);
	          parts.length = i + 1;
	        }

	        parts[i] = parts[i].replace(/\\(.)/g, "$1");
	      }

	      value = parts.join('"');
	    }

	    return value;
	  }

	  function rfc5987decode(extvalue) {
	    var encodingend = extvalue.indexOf("'");

	    if (encodingend === -1) {
	      return extvalue;
	    }

	    var encoding = extvalue.slice(0, encodingend);
	    var langvalue = extvalue.slice(encodingend + 1);
	    var value = langvalue.replace(/^[^']*'/, "");
	    return textdecode(encoding, value);
	  }

	  function rfc2047decode(value) {
	    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
	      return value;
	    }

	    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
	      if (encoding === "q" || encoding === "Q") {
	        text = text.replace(/_/g, " ");
	        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
	          return String.fromCharCode(parseInt(hex, 16));
	        });
	        return textdecode(charset, text);
	      }

	      try {
	        text = atob(text);
	      } catch (e) {}

	      return textdecode(charset, text);
	    });
	  }

	  return "";
	}

	/***/ }),
	/* 156 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFNetworkStream = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	var _network_utils = __w_pdfjs_require__(154);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
	var OK_RESPONSE = 200;
	var PARTIAL_CONTENT_RESPONSE = 206;

	function getArrayBuffer(xhr) {
	  var data = xhr.response;

	  if (typeof data !== "string") {
	    return data;
	  }

	  var array = (0, _util.stringToBytes)(data);
	  return array.buffer;
	}

	var NetworkManager = /*#__PURE__*/function () {
	  function NetworkManager(url) {
	    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, NetworkManager);

	    this.url = url;
	    this.isHttp = /^https?:/i.test(url);
	    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
	    this.withCredentials = args.withCredentials || false;

	    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
	      return new XMLHttpRequest();
	    };

	    this.currXhrId = 0;
	    this.pendingRequests = Object.create(null);
	  }

	  _createClass(NetworkManager, [{
	    key: "requestRange",
	    value: function requestRange(begin, end, listeners) {
	      var args = {
	        begin: begin,
	        end: end
	      };

	      for (var prop in listeners) {
	        args[prop] = listeners[prop];
	      }

	      return this.request(args);
	    }
	  }, {
	    key: "requestFull",
	    value: function requestFull(listeners) {
	      return this.request(listeners);
	    }
	  }, {
	    key: "request",
	    value: function request(args) {
	      var xhr = this.getXhr();
	      var xhrId = this.currXhrId++;
	      var pendingRequest = this.pendingRequests[xhrId] = {
	        xhr: xhr
	      };
	      xhr.open("GET", this.url);
	      xhr.withCredentials = this.withCredentials;

	      for (var property in this.httpHeaders) {
	        var value = this.httpHeaders[property];

	        if (typeof value === "undefined") {
	          continue;
	        }

	        xhr.setRequestHeader(property, value);
	      }

	      if (this.isHttp && "begin" in args && "end" in args) {
	        xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
	        pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
	      } else {
	        pendingRequest.expectedStatus = OK_RESPONSE;
	      }

	      xhr.responseType = "arraybuffer";

	      if (args.onError) {
	        xhr.onerror = function (evt) {
	          args.onError(xhr.status);
	        };
	      }

	      xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
	      xhr.onprogress = this.onProgress.bind(this, xhrId);
	      pendingRequest.onHeadersReceived = args.onHeadersReceived;
	      pendingRequest.onDone = args.onDone;
	      pendingRequest.onError = args.onError;
	      pendingRequest.onProgress = args.onProgress;
	      xhr.send(null);
	      return xhrId;
	    }
	  }, {
	    key: "onProgress",
	    value: function onProgress(xhrId, evt) {
	      var _pendingRequest$onPro;

	      var pendingRequest = this.pendingRequests[xhrId];

	      if (!pendingRequest) {
	        return;
	      }

	      (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
	    }
	  }, {
	    key: "onStateChange",
	    value: function onStateChange(xhrId, evt) {
	      var pendingRequest = this.pendingRequests[xhrId];

	      if (!pendingRequest) {
	        return;
	      }

	      var xhr = pendingRequest.xhr;

	      if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
	        pendingRequest.onHeadersReceived();
	        delete pendingRequest.onHeadersReceived;
	      }

	      if (xhr.readyState !== 4) {
	        return;
	      }

	      if (!(xhrId in this.pendingRequests)) {
	        return;
	      }

	      delete this.pendingRequests[xhrId];

	      if (xhr.status === 0 && this.isHttp) {
	        var _pendingRequest$onErr;

	        (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
	        return;
	      }

	      var xhrStatus = xhr.status || OK_RESPONSE;
	      var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

	      if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
	        var _pendingRequest$onErr2;

	        (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
	        return;
	      }

	      var chunk = getArrayBuffer(xhr);

	      if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
	        var rangeHeader = xhr.getResponseHeader("Content-Range");
	        var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
	        pendingRequest.onDone({
	          begin: parseInt(matches[1], 10),
	          chunk: chunk
	        });
	      } else if (chunk) {
	        pendingRequest.onDone({
	          begin: 0,
	          chunk: chunk
	        });
	      } else {
	        var _pendingRequest$onErr3;

	        (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
	      }
	    }
	  }, {
	    key: "getRequestXhr",
	    value: function getRequestXhr(xhrId) {
	      return this.pendingRequests[xhrId].xhr;
	    }
	  }, {
	    key: "isPendingRequest",
	    value: function isPendingRequest(xhrId) {
	      return xhrId in this.pendingRequests;
	    }
	  }, {
	    key: "abortRequest",
	    value: function abortRequest(xhrId) {
	      var xhr = this.pendingRequests[xhrId].xhr;
	      delete this.pendingRequests[xhrId];
	      xhr.abort();
	    }
	  }]);

	  return NetworkManager;
	}();

	var PDFNetworkStream = /*#__PURE__*/function () {
	  function PDFNetworkStream(source) {
	    _classCallCheck(this, PDFNetworkStream);

	    this._source = source;
	    this._manager = new NetworkManager(source.url, {
	      httpHeaders: source.httpHeaders,
	      withCredentials: source.withCredentials
	    });
	    this._rangeChunkSize = source.rangeChunkSize;
	    this._fullRequestReader = null;
	    this._rangeRequestReaders = [];
	  }

	  _createClass(PDFNetworkStream, [{
	    key: "_onRangeRequestReaderClosed",
	    value: function _onRangeRequestReaderClosed(reader) {
	      var i = this._rangeRequestReaders.indexOf(reader);

	      if (i >= 0) {
	        this._rangeRequestReaders.splice(i, 1);
	      }
	    }
	  }, {
	    key: "getFullReader",
	    value: function getFullReader() {
	      (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
	      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
	      return this._fullRequestReader;
	    }
	  }, {
	    key: "getRangeReader",
	    value: function getRangeReader(begin, end) {
	      var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
	      reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

	      this._rangeRequestReaders.push(reader);

	      return reader;
	    }
	  }, {
	    key: "cancelAllRequests",
	    value: function cancelAllRequests(reason) {
	      var _this$_fullRequestRea;

	      (_this$_fullRequestRea = this._fullRequestReader) === null || _this$_fullRequestRea === void 0 ? void 0 : _this$_fullRequestRea.cancel(reason);

	      var _iterator = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var reader = _step.value;
	          reader.cancel(reason);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    }
	  }]);

	  return PDFNetworkStream;
	}();

	exports.PDFNetworkStream = PDFNetworkStream;

	var PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {
	  function PDFNetworkStreamFullRequestReader(manager, source) {
	    _classCallCheck(this, PDFNetworkStreamFullRequestReader);

	    this._manager = manager;
	    var args = {
	      onHeadersReceived: this._onHeadersReceived.bind(this),
	      onDone: this._onDone.bind(this),
	      onError: this._onError.bind(this),
	      onProgress: this._onProgress.bind(this)
	    };
	    this._url = source.url;
	    this._fullRequestId = manager.requestFull(args);
	    this._headersReceivedCapability = (0, _util.createPromiseCapability)();
	    this._disableRange = source.disableRange || false;
	    this._contentLength = source.length;
	    this._rangeChunkSize = source.rangeChunkSize;

	    if (!this._rangeChunkSize && !this._disableRange) {
	      this._disableRange = true;
	    }

	    this._isStreamingSupported = false;
	    this._isRangeSupported = false;
	    this._cachedChunks = [];
	    this._requests = [];
	    this._done = false;
	    this._storedError = undefined;
	    this._filename = null;
	    this.onProgress = null;
	  }

	  _createClass(PDFNetworkStreamFullRequestReader, [{
	    key: "_onHeadersReceived",
	    value: function _onHeadersReceived() {
	      var fullRequestXhrId = this._fullRequestId;

	      var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

	      var getResponseHeader = function getResponseHeader(name) {
	        return fullRequestXhr.getResponseHeader(name);
	      };

	      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
	        getResponseHeader: getResponseHeader,
	        isHttp: this._manager.isHttp,
	        rangeChunkSize: this._rangeChunkSize,
	        disableRange: this._disableRange
	      }),
	          allowRangeRequests = _validateRangeRequest.allowRangeRequests,
	          suggestedLength = _validateRangeRequest.suggestedLength;

	      if (allowRangeRequests) {
	        this._isRangeSupported = true;
	      }

	      this._contentLength = suggestedLength || this._contentLength;
	      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

	      if (this._isRangeSupported) {
	        this._manager.abortRequest(fullRequestXhrId);
	      }

	      this._headersReceivedCapability.resolve();
	    }
	  }, {
	    key: "_onDone",
	    value: function _onDone(data) {
	      if (data) {
	        if (this._requests.length > 0) {
	          var requestCapability = this._requests.shift();

	          requestCapability.resolve({
	            value: data.chunk,
	            done: false
	          });
	        } else {
	          this._cachedChunks.push(data.chunk);
	        }
	      }

	      this._done = true;

	      if (this._cachedChunks.length > 0) {
	        return;
	      }

	      var _iterator2 = _createForOfIteratorHelper(this._requests),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _requestCapability = _step2.value;

	          _requestCapability.resolve({
	            value: undefined,
	            done: true
	          });
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      this._requests.length = 0;
	    }
	  }, {
	    key: "_onError",
	    value: function _onError(status) {
	      this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

	      this._headersReceivedCapability.reject(this._storedError);

	      var _iterator3 = _createForOfIteratorHelper(this._requests),
	          _step3;

	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var requestCapability = _step3.value;
	          requestCapability.reject(this._storedError);
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }

	      this._requests.length = 0;
	      this._cachedChunks.length = 0;
	    }
	  }, {
	    key: "_onProgress",
	    value: function _onProgress(evt) {
	      var _this$onProgress;

	      (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
	        loaded: evt.loaded,
	        total: evt.lengthComputable ? evt.total : this._contentLength
	      });
	    }
	  }, {
	    key: "filename",
	    get: function get() {
	      return this._filename;
	    }
	  }, {
	    key: "isRangeSupported",
	    get: function get() {
	      return this._isRangeSupported;
	    }
	  }, {
	    key: "isStreamingSupported",
	    get: function get() {
	      return this._isStreamingSupported;
	    }
	  }, {
	    key: "contentLength",
	    get: function get() {
	      return this._contentLength;
	    }
	  }, {
	    key: "headersReady",
	    get: function get() {
	      return this._headersReceivedCapability.promise;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
	        var chunk, requestCapability;
	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!this._storedError) {
	                  _context.next = 2;
	                  break;
	                }

	                throw this._storedError;

	              case 2:
	                if (!(this._cachedChunks.length > 0)) {
	                  _context.next = 5;
	                  break;
	                }

	                chunk = this._cachedChunks.shift();
	                return _context.abrupt("return", {
	                  value: chunk,
	                  done: false
	                });

	              case 5:
	                if (!this._done) {
	                  _context.next = 7;
	                  break;
	                }

	                return _context.abrupt("return", {
	                  value: undefined,
	                  done: true
	                });

	              case 7:
	                requestCapability = (0, _util.createPromiseCapability)();

	                this._requests.push(requestCapability);

	                return _context.abrupt("return", requestCapability.promise);

	              case 10:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function read() {
	        return _read.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      this._done = true;

	      this._headersReceivedCapability.reject(reason);

	      var _iterator4 = _createForOfIteratorHelper(this._requests),
	          _step4;

	      try {
	        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	          var requestCapability = _step4.value;
	          requestCapability.resolve({
	            value: undefined,
	            done: true
	          });
	        }
	      } catch (err) {
	        _iterator4.e(err);
	      } finally {
	        _iterator4.f();
	      }

	      this._requests.length = 0;

	      if (this._manager.isPendingRequest(this._fullRequestId)) {
	        this._manager.abortRequest(this._fullRequestId);
	      }

	      this._fullRequestReader = null;
	    }
	  }]);

	  return PDFNetworkStreamFullRequestReader;
	}();

	var PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {
	  function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
	    _classCallCheck(this, PDFNetworkStreamRangeRequestReader);

	    this._manager = manager;
	    var args = {
	      onDone: this._onDone.bind(this),
	      onError: this._onError.bind(this),
	      onProgress: this._onProgress.bind(this)
	    };
	    this._url = manager.url;
	    this._requestId = manager.requestRange(begin, end, args);
	    this._requests = [];
	    this._queuedChunk = null;
	    this._done = false;
	    this._storedError = undefined;
	    this.onProgress = null;
	    this.onClosed = null;
	  }

	  _createClass(PDFNetworkStreamRangeRequestReader, [{
	    key: "_close",
	    value: function _close() {
	      var _this$onClosed;

	      (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
	    }
	  }, {
	    key: "_onDone",
	    value: function _onDone(data) {
	      var chunk = data.chunk;

	      if (this._requests.length > 0) {
	        var requestCapability = this._requests.shift();

	        requestCapability.resolve({
	          value: chunk,
	          done: false
	        });
	      } else {
	        this._queuedChunk = chunk;
	      }

	      this._done = true;

	      var _iterator5 = _createForOfIteratorHelper(this._requests),
	          _step5;

	      try {
	        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
	          var _requestCapability2 = _step5.value;

	          _requestCapability2.resolve({
	            value: undefined,
	            done: true
	          });
	        }
	      } catch (err) {
	        _iterator5.e(err);
	      } finally {
	        _iterator5.f();
	      }

	      this._requests.length = 0;

	      this._close();
	    }
	  }, {
	    key: "_onError",
	    value: function _onError(status) {
	      this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

	      var _iterator6 = _createForOfIteratorHelper(this._requests),
	          _step6;

	      try {
	        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
	          var requestCapability = _step6.value;
	          requestCapability.reject(this._storedError);
	        }
	      } catch (err) {
	        _iterator6.e(err);
	      } finally {
	        _iterator6.f();
	      }

	      this._requests.length = 0;
	      this._queuedChunk = null;
	    }
	  }, {
	    key: "_onProgress",
	    value: function _onProgress(evt) {
	      if (!this.isStreamingSupported) {
	        var _this$onProgress2;

	        (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
	          loaded: evt.loaded
	        });
	      }
	    }
	  }, {
	    key: "isStreamingSupported",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
	        var chunk, requestCapability;
	        return _regenerator["default"].wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!this._storedError) {
	                  _context2.next = 2;
	                  break;
	                }

	                throw this._storedError;

	              case 2:
	                if (!(this._queuedChunk !== null)) {
	                  _context2.next = 6;
	                  break;
	                }

	                chunk = this._queuedChunk;
	                this._queuedChunk = null;
	                return _context2.abrupt("return", {
	                  value: chunk,
	                  done: false
	                });

	              case 6:
	                if (!this._done) {
	                  _context2.next = 8;
	                  break;
	                }

	                return _context2.abrupt("return", {
	                  value: undefined,
	                  done: true
	                });

	              case 8:
	                requestCapability = (0, _util.createPromiseCapability)();

	                this._requests.push(requestCapability);

	                return _context2.abrupt("return", requestCapability.promise);

	              case 11:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function read() {
	        return _read2.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      this._done = true;

	      var _iterator7 = _createForOfIteratorHelper(this._requests),
	          _step7;

	      try {
	        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
	          var requestCapability = _step7.value;
	          requestCapability.resolve({
	            value: undefined,
	            done: true
	          });
	        }
	      } catch (err) {
	        _iterator7.e(err);
	      } finally {
	        _iterator7.f();
	      }

	      this._requests.length = 0;

	      if (this._manager.isPendingRequest(this._requestId)) {
	        this._manager.abortRequest(this._requestId);
	      }

	      this._close();
	    }
	  }]);

	  return PDFNetworkStreamRangeRequestReader;
	}();

	/***/ }),
	/* 157 */
	/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.PDFFetchStream = void 0;

	var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));

	var _util = __w_pdfjs_require__(4);

	var _network_utils = __w_pdfjs_require__(154);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function createFetchOptions(headers, withCredentials, abortController) {
	  return {
	    method: "GET",
	    headers: headers,
	    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
	    mode: "cors",
	    credentials: withCredentials ? "include" : "same-origin",
	    redirect: "follow"
	  };
	}

	function createHeaders(httpHeaders) {
	  var headers = new Headers();

	  for (var property in httpHeaders) {
	    var value = httpHeaders[property];

	    if (typeof value === "undefined") {
	      continue;
	    }

	    headers.append(property, value);
	  }

	  return headers;
	}

	var PDFFetchStream = /*#__PURE__*/function () {
	  function PDFFetchStream(source) {
	    _classCallCheck(this, PDFFetchStream);

	    this.source = source;
	    this.isHttp = /^https?:/i.test(source.url);
	    this.httpHeaders = this.isHttp && source.httpHeaders || {};
	    this._fullRequestReader = null;
	    this._rangeRequestReaders = [];
	  }

	  _createClass(PDFFetchStream, [{
	    key: "_progressiveDataLength",
	    get: function get() {
	      var _this$_fullRequestRea, _this$_fullRequestRea2;

	      return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
	    }
	  }, {
	    key: "getFullReader",
	    value: function getFullReader() {
	      (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
	      this._fullRequestReader = new PDFFetchStreamReader(this);
	      return this._fullRequestReader;
	    }
	  }, {
	    key: "getRangeReader",
	    value: function getRangeReader(begin, end) {
	      if (end <= this._progressiveDataLength) {
	        return null;
	      }

	      var reader = new PDFFetchStreamRangeReader(this, begin, end);

	      this._rangeRequestReaders.push(reader);

	      return reader;
	    }
	  }, {
	    key: "cancelAllRequests",
	    value: function cancelAllRequests(reason) {
	      if (this._fullRequestReader) {
	        this._fullRequestReader.cancel(reason);
	      }

	      var _iterator = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var reader = _step.value;
	          reader.cancel(reason);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    }
	  }]);

	  return PDFFetchStream;
	}();

	exports.PDFFetchStream = PDFFetchStream;

	var PDFFetchStreamReader = /*#__PURE__*/function () {
	  function PDFFetchStreamReader(stream) {
	    var _this = this;

	    _classCallCheck(this, PDFFetchStreamReader);

	    this._stream = stream;
	    this._reader = null;
	    this._loaded = 0;
	    this._filename = null;
	    var source = stream.source;
	    this._withCredentials = source.withCredentials || false;
	    this._contentLength = source.length;
	    this._headersCapability = (0, _util.createPromiseCapability)();
	    this._disableRange = source.disableRange || false;
	    this._rangeChunkSize = source.rangeChunkSize;

	    if (!this._rangeChunkSize && !this._disableRange) {
	      this._disableRange = true;
	    }

	    if (typeof AbortController !== "undefined") {
	      this._abortController = new AbortController();
	    }

	    this._isStreamingSupported = !source.disableStream;
	    this._isRangeSupported = !source.disableRange;
	    this._headers = createHeaders(this._stream.httpHeaders);
	    var url = source.url;
	    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
	      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
	        throw (0, _network_utils.createResponseStatusError)(response.status, url);
	      }

	      _this._reader = response.body.getReader();

	      _this._headersCapability.resolve();

	      var getResponseHeader = function getResponseHeader(name) {
	        return response.headers.get(name);
	      };

	      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
	        getResponseHeader: getResponseHeader,
	        isHttp: _this._stream.isHttp,
	        rangeChunkSize: _this._rangeChunkSize,
	        disableRange: _this._disableRange
	      }),
	          allowRangeRequests = _validateRangeRequest.allowRangeRequests,
	          suggestedLength = _validateRangeRequest.suggestedLength;

	      _this._isRangeSupported = allowRangeRequests;
	      _this._contentLength = suggestedLength || _this._contentLength;
	      _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

	      if (!_this._isStreamingSupported && _this._isRangeSupported) {
	        _this.cancel(new _util.AbortException("Streaming is disabled."));
	      }
	    })["catch"](this._headersCapability.reject);
	    this.onProgress = null;
	  }

	  _createClass(PDFFetchStreamReader, [{
	    key: "headersReady",
	    get: function get() {
	      return this._headersCapability.promise;
	    }
	  }, {
	    key: "filename",
	    get: function get() {
	      return this._filename;
	    }
	  }, {
	    key: "contentLength",
	    get: function get() {
	      return this._contentLength;
	    }
	  }, {
	    key: "isRangeSupported",
	    get: function get() {
	      return this._isRangeSupported;
	    }
	  }, {
	    key: "isStreamingSupported",
	    get: function get() {
	      return this._isStreamingSupported;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
	        var _yield$this$_reader$r, value, done, buffer;

	        return _regenerator["default"].wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return this._headersCapability.promise;

	              case 2:
	                _context.next = 4;
	                return this._reader.read();

	              case 4:
	                _yield$this$_reader$r = _context.sent;
	                value = _yield$this$_reader$r.value;
	                done = _yield$this$_reader$r.done;

	                if (!done) {
	                  _context.next = 9;
	                  break;
	                }

	                return _context.abrupt("return", {
	                  value: value,
	                  done: done
	                });

	              case 9:
	                this._loaded += value.byteLength;

	                if (this.onProgress) {
	                  this.onProgress({
	                    loaded: this._loaded,
	                    total: this._contentLength
	                  });
	                }

	                buffer = new Uint8Array(value).buffer;
	                return _context.abrupt("return", {
	                  value: buffer,
	                  done: false
	                });

	              case 13:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function read() {
	        return _read.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      if (this._reader) {
	        this._reader.cancel(reason);
	      }

	      if (this._abortController) {
	        this._abortController.abort();
	      }
	    }
	  }]);

	  return PDFFetchStreamReader;
	}();

	var PDFFetchStreamRangeReader = /*#__PURE__*/function () {
	  function PDFFetchStreamRangeReader(stream, begin, end) {
	    var _this2 = this;

	    _classCallCheck(this, PDFFetchStreamRangeReader);

	    this._stream = stream;
	    this._reader = null;
	    this._loaded = 0;
	    var source = stream.source;
	    this._withCredentials = source.withCredentials || false;
	    this._readCapability = (0, _util.createPromiseCapability)();
	    this._isStreamingSupported = !source.disableStream;

	    if (typeof AbortController !== "undefined") {
	      this._abortController = new AbortController();
	    }

	    this._headers = createHeaders(this._stream.httpHeaders);

	    this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));

	    var url = source.url;
	    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
	      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
	        throw (0, _network_utils.createResponseStatusError)(response.status, url);
	      }

	      _this2._readCapability.resolve();

	      _this2._reader = response.body.getReader();
	    })["catch"](this._readCapability.reject);
	    this.onProgress = null;
	  }

	  _createClass(PDFFetchStreamRangeReader, [{
	    key: "isStreamingSupported",
	    get: function get() {
	      return this._isStreamingSupported;
	    }
	  }, {
	    key: "read",
	    value: function () {
	      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
	        var _yield$this$_reader$r2, value, done, buffer;

	        return _regenerator["default"].wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return this._readCapability.promise;

	              case 2:
	                _context2.next = 4;
	                return this._reader.read();

	              case 4:
	                _yield$this$_reader$r2 = _context2.sent;
	                value = _yield$this$_reader$r2.value;
	                done = _yield$this$_reader$r2.done;

	                if (!done) {
	                  _context2.next = 9;
	                  break;
	                }

	                return _context2.abrupt("return", {
	                  value: value,
	                  done: done
	                });

	              case 9:
	                this._loaded += value.byteLength;

	                if (this.onProgress) {
	                  this.onProgress({
	                    loaded: this._loaded
	                  });
	                }

	                buffer = new Uint8Array(value).buffer;
	                return _context2.abrupt("return", {
	                  value: buffer,
	                  done: false
	                });

	              case 13:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function read() {
	        return _read2.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "cancel",
	    value: function cancel(reason) {
	      if (this._reader) {
	        this._reader.cancel(reason);
	      }

	      if (this._abortController) {
	        this._abortController.abort();
	      }
	    }
	  }]);

	  return PDFFetchStreamRangeReader;
	}();

	/***/ })
	/******/ 	]);
	/************************************************************************/
	/******/ 	// The module cache
	/******/ 	var __webpack_module_cache__ = {};
	/******/ 	
	/******/ 	// The require function
	/******/ 	function __w_pdfjs_require__(moduleId) {
	/******/ 		// Check if module is in cache
	/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
	/******/ 		if (cachedModule !== undefined) {
	/******/ 			return cachedModule.exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = __webpack_module_cache__[moduleId] = {
	/******/ 			id: moduleId,
	/******/ 			loaded: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/ 	
	/******/ 		// Execute the module function
	/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
	/******/ 	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/ 	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/ 	
	/************************************************************************/
	/******/ 	/* webpack/runtime/node module decorator */
	/******/ 	(() => {
	/******/ 		__w_pdfjs_require__.nmd = (module) => {
	/******/ 			module.paths = [];
	/******/ 			if (!module.children) module.children = [];
	/******/ 			return module;
	/******/ 		};
	/******/ 	})();
	/******/ 	
	/************************************************************************/
	var __webpack_exports__ = {};
	// This entry need to be wrapped in an IIFE because it need to be in strict mode.
	(() => {
	var exports = __webpack_exports__;


	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	Object.defineProperty(exports, "AnnotationLayer", ({
	  enumerable: true,
	  get: function get() {
	    return _annotation_layer.AnnotationLayer;
	  }
	}));
	Object.defineProperty(exports, "AnnotationMode", ({
	  enumerable: true,
	  get: function get() {
	    return _util.AnnotationMode;
	  }
	}));
	Object.defineProperty(exports, "CMapCompressionType", ({
	  enumerable: true,
	  get: function get() {
	    return _util.CMapCompressionType;
	  }
	}));
	Object.defineProperty(exports, "GlobalWorkerOptions", ({
	  enumerable: true,
	  get: function get() {
	    return _worker_options.GlobalWorkerOptions;
	  }
	}));
	Object.defineProperty(exports, "InvalidPDFException", ({
	  enumerable: true,
	  get: function get() {
	    return _util.InvalidPDFException;
	  }
	}));
	Object.defineProperty(exports, "LinkTarget", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.LinkTarget;
	  }
	}));
	Object.defineProperty(exports, "LoopbackPort", ({
	  enumerable: true,
	  get: function get() {
	    return _api.LoopbackPort;
	  }
	}));
	Object.defineProperty(exports, "MissingPDFException", ({
	  enumerable: true,
	  get: function get() {
	    return _util.MissingPDFException;
	  }
	}));
	Object.defineProperty(exports, "OPS", ({
	  enumerable: true,
	  get: function get() {
	    return _util.OPS;
	  }
	}));
	Object.defineProperty(exports, "PDFDataRangeTransport", ({
	  enumerable: true,
	  get: function get() {
	    return _api.PDFDataRangeTransport;
	  }
	}));
	Object.defineProperty(exports, "PDFDateString", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.PDFDateString;
	  }
	}));
	Object.defineProperty(exports, "PDFWorker", ({
	  enumerable: true,
	  get: function get() {
	    return _api.PDFWorker;
	  }
	}));
	Object.defineProperty(exports, "PasswordResponses", ({
	  enumerable: true,
	  get: function get() {
	    return _util.PasswordResponses;
	  }
	}));
	Object.defineProperty(exports, "PermissionFlag", ({
	  enumerable: true,
	  get: function get() {
	    return _util.PermissionFlag;
	  }
	}));
	Object.defineProperty(exports, "PixelsPerInch", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.PixelsPerInch;
	  }
	}));
	Object.defineProperty(exports, "RenderingCancelledException", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.RenderingCancelledException;
	  }
	}));
	Object.defineProperty(exports, "SVGGraphics", ({
	  enumerable: true,
	  get: function get() {
	    return _svg.SVGGraphics;
	  }
	}));
	Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
	  enumerable: true,
	  get: function get() {
	    return _util.UNSUPPORTED_FEATURES;
	  }
	}));
	Object.defineProperty(exports, "UnexpectedResponseException", ({
	  enumerable: true,
	  get: function get() {
	    return _util.UnexpectedResponseException;
	  }
	}));
	Object.defineProperty(exports, "Util", ({
	  enumerable: true,
	  get: function get() {
	    return _util.Util;
	  }
	}));
	Object.defineProperty(exports, "VerbosityLevel", ({
	  enumerable: true,
	  get: function get() {
	    return _util.VerbosityLevel;
	  }
	}));
	Object.defineProperty(exports, "XfaLayer", ({
	  enumerable: true,
	  get: function get() {
	    return _xfa_layer.XfaLayer;
	  }
	}));
	Object.defineProperty(exports, "addLinkAttributes", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.addLinkAttributes;
	  }
	}));
	Object.defineProperty(exports, "build", ({
	  enumerable: true,
	  get: function get() {
	    return _api.build;
	  }
	}));
	Object.defineProperty(exports, "createObjectURL", ({
	  enumerable: true,
	  get: function get() {
	    return _util.createObjectURL;
	  }
	}));
	Object.defineProperty(exports, "createPromiseCapability", ({
	  enumerable: true,
	  get: function get() {
	    return _util.createPromiseCapability;
	  }
	}));
	Object.defineProperty(exports, "createValidAbsoluteUrl", ({
	  enumerable: true,
	  get: function get() {
	    return _util.createValidAbsoluteUrl;
	  }
	}));
	Object.defineProperty(exports, "getDocument", ({
	  enumerable: true,
	  get: function get() {
	    return _api.getDocument;
	  }
	}));
	Object.defineProperty(exports, "getFilenameFromUrl", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.getFilenameFromUrl;
	  }
	}));
	Object.defineProperty(exports, "getPdfFilenameFromUrl", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.getPdfFilenameFromUrl;
	  }
	}));
	Object.defineProperty(exports, "getXfaPageViewport", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.getXfaPageViewport;
	  }
	}));
	Object.defineProperty(exports, "isPdfFile", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.isPdfFile;
	  }
	}));
	Object.defineProperty(exports, "loadScript", ({
	  enumerable: true,
	  get: function get() {
	    return _display_utils.loadScript;
	  }
	}));
	Object.defineProperty(exports, "removeNullCharacters", ({
	  enumerable: true,
	  get: function get() {
	    return _util.removeNullCharacters;
	  }
	}));
	Object.defineProperty(exports, "renderTextLayer", ({
	  enumerable: true,
	  get: function get() {
	    return _text_layer.renderTextLayer;
	  }
	}));
	Object.defineProperty(exports, "shadow", ({
	  enumerable: true,
	  get: function get() {
	    return _util.shadow;
	  }
	}));
	Object.defineProperty(exports, "version", ({
	  enumerable: true,
	  get: function get() {
	    return _api.version;
	  }
	}));

	var _display_utils = __w_pdfjs_require__(1);

	var _util = __w_pdfjs_require__(4);

	var _api = __w_pdfjs_require__(136);

	var _annotation_layer = __w_pdfjs_require__(148);

	var _worker_options = __w_pdfjs_require__(142);

	var _is_node = __w_pdfjs_require__(6);

	var _text_layer = __w_pdfjs_require__(151);

	var _svg = __w_pdfjs_require__(152);

	var _xfa_layer = __w_pdfjs_require__(150);
	{
	  if (_is_node.isNodeJS) {
	    var _require = __w_pdfjs_require__(153),
	        PDFNodeStream = _require.PDFNodeStream;

	    (0, _api.setPDFNetworkStreamFactory)(function (params) {
	      return new PDFNodeStream(params);
	    });
	  } else {
	    var _require2 = __w_pdfjs_require__(156),
	        PDFNetworkStream = _require2.PDFNetworkStream;

	    var _require3 = __w_pdfjs_require__(157),
	        PDFFetchStream = _require3.PDFFetchStream;

	    (0, _api.setPDFNetworkStreamFactory)(function (params) {
	      if ((0, _display_utils.isValidFetchUrl)(params.url)) {
	        return new PDFFetchStream(params);
	      }

	      return new PDFNetworkStream(params);
	    });
	  }
	}
	})();

	/******/ 	return __webpack_exports__;
	/******/ })()
	;
	});
	
} (pdf));

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var propTypes = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has;
	hasRequiredHas = 1;
	has = Function.call.bind(Object.prototype.hasOwnProperty);
	return has;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = requireHas();

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) { /**/ }
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = reactIs$2.exports;
	var assign = requireObjectAssign();

	var ReactPropTypesSecret = requireReactPropTypesSecret();
	var has = requireHas();
	var checkPropTypes = requireCheckPropTypes();

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data: {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError(
	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
	          {expectedType: expectedType}
	        );
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError(
	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
	    );
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = reactIs$2.exports;

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = requireFactoryWithThrowingShims()();
}

// As defined on the list of supported events: https://reactjs.org/docs/events.html
var clipboardEvents = ['onCopy', 'onCut', 'onPaste'];
var compositionEvents = ['onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate'];
var keyboardEvents = ['onKeyDown', 'onKeyPress', 'onKeyUp'];
var focusEvents = ['onFocus', 'onBlur'];
var formEvents = ['onChange', 'onInput', 'onInvalid', 'onReset', 'onSubmit'];
var genericEvents = ['onError', 'onLoad'];
var mouseEvents = ['onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp'];
var pointerEvents = ['onPointerDown', 'onPointerMove', 'onPointerUp', 'onPointerCancel', 'onGotPointerCapture', 'onLostPointerCapture', 'onPointerEnter', 'onPointerLeave', 'onPointerOver', 'onPointerOut'];
var selectionEvents = ['onSelect'];
var touchEvents = ['onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart'];
var uiEvents = ['onScroll'];
var wheelEvents = ['onWheel'];
var mediaEvents = ['onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting'];
var imageEvents = ['onLoad', 'onError'];
var animationEvents = ['onAnimationStart', 'onAnimationEnd', 'onAnimationIteration'];
var transitionEvents = ['onTransitionEnd'];
var otherEvents = ['onToggle'];
var allEvents = [].concat(clipboardEvents, compositionEvents, keyboardEvents, focusEvents, formEvents, genericEvents, mouseEvents, pointerEvents, selectionEvents, touchEvents, uiEvents, wheelEvents, mediaEvents, imageEvents, animationEvents, transitionEvents, otherEvents);
/**
 * Returns an object with on-event callback props curried with provided args.
 * @param {Object} props Props passed to a component.
 * @param {Function=} getArgs A function that returns argument(s) on-event callbacks
 *   shall be curried with.
 */

var makeEventProps = function makeEventProps(props, getArgs) {
  var eventProps = {};
  allEvents.forEach(function (eventName) {
    if (!(eventName in props)) {
      return;
    }

    if (!getArgs) {
      eventProps[eventName] = props[eventName];
      return;
    }

    eventProps[eventName] = function (event) {
      return props[eventName](event, getArgs(eventName));
    };
  });
  return eventProps;
};

function makeCancellablePromise(promise) {
  var isCancelled = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function () {
      return !isCancelled && resolve.apply(void 0, arguments);
    })["catch"](function (error) {
      return !isCancelled && reject(error);
    });
  });
  return {
    promise: wrappedPromise,
    cancel: function cancel() {
      isCancelled = true;
    }
  };
}

function mergeClassNames() {
  return Array.prototype.slice.call(arguments).reduce(function (classList, arg) {
    return classList.concat(arg);
  }, []).filter(function (arg) {
    return typeof arg === 'string';
  }).join(' ');
}

var isProduction$1 = process.env.NODE_ENV === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction$1) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? prefix + ": " + provided : prefix;
    throw new Error(value);
}

var isProduction = process.env.NODE_ENV === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

var DocumentContext = /*#__PURE__*/createContext(null);

function Message(_ref) {
  var children = _ref.children,
      type = _ref.type;
  return /*#__PURE__*/React.createElement("div", {
    className: "react-pdf__message react-pdf__message--".concat(type)
  }, children);
}
Message.propTypes = {
  children: propTypes.exports.node,
  type: propTypes.exports.oneOf(['error', 'loading', 'no-data']).isRequired
};

var DEFAULT_LINK_REL = 'noopener noreferrer nofollow';

var LinkService = /*#__PURE__*/function () {
  function LinkService() {
    _classCallCheck(this, LinkService);

    this.externalLinkTarget = null;
    this.externalLinkRel = null;
  }

  _createClass(LinkService, [{
    key: "setDocument",
    value: function setDocument(pdfDocument) {
      this.pdfDocument = pdfDocument;
    }
  }, {
    key: "setViewer",
    value: function setViewer(pdfViewer) {
      this.pdfViewer = pdfViewer;
    }
  }, {
    key: "setExternalLinkRel",
    value: function setExternalLinkRel(externalLinkRel) {
      this.externalLinkRel = externalLinkRel;
    }
  }, {
    key: "setExternalLinkTarget",
    value: function setExternalLinkTarget(externalLinkTarget) {
      this.externalLinkTarget = externalLinkTarget;
    }
  }, {
    key: "setHistory",
    value: function setHistory() {}
  }, {
    key: "pagesCount",
    get: function get() {
      return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
  }, {
    key: "page",
    get: function get() {
      return this.pdfViewer.currentPageNumber;
    },
    set: function set(value) {
      this.pdfViewer.currentPageNumber = value;
    }
  }, {
    key: "rotation",
    get: function get() {
      return 0;
    },
    set: function set(value) {}
  }, {
    key: "goToDestination",
    value: function goToDestination(dest) {
      var _this = this;

      new Promise(function (resolve) {
        if (typeof dest === 'string') {
          _this.pdfDocument.getDestination(dest).then(resolve);
        } else if (Array.isArray(dest)) {
          resolve(dest);
        } else {
          dest.then(resolve);
        }
      }).then(function (explicitDest) {
        invariant(Array.isArray(explicitDest), "\"".concat(explicitDest, "\" is not a valid destination array."));
        var destRef = explicitDest[0];
        new Promise(function (resolve) {
          if (destRef instanceof Object) {
            _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
              resolve(pageIndex);
            })["catch"](function () {
              invariant(false, "\"".concat(destRef, "\" is not a valid page reference."));
            });
          } else if (typeof destRef === 'number') {
            resolve(destRef);
          } else {
            invariant(false, "\"".concat(destRef, "\" is not a valid destination reference."));
          }
        }).then(function (pageIndex) {
          var pageNumber = pageIndex + 1;
          invariant(pageNumber >= 1 && pageNumber <= _this.pagesCount, "\"".concat(pageNumber, "\" is not a valid page number."));

          _this.pdfViewer.scrollPageIntoView({
            dest: dest,
            pageIndex: pageIndex,
            pageNumber: pageNumber
          });
        });
      });
    }
  }, {
    key: "navigateTo",
    value: function navigateTo(dest) {
      this.goToDestination(dest);
    }
  }, {
    key: "goToPage",
    value: function goToPage() {}
  }, {
    key: "addLinkAttributes",
    value: function addLinkAttributes(link, url, newWindow) {
      link.href = url;
      link.rel = this.externalLinkRel || DEFAULT_LINK_REL;
      link.target = newWindow ? '_blank' : this.externalLinkTarget || '';
    }
  }, {
    key: "getDestinationHash",
    value: function getDestinationHash() {
      return '#';
    }
  }, {
    key: "getAnchorUrl",
    value: function getAnchorUrl() {
      return '#';
    }
  }, {
    key: "setHash",
    value: function setHash() {}
  }, {
    key: "executeNamedAction",
    value: function executeNamedAction() {}
  }, {
    key: "cachePageRef",
    value: function cachePageRef() {}
  }, {
    key: "isPageVisible",
    value: function isPageVisible() {
      return true;
    }
  }, {
    key: "isPageCached",
    value: function isPageCached() {
      return true;
    }
  }]);

  return LinkService;
}();

// As defined in https://github.com/mozilla/pdf.js/blob/d9fac3459609a807be6506fb3441b5da4b154d14/src/shared/util.js#L371-L374
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

/**
 * Checks if we're running in a browser environment.
 */

var isBrowser = typeof window !== 'undefined';
/**
 * Checks whether we're running from a local file system.
 */

var isLocalFileSystem = isBrowser && window.location.protocol === 'file:';
/**
 * Checks whether a variable is defined.
 *
 * @param {*} variable Variable to check
 */

function isDefined(variable) {
  return typeof variable !== 'undefined';
}
/**
 * Checks whether a variable is defined and not null.
 *
 * @param {*} variable Variable to check
 */

function isProvided(variable) {
  return isDefined(variable) && variable !== null;
}
/**
 * Checkes whether a variable provided is a string.
 *
 * @param {*} variable Variable to check
 */

function isString(variable) {
  return typeof variable === 'string';
}
/**
 * Checks whether a variable provided is an ArrayBuffer.
 *
 * @param {*} variable Variable to check
 */

function isArrayBuffer(variable) {
  return variable instanceof ArrayBuffer;
}
/**
 * Checkes whether a variable provided is a Blob.
 *
 * @param {*} variable Variable to check
 */

function isBlob(variable) {
  invariant(isBrowser, 'isBlob can only be used in a browser environment');
  return variable instanceof Blob;
}
/**
 * Checkes whether a variable provided is a File.
 *
 * @param {*} variable Variable to check
 */

function isFile$1(variable) {
  invariant(isBrowser, 'isFile can only be used in a browser environment');
  return variable instanceof File;
}
/**
 * Checks whether a string provided is a data URI.
 *
 * @param {string} str String to check
 */

function isDataURI(str) {
  return isString(str) && /^data:/.test(str);
}
function dataURItoByteString(dataURI) {
  invariant(isDataURI(dataURI), 'Invalid data URI.');

  var _dataURI$split = dataURI.split(','),
      _dataURI$split2 = _slicedToArray(_dataURI$split, 2),
      headersString = _dataURI$split2[0],
      dataString = _dataURI$split2[1];

  var headers = headersString.split(';');

  if (headers.indexOf('base64') !== -1) {
    return atob(dataString);
  }

  return unescape(dataString);
}
function getPixelRatio() {
  return isBrowser && window.devicePixelRatio || 1;
}
var allowFileAccessFromFilesTip = 'On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.';
function displayCORSWarning() {
  warning(!isLocalFileSystem, "Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function displayWorkerWarning() {
  warning(!isLocalFileSystem, "Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ".concat(allowFileAccessFromFilesTip));
}
function cancelRunningTask(runningTask) {
  if (runningTask && runningTask.cancel) runningTask.cancel();
}
function makePageCallback(page, scale) {
  Object.defineProperty(page, 'width', {
    get: function get() {
      return this.view[2] * scale;
    },
    configurable: true
  });
  Object.defineProperty(page, 'height', {
    get: function get() {
      return this.view[3] * scale;
    },
    configurable: true
  });
  Object.defineProperty(page, 'originalWidth', {
    get: function get() {
      return this.view[2];
    },
    configurable: true
  });
  Object.defineProperty(page, 'originalHeight', {
    get: function get() {
      return this.view[3];
    },
    configurable: true
  });
  return page;
}
function isCancelException(error) {
  return error.name === 'RenderingCancelledException';
}
function loadFromFile(file) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      return resolve(new Uint8Array(reader.result));
    };

    reader.onerror = function (event) {
      switch (event.target.error.code) {
        case event.target.error.NOT_FOUND_ERR:
          return reject(new Error('Error while reading a file: File not found.'));

        case event.target.error.NOT_READABLE_ERR:
          return reject(new Error('Error while reading a file: File not readable.'));

        case event.target.error.SECURITY_ERR:
          return reject(new Error('Error while reading a file: Security error.'));

        case event.target.error.ABORT_ERR:
          return reject(new Error('Error while reading a file: Aborted.'));

        default:
          return reject(new Error('Error while reading a file.'));
      }
    };

    reader.readAsArrayBuffer(file);
    return null;
  });
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var eventProps = function () {
  var result = {};
  [].concat(_toConsumableArray(mouseEvents), _toConsumableArray(touchEvents), _toConsumableArray(keyboardEvents)).forEach(function (eventName) {
    result[eventName] = propTypes.exports.func;
  });
  return result;
}();
var fileTypes = [propTypes.exports.string, propTypes.exports.instanceOf(ArrayBuffer), propTypes.exports.shape({
  data: propTypes.exports.oneOfType([propTypes.exports.object, propTypes.exports.string]),
  httpHeaders: propTypes.exports.object,
  range: propTypes.exports.object,
  url: propTypes.exports.string,
  withCredentials: propTypes.exports.bool
})];

if (typeof File !== 'undefined') {
  fileTypes.push(propTypes.exports.instanceOf(File));
}

if (typeof Blob !== 'undefined') {
  fileTypes.push(propTypes.exports.instanceOf(Blob));
}

var isClassName = propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.arrayOf(propTypes.exports.string)]);
var isFile = propTypes.exports.oneOfType(fileTypes);
var isLinkService = propTypes.exports.instanceOf(LinkService);
propTypes.exports.oneOf(['_self', '_blank', '_parent', '_top']);
var isPage = propTypes.exports.shape({
  _transport: propTypes.exports.shape({
    fontLoader: propTypes.exports.object.isRequired
  }).isRequired,
  commonObjs: propTypes.exports.shape({
    _objs: propTypes.exports.object.isRequired
  }).isRequired,
  getAnnotations: propTypes.exports.func.isRequired,
  getTextContent: propTypes.exports.func.isRequired,
  getViewport: propTypes.exports.func.isRequired,
  render: propTypes.exports.func.isRequired
});
var isPageIndex = function isPageIndex(props, propName, componentName) {
  var pageIndex = props[propName],
      pageNumber = props.pageNumber,
      pdf = props.pdf;

  if (!isDefined(pdf)) {
    return null;
  }

  if (isDefined(pageIndex)) {
    if (typeof pageIndex !== 'number') {
      return new Error("`".concat(propName, "` of type `").concat(_typeof$1(pageIndex), "` supplied to `").concat(componentName, "`, expected `number`."));
    }

    if (pageIndex < 0) {
      return new Error("Expected `".concat(propName, "` to be greater or equal to 0."));
    }

    var numPages = pdf.numPages;

    if (pageIndex + 1 > numPages) {
      return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages - 1, "."));
    }
  } else if (!isDefined(pageNumber)) {
    return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));
  } // Everything is fine


  return null;
};
var isPageNumber = function isPageNumber(props, propName, componentName) {
  var pageNumber = props[propName],
      pageIndex = props.pageIndex,
      pdf = props.pdf;

  if (!isDefined(pdf)) {
    return null;
  }

  if (isDefined(pageNumber)) {
    if (typeof pageNumber !== 'number') {
      return new Error("`".concat(propName, "` of type `").concat(_typeof$1(pageNumber), "` supplied to `").concat(componentName, "`, expected `number`."));
    }

    if (pageNumber < 1) {
      return new Error("Expected `".concat(propName, "` to be greater or equal to 1."));
    }

    var numPages = pdf.numPages;

    if (pageNumber > numPages) {
      return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages, "."));
    }
  } else if (!isDefined(pageIndex)) {
    return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));
  } // Everything is fine


  return null;
};
var isPdf = propTypes.exports.oneOfType([propTypes.exports.shape({
  getDestination: propTypes.exports.func.isRequired,
  getOutline: propTypes.exports.func.isRequired,
  getPage: propTypes.exports.func.isRequired,
  numPages: propTypes.exports.number.isRequired
}), propTypes.exports.bool]);
var isRef = propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.shape({
  current: propTypes.exports.any
})]);
var isRenderMode = propTypes.exports.oneOf(['canvas', 'none', 'svg']);
var isRotate = propTypes.exports.oneOf([0, 90, 180, 270]);

var _excluded = ["url"];

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var PDFDataRangeTransport = pdf.exports.PDFDataRangeTransport;

var Document = /*#__PURE__*/function (_PureComponent) {
  _inherits(Document, _PureComponent);

  var _super = _createSuper$6(Document);

  function Document() {
    var _this;

    _classCallCheck(this, Document);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      pdf: null
    });

    _defineProperty(_assertThisInitialized(_this), "viewer", {
      scrollPageIntoView: function scrollPageIntoView(_ref) {
        var dest = _ref.dest,
            pageIndex = _ref.pageIndex,
            pageNumber = _ref.pageNumber;
        // Handling jumping to internal links target
        var onItemClick = _this.props.onItemClick; // First, check if custom handling of onItemClick was provided

        if (onItemClick) {
          onItemClick({
            dest: dest,
            pageIndex: pageIndex,
            pageNumber: pageNumber
          });
          return;
        } // If not, try to look for target page within the <Document>.


        var page = _this.pages[pageIndex];

        if (page) {
          // Scroll to the page automatically
          page.scrollIntoView();
          return;
        }

        warning(false, "An internal link leading to page ".concat(pageNumber, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>."));
      }
    });

    _defineProperty(_assertThisInitialized(_this), "linkService", new LinkService());

    _defineProperty(_assertThisInitialized(_this), "loadDocument", function () {
      // If another rendering is in progress, let's cancel it
      cancelRunningTask(_this.runningTask); // If another loading is in progress, let's destroy it

      if (_this.loadingTask) _this.loadingTask.destroy();
      var cancellable = makeCancellablePromise(_this.findDocumentSource());
      _this.runningTask = cancellable;
      cancellable.promise.then(function (source) {
        _this.onSourceSuccess();

        if (!source) {
          return;
        }

        _this.setState(function (prevState) {
          if (!prevState.pdf) {
            return null;
          }

          return {
            pdf: null
          };
        });

        var _this$props = _this.props,
            options = _this$props.options,
            onLoadProgress = _this$props.onLoadProgress,
            onPassword = _this$props.onPassword;
        _this.loadingTask = pdf.exports.getDocument(_objectSpread$2(_objectSpread$2({}, source), options));
        _this.loadingTask.onPassword = onPassword;

        if (onLoadProgress) {
          _this.loadingTask.onProgress = onLoadProgress;
        }

        var cancellable = makeCancellablePromise(_this.loadingTask.promise);
        _this.runningTask = cancellable;
        cancellable.promise.then(function (pdf) {
          _this.setState(function (prevState) {
            if (prevState.pdf && prevState.pdf.fingerprint === pdf.fingerprint) {
              return null;
            }

            return {
              pdf: pdf
            };
          }, _this.onLoadSuccess);
        })["catch"](function (error) {
          _this.onLoadError(error);
        });
      })["catch"](function (error) {
        _this.onSourceError(error);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "setupLinkService", function () {
      var _this$props2 = _this.props,
          externalLinkRel = _this$props2.externalLinkRel,
          externalLinkTarget = _this$props2.externalLinkTarget;

      _this.linkService.setViewer(_this.viewer);

      _this.linkService.setExternalLinkRel(externalLinkRel);

      _this.linkService.setExternalLinkTarget(externalLinkTarget);
    });

    _defineProperty(_assertThisInitialized(_this), "onSourceSuccess", function () {
      var onSourceSuccess = _this.props.onSourceSuccess;
      if (onSourceSuccess) onSourceSuccess();
    });

    _defineProperty(_assertThisInitialized(_this), "onSourceError", function (error) {
      warning(error);
      var onSourceError = _this.props.onSourceError;
      if (onSourceError) onSourceError(error);
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {
      var onLoadSuccess = _this.props.onLoadSuccess;
      var pdf = _this.state.pdf;
      if (onLoadSuccess) onLoadSuccess(pdf);
      _this.pages = new Array(pdf.numPages);

      _this.linkService.setDocument(pdf);
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {
      _this.setState({
        pdf: false
      });

      warning(error);
      var onLoadError = _this.props.onLoadError;
      if (onLoadError) onLoadError(error);
    });

    _defineProperty(_assertThisInitialized(_this), "findDocumentSource", function () {
      return new Promise(function (resolve) {
        var file = _this.props.file;

        if (!file) {
          resolve(null);
        } // File is a string


        if (typeof file === 'string') {
          if (isDataURI(file)) {
            var fileByteString = dataURItoByteString(file);
            resolve({
              data: fileByteString
            });
          }

          displayCORSWarning();
          resolve({
            url: file
          });
        } // File is PDFDataRangeTransport


        if (file instanceof PDFDataRangeTransport) {
          resolve({
            range: file
          });
        } // File is an ArrayBuffer


        if (isArrayBuffer(file)) {
          resolve({
            data: file
          });
        }
        /**
         * The cases below are browser-only.
         * If you're running on a non-browser environment, these cases will be of no use.
         */


        if (isBrowser) {
          // File is a Blob
          if (isBlob(file) || isFile$1(file)) {
            loadFromFile(file).then(function (data) {
              resolve({
                data: data
              });
            });
            return;
          }
        } // At this point, file must be an object


        invariant(_typeof$1(file) === 'object', 'Invalid parameter in file, need either Uint8Array, string or a parameter object');
        invariant(file.url || file.data || file.range, 'Invalid parameter object: need either .data, .range or .url'); // File .url is a string

        if (typeof file.url === 'string') {
          if (isDataURI(file.url)) {
            var url = file.url,
                otherParams = _objectWithoutProperties(file, _excluded);

            var _fileByteString = dataURItoByteString(url);

            resolve(_objectSpread$2({
              data: _fileByteString
            }, otherParams));
          }

          displayCORSWarning();
        }

        resolve(file);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "registerPage", function (pageIndex, ref) {
      _this.pages[pageIndex] = ref;
    });

    _defineProperty(_assertThisInitialized(_this), "unregisterPage", function (pageIndex) {
      delete _this.pages[pageIndex];
    });

    return _this;
  }

  _createClass(Document, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.loadDocument();
      this.setupLinkService();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var file = this.props.file;

      if (file !== prevProps.file) {
        this.loadDocument();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // If rendering is in progress, let's cancel it
      cancelRunningTask(this.runningTask); // If loading is in progress, let's destroy it

      if (this.loadingTask) this.loadingTask.destroy();
    }
  }, {
    key: "childContext",
    get: function get() {
      var linkService = this.linkService,
          registerPage = this.registerPage,
          unregisterPage = this.unregisterPage;
      var _this$props3 = this.props,
          imageResourcesPath = _this$props3.imageResourcesPath,
          renderMode = _this$props3.renderMode,
          rotate = _this$props3.rotate;
      var pdf = this.state.pdf;
      return {
        imageResourcesPath: imageResourcesPath,
        linkService: linkService,
        pdf: pdf,
        registerPage: registerPage,
        renderMode: renderMode,
        rotate: rotate,
        unregisterPage: unregisterPage
      };
    }
  }, {
    key: "eventProps",
    get: function get() {
      var _this2 = this;

      return makeEventProps(this.props, function () {
        return _this2.state.pdf;
      });
    }
    /**
     * Called when a document source is resolved correctly
     */

  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children = this.props.children;
      return /*#__PURE__*/React.createElement(DocumentContext.Provider, {
        value: this.childContext
      }, children);
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var file = this.props.file;
      var pdf = this.state.pdf;

      if (!file) {
        var noData = this.props.noData;
        return /*#__PURE__*/React.createElement(Message, {
          type: "no-data"
        }, typeof noData === 'function' ? noData() : noData);
      }

      if (pdf === null) {
        var loading = this.props.loading;
        return /*#__PURE__*/React.createElement(Message, {
          type: "loading"
        }, typeof loading === 'function' ? loading() : loading);
      }

      if (pdf === false) {
        var error = this.props.error;
        return /*#__PURE__*/React.createElement(Message, {
          type: "error"
        }, typeof error === 'function' ? error() : error);
      }

      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          className = _this$props4.className,
          inputRef = _this$props4.inputRef;
      return /*#__PURE__*/React.createElement("div", _extends({
        className: mergeClassNames('react-pdf__Document', className),
        ref: inputRef
      }, this.eventProps), this.renderContent());
    }
  }]);

  return Document;
}(PureComponent);
Document.defaultProps = {
  error: 'Failed to load PDF file.',
  loading: 'Loading PDF…',
  noData: 'No PDF file specified.',
  onPassword: function onPassword(callback, reason) {
    switch (reason) {
      case PasswordResponses.NEED_PASSWORD:
        {
          // eslint-disable-next-line no-alert
          var password = prompt('Enter the password to open this PDF file.');
          callback(password);
          break;
        }

      case PasswordResponses.INCORRECT_PASSWORD:
        {
          // eslint-disable-next-line no-alert
          var _password = prompt('Invalid password. Please try again.');

          callback(_password);
          break;
        }
    }
  }
};
var isFunctionOrNode$1 = propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.node]);
Document.propTypes = _objectSpread$2(_objectSpread$2({}, eventProps), {}, {
  children: propTypes.exports.node,
  className: isClassName,
  error: isFunctionOrNode$1,
  externalLinkRel: propTypes.exports.string,
  externalLinkTarget: propTypes.exports.string,
  file: isFile,
  imageResourcesPath: propTypes.exports.string,
  inputRef: isRef,
  loading: isFunctionOrNode$1,
  noData: isFunctionOrNode$1,
  onItemClick: propTypes.exports.func,
  onLoadError: propTypes.exports.func,
  onLoadProgress: propTypes.exports.func,
  onLoadSuccess: propTypes.exports.func,
  onPassword: propTypes.exports.func,
  onSourceError: propTypes.exports.func,
  onSourceSuccess: propTypes.exports.func,
  rotate: propTypes.exports.number
});

var isDestination = propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.arrayOf(propTypes.exports.any)]);
({
  item: propTypes.exports.shape({
    dest: isDestination,
    items: propTypes.exports.arrayOf(propTypes.exports.shape({
      dest: isDestination,
      title: propTypes.exports.string
    })),
    title: propTypes.exports.string
  }).isRequired,
  onClick: propTypes.exports.func,
  pdf: isPdf.isRequired
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
_objectSpread$1({
  className: isClassName,
  inputRef: isRef,
  onItemClick: propTypes.exports.func,
  onLoadError: propTypes.exports.func,
  onLoadSuccess: propTypes.exports.func,
  pdf: isPdf
}, eventProps);

/**
 * A function that merges React refs into one.
 * Supports both functions and ref objects created using createRef() and useRef().
 *
 * Usage:
 * ```jsx
 * <div ref={mergeRefs(ref1, ref2, ref3)} />
 * ```
 *
 * @param {...Array<Function|object>} inputRefs Array of refs
 * @returns {Function} Merged refs
 */
function mergeRefs() {
  for (var _len = arguments.length, inputRefs = new Array(_len), _key = 0; _key < _len; _key++) {
    inputRefs[_key] = arguments[_key];
  }

  var filteredInputRefs = inputRefs.filter(Boolean);

  if (filteredInputRefs.length <= 1) {
    return filteredInputRefs[0];
  }

  return function mergedRefs(ref) {
    filteredInputRefs.forEach(function (inputRef) {
      if (typeof inputRef === 'function') {
        inputRef(ref);
      } else {
        // eslint-disable-next-line no-param-reassign
        inputRef.current = ref;
      }
    });
  };
}

var PageContext = /*#__PURE__*/createContext(null);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var ANNOTATION_MODE = pdf.exports.AnnotationMode;
var PageCanvasInternal = /*#__PURE__*/function (_PureComponent) {
  _inherits(PageCanvasInternal, _PureComponent);

  var _super = _createSuper$5(PageCanvasInternal);

  function PageCanvasInternal() {
    var _this;

    _classCallCheck(this, PageCanvasInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "canvasElement", /*#__PURE__*/createRef());

    _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function () {
      _this.renderer = null;
      var _this$props = _this.props,
          onRenderSuccess = _this$props.onRenderSuccess,
          page = _this$props.page,
          scale = _this$props.scale;
      if (onRenderSuccess) onRenderSuccess(makePageCallback(page, scale));
    });

    _defineProperty(_assertThisInitialized(_this), "onRenderError", function (error) {
      if (isCancelException(error)) {
        return;
      }

      warning(error);
      var onRenderError = _this.props.onRenderError;
      if (onRenderError) onRenderError(error);
    });

    _defineProperty(_assertThisInitialized(_this), "drawPageOnCanvas", function () {
      var canvas = _this.canvasElement.current;

      if (!canvas) {
        return null;
      }

      var _assertThisInitialize = _assertThisInitialized(_this),
          renderViewport = _assertThisInitialize.renderViewport,
          viewport = _assertThisInitialize.viewport;

      var _this$props2 = _this.props,
          canvasBackground = _this$props2.canvasBackground,
          page = _this$props2.page,
          renderForms = _this$props2.renderForms;
      canvas.width = renderViewport.width;
      canvas.height = renderViewport.height;
      canvas.style.width = "".concat(Math.floor(viewport.width), "px");
      canvas.style.height = "".concat(Math.floor(viewport.height), "px");
      var renderContext = {
        annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,

        get canvasContext() {
          return canvas.getContext('2d');
        },

        viewport: renderViewport
      };

      if (canvasBackground) {
        renderContext.background = canvasBackground;
      } // If another render is in progress, let's cancel it


      _this.cancelRenderingTask();

      _this.renderer = page.render(renderContext);
      return _this.renderer.promise.then(_this.onRenderSuccess)["catch"](_this.onRenderError);
    });

    return _this;
  }

  _createClass(PageCanvasInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.drawPageOnCanvas();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props3 = this.props,
          canvasBackground = _this$props3.canvasBackground,
          page = _this$props3.page,
          renderForms = _this$props3.renderForms;

      if (canvasBackground !== prevProps.canvasBackground || renderForms !== prevProps.renderForms) {
        // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.
        page.cleanup();
        this.drawPageOnCanvas();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelRenderingTask();
      var canvas = this.canvasElement.current;
      /**
       * Zeroing the width and height cause most browsers to release graphics
       * resources immediately, which can greatly reduce memory consumption.
       */

      if (canvas) {
        canvas.width = 0;
        canvas.height = 0;
      }
    }
  }, {
    key: "cancelRenderingTask",
    value: function cancelRenderingTask() {
      if (this.renderer) {
        this.renderer.cancel();
        this.renderer = null;
      }
    }
    /**
     * Called when a page is rendered successfully.
     */

  }, {
    key: "renderViewport",
    get: function get() {
      var _this$props4 = this.props,
          page = _this$props4.page,
          rotate = _this$props4.rotate,
          scale = _this$props4.scale;
      var pixelRatio = getPixelRatio();
      return page.getViewport({
        scale: scale * pixelRatio,
        rotation: rotate
      });
    }
  }, {
    key: "viewport",
    get: function get() {
      var _this$props5 = this.props,
          page = _this$props5.page,
          rotate = _this$props5.rotate,
          scale = _this$props5.scale;
      return page.getViewport({
        scale: scale,
        rotation: rotate
      });
    }
  }, {
    key: "render",
    value: function render() {
      var canvasRef = this.props.canvasRef;
      return /*#__PURE__*/React.createElement("canvas", {
        className: "react-pdf__Page__canvas",
        dir: "ltr",
        ref: mergeRefs(canvasRef, this.canvasElement),
        style: {
          display: 'block',
          userSelect: 'none'
        }
      });
    }
  }]);

  return PageCanvasInternal;
}(PureComponent);
PageCanvasInternal.propTypes = {
  canvasBackground: propTypes.exports.string,
  canvasRef: isRef,
  onRenderError: propTypes.exports.func,
  onRenderSuccess: propTypes.exports.func,
  page: isPage.isRequired,
  renderForms: propTypes.exports.bool,
  rotate: isRotate,
  scale: propTypes.exports.number.isRequired
};
function PageCanvas(props) {
  return /*#__PURE__*/React.createElement(PageContext.Consumer, null, function (context) {
    return /*#__PURE__*/React.createElement(PageCanvasInternal, _extends({}, context, props));
  });
}

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var PageSVGInternal = /*#__PURE__*/function (_PureComponent) {
  _inherits(PageSVGInternal, _PureComponent);

  var _super = _createSuper$4(PageSVGInternal);

  function PageSVGInternal() {
    var _this;

    _classCallCheck(this, PageSVGInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      svg: null
    });

    _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function () {
      _this.renderer = null;
      var _this$props = _this.props,
          onRenderSuccess = _this$props.onRenderSuccess,
          page = _this$props.page,
          scale = _this$props.scale;
      if (onRenderSuccess) onRenderSuccess(makePageCallback(page, scale));
    });

    _defineProperty(_assertThisInitialized(_this), "onRenderError", function (error) {
      if (isCancelException(error)) {
        return;
      }

      warning(error);
      var onRenderError = _this.props.onRenderError;
      if (onRenderError) onRenderError(error);
    });

    _defineProperty(_assertThisInitialized(_this), "renderSVG", function () {
      var page = _this.props.page;
      _this.renderer = page.getOperatorList();
      return _this.renderer.then(function (operatorList) {
        var svgGfx = new pdf.exports.SVGGraphics(page.commonObjs, page.objs);
        _this.renderer = svgGfx.getSVG(operatorList, _this.viewport).then(function (svg) {
          _this.setState({
            svg: svg
          }, _this.onRenderSuccess);
        })["catch"](_this.onRenderError);
      })["catch"](_this.onRenderError);
    });

    _defineProperty(_assertThisInitialized(_this), "drawPageOnContainer", function (element) {
      var svg = _this.state.svg;

      if (!element || !svg) {
        return;
      } // Append SVG element to the main container, if this hasn't been done already


      if (!element.firstElementChild) {
        element.appendChild(svg);
      }

      var _this$viewport = _this.viewport,
          width = _this$viewport.width,
          height = _this$viewport.height;
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
    });

    return _this;
  }

  _createClass(PageSVGInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.renderSVG();
    }
    /**
     * Called when a page is rendered successfully.
     */

  }, {
    key: "viewport",
    get: function get() {
      var _this$props2 = this.props,
          page = _this$props2.page,
          rotate = _this$props2.rotate,
          scale = _this$props2.scale;
      return page.getViewport({
        scale: scale,
        rotation: rotate
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$viewport2 = this.viewport,
          width = _this$viewport2.width,
          height = _this$viewport2.height;
      return /*#__PURE__*/React.createElement("div", {
        className: "react-pdf__Page__svg" // Note: This cannot be shortened, as we need this function to be called with each render.
        ,
        ref: function ref(_ref) {
          return _this2.drawPageOnContainer(_ref);
        },
        style: {
          display: 'block',
          backgroundColor: 'white',
          overflow: 'hidden',
          width: width,
          height: height,
          userSelect: 'none'
        }
      });
    }
  }]);

  return PageSVGInternal;
}(PureComponent);
PageSVGInternal.propTypes = {
  onRenderError: propTypes.exports.func,
  onRenderSuccess: propTypes.exports.func,
  page: isPage.isRequired,
  rotate: isRotate,
  scale: propTypes.exports.number.isRequired
};
function PageSVG(props) {
  return /*#__PURE__*/React.createElement(PageContext.Consumer, null, function (context) {
    return /*#__PURE__*/React.createElement(PageSVGInternal, _extends({}, context, props));
  });
}

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var TextLayerItemInternal = /*#__PURE__*/function (_PureComponent) {
  _inherits(TextLayerItemInternal, _PureComponent);

  var _super = _createSuper$3(TextLayerItemInternal);

  function TextLayerItemInternal() {
    var _this;

    _classCallCheck(this, TextLayerItemInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "itemElement", /*#__PURE__*/createRef());

    _defineProperty(_assertThisInitialized(_this), "getElementWidth", function (element) {
      var _assertThisInitialize = _assertThisInitialized(_this),
          sideways = _assertThisInitialize.sideways;

      return element.getBoundingClientRect()[sideways ? 'height' : 'width'];
    });

    return _this;
  }

  _createClass(TextLayerItemInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.alignTextItem();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.alignTextItem();
    }
  }, {
    key: "unrotatedViewport",
    get: function get() {
      var _this$props = this.props,
          page = _this$props.page,
          scale = _this$props.scale;
      return page.getViewport({
        scale: scale
      });
    }
    /**
     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
     * text content.
     */

  }, {
    key: "rotate",
    get: function get() {
      var _this$props2 = this.props,
          page = _this$props2.page,
          rotate = _this$props2.rotate;
      return rotate - page.rotate;
    }
  }, {
    key: "sideways",
    get: function get() {
      var rotate = this.rotate;
      return rotate % 180 !== 0;
    }
  }, {
    key: "defaultSideways",
    get: function get() {
      var rotation = this.unrotatedViewport.rotation;
      return rotation % 180 !== 0;
    }
  }, {
    key: "fontSize",
    get: function get() {
      var transform = this.props.transform;
      var defaultSideways = this.defaultSideways;

      var _transform = _slicedToArray(transform, 2),
          fontHeightPx = _transform[0],
          fontWidthPx = _transform[1];

      return defaultSideways ? fontWidthPx : fontHeightPx;
    }
  }, {
    key: "top",
    get: function get() {
      var transform = this.props.transform;
      var viewport = this.unrotatedViewport,
          defaultSideways = this.defaultSideways;

      var _transform2 = _slicedToArray(transform, 6),

      /* fontHeightPx */

      /* fontWidthPx */
      offsetX = _transform2[2],
          offsetY = _transform2[3],
          x = _transform2[4],
          y = _transform2[5];

      var _viewport$viewBox = _slicedToArray(viewport.viewBox, 4),

      /* xMin */
      yMin
      /* xMax */
      = _viewport$viewBox[1],
          yMax = _viewport$viewBox[3];

      return defaultSideways ? x + offsetX + yMin : yMax - (y + offsetY);
    }
  }, {
    key: "left",
    get: function get() {
      var transform = this.props.transform;
      var viewport = this.unrotatedViewport,
          defaultSideways = this.defaultSideways;

      var _transform3 = _slicedToArray(transform, 6),

      /* fontHeightPx */

      /* fontWidthPx */

      /* offsetX */

      /* offsetY */
      x = _transform3[4],
          y = _transform3[5];

      var _viewport$viewBox2 = _slicedToArray(viewport.viewBox, 1),
          xMin = _viewport$viewBox2[0];

      return defaultSideways ? y - xMin : x - xMin;
    }
  }, {
    key: "getFontData",
    value: function getFontData(fontName) {
      var page = this.props.page;
      return new Promise(function (resolve) {
        page.commonObjs.get(fontName, resolve);
      });
    }
  }, {
    key: "alignTextItem",
    value: function alignTextItem() {
      var _this2 = this;

      var element = this.itemElement.current;

      if (!element) {
        return;
      }

      element.style.transform = '';
      var _this$props3 = this.props,
          fontName = _this$props3.fontName,
          scale = _this$props3.scale,
          width = _this$props3.width;
      element.style.fontFamily = "".concat(fontName, ", sans-serif");
      this.getFontData(fontName).then(function (fontData) {
        var fallbackFontName = fontData ? fontData.fallbackName : 'sans-serif';
        element.style.fontFamily = "".concat(fontName, ", ").concat(fallbackFontName);
        var targetWidth = width * scale;

        var actualWidth = _this2.getElementWidth(element);

        var transform = "scaleX(".concat(targetWidth / actualWidth, ")");
        var ascent = fontData ? fontData.ascent : 0;

        if (ascent) {
          transform += " translateY(".concat((1 - ascent) * 100, "%)");
        }

        element.style.transform = transform;
        element.style.WebkitTransform = transform;
      });
    }
  }, {
    key: "render",
    value: function render() {
      var fontSize = this.fontSize,
          top = this.top,
          left = this.left;
      var _this$props4 = this.props,
          customTextRenderer = _this$props4.customTextRenderer,
          scale = _this$props4.scale,
          text = _this$props4.str;
      return /*#__PURE__*/React.createElement("span", {
        ref: this.itemElement,
        style: {
          height: '1em',
          fontFamily: 'sans-serif',
          fontSize: "".concat(fontSize * scale, "px"),
          position: 'absolute',
          top: "".concat(top * scale, "px"),
          left: "".concat(left * scale, "px"),
          transformOrigin: 'left bottom',
          whiteSpace: 'pre',
          pointerEvents: 'all'
        }
      }, customTextRenderer ? customTextRenderer(this.props) : text);
    }
  }]);

  return TextLayerItemInternal;
}(PureComponent);
TextLayerItemInternal.propTypes = {
  customTextRenderer: propTypes.exports.func,
  fontName: propTypes.exports.string.isRequired,
  itemIndex: propTypes.exports.number.isRequired,
  page: isPage.isRequired,
  rotate: isRotate,
  scale: propTypes.exports.number,
  str: propTypes.exports.string.isRequired,
  transform: propTypes.exports.arrayOf(propTypes.exports.number).isRequired,
  width: propTypes.exports.number.isRequired
};
function TextLayerItem(props) {
  return /*#__PURE__*/React.createElement(PageContext.Consumer, null, function (context) {
    return /*#__PURE__*/React.createElement(TextLayerItemInternal, _extends({}, context, props));
  });
}

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var TextLayerInternal = /*#__PURE__*/function (_PureComponent) {
  _inherits(TextLayerInternal, _PureComponent);

  var _super = _createSuper$2(TextLayerInternal);

  function TextLayerInternal() {
    var _this;

    _classCallCheck(this, TextLayerInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      textItems: null
    });

    _defineProperty(_assertThisInitialized(_this), "loadTextItems", function () {
      var page = _this.props.page;
      var cancellable = makeCancellablePromise(page.getTextContent());
      _this.runningTask = cancellable;
      cancellable.promise.then(function (_ref) {
        var textItems = _ref.items;

        _this.setState({
          textItems: textItems
        }, _this.onLoadSuccess);
      })["catch"](function (error) {
        _this.onLoadError(error);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {
      var onGetTextSuccess = _this.props.onGetTextSuccess;
      var textItems = _this.state.textItems;
      if (onGetTextSuccess) onGetTextSuccess(textItems);
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {
      _this.setState({
        textItems: false
      });

      warning(error);
      var onGetTextError = _this.props.onGetTextError;
      if (onGetTextError) onGetTextError(error);
    });

    return _this;
  }

  _createClass(TextLayerInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var page = this.props.page;
      invariant(page, 'Attempted to load page text content, but no page was specified.');
      this.loadTextItems();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var page = this.props.page;

      if (prevProps.page && page !== prevProps.page) {
        this.loadTextItems();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "unrotatedViewport",
    get: function get() {
      var _this$props = this.props,
          page = _this$props.page,
          scale = _this$props.scale;
      return page.getViewport({
        scale: scale
      });
    }
    /**
     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate
     * text content.
     */

  }, {
    key: "rotate",
    get: function get() {
      var _this$props2 = this.props,
          page = _this$props2.page,
          rotate = _this$props2.rotate;
      return rotate - page.rotate;
    }
  }, {
    key: "renderTextItems",
    value: function renderTextItems() {
      var textItems = this.state.textItems;

      if (!textItems) {
        return null;
      }

      return textItems.map(function (textItem, itemIndex) {
        return /*#__PURE__*/React.createElement(TextLayerItem // eslint-disable-next-line react/no-array-index-key
        , _extends({
          key: itemIndex,
          itemIndex: itemIndex
        }, textItem));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var viewport = this.unrotatedViewport,
          rotate = this.rotate;
      return /*#__PURE__*/React.createElement("div", {
        className: "react-pdf__Page__textContent",
        style: {
          position: 'absolute',
          top: '50%',
          left: '50%',
          width: "".concat(viewport.width, "px"),
          height: "".concat(viewport.height, "px"),
          color: 'transparent',
          transform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),
          WebkitTransform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),
          pointerEvents: 'none'
        }
      }, this.renderTextItems());
    }
  }]);

  return TextLayerInternal;
}(PureComponent);
TextLayerInternal.propTypes = {
  onGetTextError: propTypes.exports.func,
  onGetTextSuccess: propTypes.exports.func,
  page: isPage.isRequired,
  rotate: isRotate,
  scale: propTypes.exports.number
};
function TextLayer(props) {
  return /*#__PURE__*/React.createElement(PageContext.Consumer, null, function (context) {
    return /*#__PURE__*/React.createElement(TextLayerInternal, _extends({}, context, props));
  });
}

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var AnnotationLayerInternal = /*#__PURE__*/function (_PureComponent) {
  _inherits(AnnotationLayerInternal, _PureComponent);

  var _super = _createSuper$1(AnnotationLayerInternal);

  function AnnotationLayerInternal() {
    var _this;

    _classCallCheck(this, AnnotationLayerInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      annotations: null
    });

    _defineProperty(_assertThisInitialized(_this), "layerElement", /*#__PURE__*/createRef());

    _defineProperty(_assertThisInitialized(_this), "loadAnnotations", function () {
      var page = _this.props.page;
      var cancellable = makeCancellablePromise(page.getAnnotations());
      _this.runningTask = cancellable;
      cancellable.promise.then(function (annotations) {
        _this.setState({
          annotations: annotations
        }, _this.onLoadSuccess);
      })["catch"](function (error) {
        _this.onLoadError(error);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {
      var onGetAnnotationsSuccess = _this.props.onGetAnnotationsSuccess;
      var annotations = _this.state.annotations;
      if (onGetAnnotationsSuccess) onGetAnnotationsSuccess(annotations);
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {
      _this.setState({
        annotations: false
      });

      warning(error);
      var onGetAnnotationsError = _this.props.onGetAnnotationsError;
      if (onGetAnnotationsError) onGetAnnotationsError(error);
    });

    _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function () {
      var onRenderAnnotationLayerSuccess = _this.props.onRenderAnnotationLayerSuccess;
      if (onRenderAnnotationLayerSuccess) onRenderAnnotationLayerSuccess();
    });

    _defineProperty(_assertThisInitialized(_this), "onRenderError", function (error) {
      warning(error);
      var onRenderAnnotationLayerError = _this.props.onRenderAnnotationLayerError;
      if (onRenderAnnotationLayerError) onRenderAnnotationLayerError(error);
    });

    return _this;
  }

  _createClass(AnnotationLayerInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var page = this.props.page;
      invariant(page, 'Attempted to load page annotations, but no page was specified.');
      this.loadAnnotations();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props = this.props,
          page = _this$props.page,
          renderForms = _this$props.renderForms;

      if (prevProps.page && page !== prevProps.page || renderForms !== prevProps.renderForms) {
        this.loadAnnotations();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "viewport",
    get: function get() {
      var _this$props2 = this.props,
          page = _this$props2.page,
          rotate = _this$props2.rotate,
          scale = _this$props2.scale;
      return page.getViewport({
        scale: scale,
        rotation: rotate
      });
    }
  }, {
    key: "renderAnnotationLayer",
    value: function renderAnnotationLayer() {
      var annotations = this.state.annotations;

      if (!annotations) {
        return;
      }

      var _this$props3 = this.props,
          imageResourcesPath = _this$props3.imageResourcesPath,
          linkService = _this$props3.linkService,
          page = _this$props3.page,
          renderForms = _this$props3.renderForms;
      var viewport = this.viewport.clone({
        dontFlip: true
      });
      var parameters = {
        annotations: annotations,
        div: this.layerElement.current,
        imageResourcesPath: imageResourcesPath,
        linkService: linkService,
        page: page,
        renderForms: renderForms,
        viewport: viewport
      };
      this.layerElement.current.innerHTML = '';

      try {
        pdf.exports.AnnotationLayer.render(parameters);
        this.onRenderSuccess();
      } catch (error) {
        this.onRenderError(error);
      }
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement("div", {
        className: "react-pdf__Page__annotations annotationLayer",
        ref: this.layerElement
      }, this.renderAnnotationLayer());
    }
  }]);

  return AnnotationLayerInternal;
}(PureComponent);
AnnotationLayerInternal.propTypes = {
  imageResourcesPath: propTypes.exports.string,
  linkService: isLinkService.isRequired,
  onGetAnnotationsError: propTypes.exports.func,
  onGetAnnotationsSuccess: propTypes.exports.func,
  onRenderAnnotationLayerError: propTypes.exports.func,
  onRenderAnnotationLayerSuccess: propTypes.exports.func,
  page: isPage,
  renderForms: propTypes.exports.bool,
  rotate: isRotate,
  scale: propTypes.exports.number
};

var AnnotationLayer = function AnnotationLayer(props) {
  return /*#__PURE__*/React.createElement(DocumentContext.Consumer, null, function (documentContext) {
    return /*#__PURE__*/React.createElement(PageContext.Consumer, null, function (pageContext) {
      return /*#__PURE__*/React.createElement(AnnotationLayerInternal, _extends({}, documentContext, pageContext, props));
    });
  });
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var defaultScale = 1;
var PageInternal = /*#__PURE__*/function (_PureComponent) {
  _inherits(PageInternal, _PureComponent);

  var _super = _createSuper(PageInternal);

  function PageInternal() {
    var _this;

    _classCallCheck(this, PageInternal);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      page: null
    });

    _defineProperty(_assertThisInitialized(_this), "pageElement", /*#__PURE__*/createRef());

    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {
      var _this$props = _this.props,
          onLoadSuccess = _this$props.onLoadSuccess,
          registerPage = _this$props.registerPage;
      var page = _this.state.page;
      if (onLoadSuccess) onLoadSuccess(makePageCallback(page, _this.scale));
      if (registerPage) registerPage(_this.pageIndex, _this.pageElement.current);
    });

    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {
      _this.setState({
        page: false
      });

      warning(error);
      var onLoadError = _this.props.onLoadError;
      if (onLoadError) onLoadError(error);
    });

    _defineProperty(_assertThisInitialized(_this), "loadPage", function () {
      var pdf = _this.props.pdf;

      var pageNumber = _this.getPageNumber();

      if (!pageNumber) {
        return;
      }

      _this.setState(function (prevState) {
        if (!prevState.page) {
          return null;
        }

        return {
          page: null
        };
      });

      var cancellable = makeCancellablePromise(pdf.getPage(pageNumber));
      _this.runningTask = cancellable;
      cancellable.promise.then(function (page) {
        _this.setState({
          page: page
        }, _this.onLoadSuccess);
      })["catch"](function (error) {
        _this.onLoadError(error);
      });
    });

    return _this;
  }

  _createClass(PageInternal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var pdf = this.props.pdf;
      invariant(pdf, 'Attempted to load a page, but no document was specified.');
      this.loadPage();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var pdf = this.props.pdf;

      if (prevProps.pdf && pdf !== prevProps.pdf || this.getPageNumber() !== this.getPageNumber(prevProps)) {
        var unregisterPage = this.props.unregisterPage;
        if (unregisterPage) unregisterPage(this.getPageIndex(prevProps));
        this.loadPage();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var unregisterPage = this.props.unregisterPage;
      if (unregisterPage) unregisterPage(this.pageIndex);
      cancelRunningTask(this.runningTask);
    }
  }, {
    key: "childContext",
    get: function get() {
      var page = this.state.page;

      if (!page) {
        return {};
      }

      var _this$props2 = this.props,
          canvasBackground = _this$props2.canvasBackground,
          customTextRenderer = _this$props2.customTextRenderer,
          onGetAnnotationsError = _this$props2.onGetAnnotationsError,
          onGetAnnotationsSuccess = _this$props2.onGetAnnotationsSuccess,
          onGetTextError = _this$props2.onGetTextError,
          onGetTextSuccess = _this$props2.onGetTextSuccess,
          onRenderAnnotationLayerError = _this$props2.onRenderAnnotationLayerError,
          onRenderAnnotationLayerSuccess = _this$props2.onRenderAnnotationLayerSuccess,
          onRenderError = _this$props2.onRenderError,
          onRenderSuccess = _this$props2.onRenderSuccess,
          renderForms = _this$props2.renderForms,
          renderInteractiveForms = _this$props2.renderInteractiveForms;
      return {
        canvasBackground: canvasBackground,
        customTextRenderer: customTextRenderer,
        onGetAnnotationsError: onGetAnnotationsError,
        onGetAnnotationsSuccess: onGetAnnotationsSuccess,
        onGetTextError: onGetTextError,
        onGetTextSuccess: onGetTextSuccess,
        onRenderAnnotationLayerError: onRenderAnnotationLayerError,
        onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccess,
        onRenderError: onRenderError,
        onRenderSuccess: onRenderSuccess,
        page: page,
        renderForms: renderForms !== null && renderForms !== void 0 ? renderForms : renderInteractiveForms,
        // For backward compatibility
        rotate: this.rotate,
        scale: this.scale
      };
    }
    /**
     * Called when a page is loaded successfully
     */

  }, {
    key: "getPageIndex",
    value: function getPageIndex() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      if (isProvided(props.pageNumber)) {
        return props.pageNumber - 1;
      }

      if (isProvided(props.pageIndex)) {
        return props.pageIndex;
      }

      return null;
    }
  }, {
    key: "getPageNumber",
    value: function getPageNumber() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      if (isProvided(props.pageNumber)) {
        return props.pageNumber;
      }

      if (isProvided(props.pageIndex)) {
        return props.pageIndex + 1;
      }

      return null;
    }
  }, {
    key: "pageIndex",
    get: function get() {
      return this.getPageIndex();
    }
  }, {
    key: "pageNumber",
    get: function get() {
      return this.getPageNumber();
    }
  }, {
    key: "rotate",
    get: function get() {
      var rotate = this.props.rotate;

      if (isProvided(rotate)) {
        return rotate;
      }

      var page = this.state.page;

      if (!page) {
        return null;
      }

      return page.rotate;
    }
  }, {
    key: "scale",
    get: function get() {
      var page = this.state.page;

      if (!page) {
        return null;
      }

      var _this$props3 = this.props,
          scale = _this$props3.scale,
          width = _this$props3.width,
          height = _this$props3.height;
      var rotate = this.rotate; // Be default, we'll render page at 100% * scale width.

      var pageScale = 1; // Passing scale explicitly null would cause the page not to render

      var scaleWithDefault = scale === null ? defaultScale : scale; // If width/height is defined, calculate the scale of the page so it could be of desired width.

      if (width || height) {
        var viewport = page.getViewport({
          scale: 1,
          rotation: rotate
        });
        pageScale = width ? width / viewport.width : height / viewport.height;
      }

      return scaleWithDefault * pageScale;
    }
  }, {
    key: "eventProps",
    get: function get() {
      var _this2 = this;

      return makeEventProps(this.props, function () {
        var page = _this2.state.page;

        if (!page) {
          return page;
        }

        return makePageCallback(page, _this2.scale);
      });
    }
  }, {
    key: "pageKey",
    get: function get() {
      var page = this.state.page;
      return "".concat(page.pageIndex, "@").concat(this.scale, "/").concat(this.rotate);
    }
  }, {
    key: "pageKeyNoScale",
    get: function get() {
      var page = this.state.page;
      return "".concat(page.pageIndex, "/").concat(this.rotate);
    }
  }, {
    key: "renderMainLayer",
    value: function renderMainLayer() {
      var _this$props4 = this.props,
          canvasRef = _this$props4.canvasRef,
          renderMode = _this$props4.renderMode;

      switch (renderMode) {
        case 'none':
          return null;

        case 'svg':
          return /*#__PURE__*/React.createElement(PageSVG, {
            key: "".concat(this.pageKeyNoScale, "_svg")
          });

        case 'canvas':
        default:
          return /*#__PURE__*/React.createElement(PageCanvas, {
            key: "".concat(this.pageKey, "_canvas"),
            canvasRef: canvasRef
          });
      }
    }
  }, {
    key: "renderTextLayer",
    value: function renderTextLayer() {
      var renderTextLayer = this.props.renderTextLayer;

      if (!renderTextLayer) {
        return null;
      }

      return /*#__PURE__*/React.createElement(TextLayer, {
        key: "".concat(this.pageKey, "_text")
      });
    }
  }, {
    key: "renderAnnotationLayer",
    value: function renderAnnotationLayer() {
      var renderAnnotationLayer = this.props.renderAnnotationLayer;

      if (!renderAnnotationLayer) {
        return null;
      }
      /**
       * As of now, PDF.js 2.0.943 returns warnings on unimplemented annotations in SVG mode.
       * Therefore, as a fallback, we render "traditional" AnnotationLayer component.
       */


      return /*#__PURE__*/React.createElement(AnnotationLayer, {
        key: "".concat(this.pageKey, "_annotations")
      });
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children = this.props.children;
      return /*#__PURE__*/React.createElement(PageContext.Provider, {
        value: this.childContext
      }, this.renderMainLayer(), this.renderTextLayer(), this.renderAnnotationLayer(), children);
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var pageNumber = this.pageNumber;
      var pdf = this.props.pdf;
      var page = this.state.page;

      if (!pageNumber) {
        var noData = this.props.noData;
        return /*#__PURE__*/React.createElement(Message, {
          type: "no-data"
        }, typeof noData === 'function' ? noData() : noData);
      }

      if (pdf === null || page === null) {
        var loading = this.props.loading;
        return /*#__PURE__*/React.createElement(Message, {
          type: "loading"
        }, typeof loading === 'function' ? loading() : loading);
      }

      if (pdf === false || page === false) {
        var error = this.props.error;
        return /*#__PURE__*/React.createElement(Message, {
          type: "error"
        }, typeof error === 'function' ? error() : error);
      }

      return this.renderChildren();
    }
  }, {
    key: "render",
    value: function render() {
      var pageNumber = this.pageNumber;
      var _this$props5 = this.props,
          className = _this$props5.className,
          inputRef = _this$props5.inputRef;
      return /*#__PURE__*/React.createElement("div", _extends({
        className: mergeClassNames('react-pdf__Page', className),
        "data-page-number": pageNumber,
        ref: mergeRefs(inputRef, this.pageElement),
        style: {
          position: 'relative'
        }
      }, this.eventProps), this.renderContent());
    }
  }]);

  return PageInternal;
}(PureComponent);
PageInternal.defaultProps = {
  error: 'Failed to load the page.',
  loading: 'Loading page…',
  noData: 'No page specified.',
  renderAnnotationLayer: true,
  renderForms: false,
  renderMode: 'canvas',
  renderTextLayer: true,
  scale: defaultScale
};
var isFunctionOrNode = propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.node]);
PageInternal.propTypes = _objectSpread(_objectSpread({}, eventProps), {}, {
  canvasBackground: propTypes.exports.string,
  children: propTypes.exports.node,
  className: isClassName,
  customTextRenderer: propTypes.exports.func,
  error: isFunctionOrNode,
  height: propTypes.exports.number,
  imageResourcesPath: propTypes.exports.string,
  inputRef: isRef,
  loading: isFunctionOrNode,
  noData: isFunctionOrNode,
  onGetTextError: propTypes.exports.func,
  onGetTextSuccess: propTypes.exports.func,
  onLoadError: propTypes.exports.func,
  onLoadSuccess: propTypes.exports.func,
  onRenderError: propTypes.exports.func,
  onRenderSuccess: propTypes.exports.func,
  pageIndex: isPageIndex,
  pageNumber: isPageNumber,
  pdf: isPdf,
  registerPage: propTypes.exports.func,
  renderAnnotationLayer: propTypes.exports.bool,
  renderForms: propTypes.exports.bool,
  renderInteractiveForms: propTypes.exports.bool,
  // For backward compatibility
  renderMode: isRenderMode,
  renderTextLayer: propTypes.exports.bool,
  rotate: isRotate,
  scale: propTypes.exports.number,
  unregisterPage: propTypes.exports.func,
  width: propTypes.exports.number
});

function Page(props, ref) {
  return /*#__PURE__*/React.createElement(DocumentContext.Consumer, null, function (context) {
    return /*#__PURE__*/React.createElement(PageInternal, _extends({
      ref: ref
    }, context, props));
  });
}

var PdfPage = /*#__PURE__*/React.forwardRef(Page);

displayWorkerWarning();
pdf.exports.GlobalWorkerOptions.workerSrc = 'pdf.worker.js';

var options = {
    cMapUrl: PDF_C_MAP_URL,
    cMapPacked: true,
};
var TosPdf = function (_a) {
    var backendUrl = _a.backendUrl;
    var debug = useSettings().debug;
    var _b = useState(''), url = _b[0], setUrl = _b[1];
    var _c = useState(0), numPages = _c[0], setNumPages = _c[1];
    React.useEffect(function () {
        getTOSPDFLink(backendUrl)
            .then(function (redirect) {
            setUrl(redirect);
        })
            .catch(function (e) {
            debug && console.log(e);
        });
    }, []);
    function onDocumentLoadSuccess(_a) {
        var nextNumPages = _a.numPages;
        setNumPages(nextNumPages);
    }
    return url ? (jsxRuntime.exports.jsx("div", __assign({ style: {
            width: '100%',
            height: '25rem',
            overflowY: 'scroll',
            paddingTop: '4rem',
            backgroundColor: '#000000',
            color: 'transparent',
            scrollbarWidth: 'thin',
        } }, { children: jsxRuntime.exports.jsx(Document, __assign({ file: url, options: options, "data-id": "div-document-container-tos", onLoadError: function () { return debug && console.error; }, onLoadSuccess: onDocumentLoadSuccess }, { children: Array.from(new Array(numPages), function (_el, index) { return (jsxRuntime.exports.jsx(PdfPage, { width: 500, pageNumber: index + 1 }, "page_".concat(index + 1))); }) })) }))) : (jsxRuntime.exports.jsx("span", { children: "Loading Terms Of Service..." }));
};

var PageTOS = function (_a) {
    var backendUrl = _a.backendUrl;
    var navigate = useNavigation().navigate;
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("h1", { children: "Read and sign our Terms of Service." }), jsxRuntime.exports.jsx("section", { children: "You are required to acknowledge that you read and agree to the Ky0x Terms of Use & Privacy Policy and understand that Ky0x uses Third Party Service Providers to provide the requested Services." }), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx(TosPdf, { backendUrl: backendUrl }) }), jsxRuntime.exports.jsx("section", __assign({ className: "tos-accept" }, { children: "By clicking Accept, you agree to be bound by the Terms of Service." })), jsxRuntime.exports.jsxs("section", __assign({ className: "kyc-buttons" }, { children: [jsxRuntime.exports.jsx("button", __assign({ className: "kyc-button", onClick: function () { return navigate(Page$1.INTRO); } }, { children: "Go back" })), jsxRuntime.exports.jsx("button", __assign({ onClick: function () {
                            navigate(Page$1.SIGN_WALLET);
                        }, className: "kyc-button kyc-button-primary" }, { children: "Accept" }))] }))] }));
};

var useAuth = function () {
    var dispatch = useAppDispatch();
    var _a = useAppSelector(function (state) { return state.auth; }), jwt = _a.jwt, account = _a.account, customerId = _a.customerId;
    var setAuth$1 = useCallback(function (jwt) {
        dispatch(setAuth(jwt));
    }, [dispatch]);
    var resetAuth = useCallback(function () {
        dispatch(reset$8());
    }, [dispatch]);
    return useMemo(function () {
        return {
            jwt: jwt,
            account: account,
            setAuth: setAuth$1,
            resetAuth: resetAuth,
            customerId: customerId,
        };
    }, [jwt, account, customerId, setAuth$1]);
};

var ContactLinks = function () {
    var customerId = useAuth().customerId;
    var id = useAppSelector(function (store) { return store.veriffSession; }).id;
    var subject = "Contacting from the Quadrata Passport on-boarding";
    var cId = customerId ? "Customer ID: ".concat(customerId, "%0D%0A") : '';
    var veriffId = id ? "Veriff Session ID: ".concat(id, "%0D%0A") : '';
    var body = "".concat(cId).concat(veriffId, "<--- Please describe your issue below this line --->%0D%0A");
    return (jsxRuntime.exports.jsxs("section", __assign({ className: "kyc-contact-links" }, { children: [jsxRuntime.exports.jsx("a", __assign({ href: "https://discord.gg/67QgzrymHW", target: "_blank", rel: "noreferrer noopener" }, { children: "Quadrata Discord" })), jsxRuntime.exports.jsx("a", __assign({ href: "mailto:kyc@springlabs.com?subject=".concat(subject, "&body=").concat(body), target: "_blank", rel: "noreferrer noopener" }, { children: "kyc@springlabs.com" }))] })));
};

var PageAuthError = function () {
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("h1", { children: "Authentication Error" }), jsxRuntime.exports.jsx("section", { children: "Please include an account (wallet address) and a valid API key to use Quadrata KYC form, or report your issue using the links below." }), jsxRuntime.exports.jsx(ContactLinks, {})] }));
};

var login = function (_a) {
    var apiKey = _a.apiKey, account = _a.account, backendUrl = _a.backendUrl;
    return __awaiter$g(void 0, void 0, void 0, function () {
        var url, response, responseJson;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    url = "".concat(backendUrl, "/login");
                    return [4 /*yield*/, fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                apiKey: apiKey,
                                walletAddress: account,
                            }),
                        })];
                case 1:
                    response = _b.sent();
                    if (response.status >= 400) {
                        throw Error('Failed to authenticate');
                    }
                    return [4 /*yield*/, response.json()];
                case 2:
                    responseJson = _b.sent();
                    return [2 /*return*/, responseJson.accessToken];
            }
        });
    });
};

var bn = {exports: {}};

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require$$0.Buffer;
	    }
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }

	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [number & 0x3ffffff];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [0];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this._strip();
	  };

	  function parseHex4Bits (string, index) {
	    var c = string.charCodeAt(index);
	    // '0' - '9'
	    if (c >= 48 && c <= 57) {
	      return c - 48;
	    // 'A' - 'F'
	    } else if (c >= 65 && c <= 70) {
	      return c - 55;
	    // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	    } else {
	      assert(false, 'Invalid character in ' + string);
	    }
	  }

	  function parseHexByte (string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;

	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }

	    this._strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var b = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        b = c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        b = c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        b = c;
	      }
	      assert(c >= 0 && b < mul, 'Invalid character');
	      r += b;
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [0];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    this._strip();
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  function move (dest, src) {
	    dest.words = src.words;
	    dest.length = src.length;
	    dest.negative = src.negative;
	    dest.red = src.red;
	  }

	  BN.prototype._move = function _move (dest) {
	    move(dest, this);
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype._strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  // Check Symbol.for because not everywhere where Symbol defined
	  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
	  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
	    try {
	      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
	    } catch (e) {
	      BN.prototype.inspect = inspect;
	    }
	  } else {
	    BN.prototype.inspect = inspect;
	  }

	  function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  }

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modrn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16, 2);
	  };

	  if (Buffer) {
	    BN.prototype.toBuffer = function toBuffer (endian, length) {
	      return this.toArrayLike(Buffer, endian, length);
	    };
	  }

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  var allocate = function allocate (ArrayType, size) {
	    if (ArrayType.allocUnsafe) {
	      return ArrayType.allocUnsafe(size);
	    }
	    return new ArrayType(size);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    this._strip();

	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    var res = allocate(ArrayType, reqLength);
	    var postfix = endian === 'le' ? 'LE' : 'BE';
	    this['_toArrayLike' + postfix](res, byteLength);
	    return res;
	  };

	  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
	    var position = 0;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position++] = word & 0xff;
	      if (position < res.length) {
	        res[position++] = (word >> 8) & 0xff;
	      }
	      if (position < res.length) {
	        res[position++] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position < res.length) {
	          res[position++] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position < res.length) {
	      res[position++] = carry;

	      while (position < res.length) {
	        res[position++] = 0;
	      }
	    }
	  };

	  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
	    var position = res.length - 1;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position--] = word & 0xff;
	      if (position >= 0) {
	        res[position--] = (word >> 8) & 0xff;
	      }
	      if (position >= 0) {
	        res[position--] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position >= 0) {
	          res[position--] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position >= 0) {
	      res[position--] = carry;

	      while (position >= 0) {
	        res[position--] = 0;
	      }
	    }
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] >>> wbit) & 0x01;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this._strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this._strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this._strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this._strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this._strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this._strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  function jumboMulTo (self, num, out) {
	    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
	    // var fftm = new FFTM();
	    // return fftm.mulp(self, num, out);
	    return bigMulTo(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this._strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) <= num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this._strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this._strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this._strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q._strip();
	    }
	    a._strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modrn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modrn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modrn = function modrn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return isNegNum ? -acc : acc;
	  };

	  // WARNING: DEPRECATED
	  BN.prototype.modn = function modn (num) {
	    return this.modrn(num);
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    this._strip();
	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this._strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is a BN v4 instance
	        r.strip();
	      } else {
	        // r is a BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

	    move(a, a.umod(this.m)._forceRed(this));
	    return a;
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal);
} (bn));

var BN$1 = bn.exports;

const version$p = "logger/5.6.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$p);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version$o = "bytes/5.6.1";

const logger$J = new Logger(version$o);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$J.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger$J.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger$J.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
        logger$J.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$J.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger$J.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger$J.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger$J.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
        return "0x0";
    }
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    if (!isHexString(value)) {
        logger$J.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
        offset++;
    }
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger$J.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger$J.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        let bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        }
        else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        }
        else {
            logger$J.throwArgumentError("invalid signature string", "signature", signature);
        }
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
                result.v += 27;
            }
            else {
                logger$J.throwArgumentError("signature invalid v byte", "signature", signature);
            }
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - (result.v % 2);
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) {
            bytes[32] |= 0x80;
        }
        result._vs = hexlify(bytes.slice(32, 64));
    }
    else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);
            if (result.recoveryParam == null) {
                result.recoveryParam = recoveryParam;
            }
            else if (result.recoveryParam !== recoveryParam) {
                logger$J.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) {
                result.s = s;
            }
            else if (result.s !== s) {
                logger$J.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) {
                logger$J.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            }
            else if (result.v === 0 || result.v === 1) {
                result.recoveryParam = result.v;
            }
            else {
                result.recoveryParam = 1 - (result.v % 2);
            }
        }
        else {
            if (result.v == null) {
                result.v = 27 + result.recoveryParam;
            }
            else {
                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));
                if (result.recoveryParam !== recId) {
                    logger$J.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
                }
            }
        }
        if (result.r == null || !isHexString(result.r)) {
            logger$J.throwArgumentError("signature missing or invalid r", "signature", signature);
        }
        else {
            result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
            logger$J.throwArgumentError("signature missing or invalid s", "signature", signature);
        }
        else {
            result.s = hexZeroPad(result.s, 32);
        }
        const vs = arrayify(result.s);
        if (vs[0] >= 128) {
            logger$J.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
            vs[0] |= 0x80;
        }
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) {
                logger$J.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) {
            result._vs = _vs;
        }
        else if (result._vs !== _vs) {
            logger$J.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        (signature.recoveryParam ? "0x1c" : "0x1b")
    ]));
}

const version$n = "bignumber/5.6.2";

var BN = BN$1.BN;
const logger$I = new Logger(version$n);
const _constructorGuard$4 = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        isHexString(value) ||
        (typeof (value) === "bigint") ||
        isBytes(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard$4) {
            logger$I.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault$1("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault$1("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault$1("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault$1("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger$I.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger$I.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger$I.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger$I.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard$4, toHex$1(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard$4, toHex$1(new BN(value)));
            }
            return logger$I.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault$1("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault$1("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
            return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger$I.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex$1(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex$1(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger$I.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex$1(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex$1(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger$I.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}

const logger$H = new Logger(version$n);
const _constructorGuard$3 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value !== undefined) {
        params.value = value;
    }
    return logger$H.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while (zeros.length < 256) {
    zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof (decimals) !== "number") {
        try {
            decimals = BigNumber.from(decimals).toNumber();
        }
        catch (e) { }
    }
    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return ("1" + zeros.substring(0, decimals));
    }
    return logger$H.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = BigNumber.from(value);
    const negative = value.lt(Zero$2);
    if (negative) {
        value = value.mul(NegativeOne$2);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
    }
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
        value = whole;
    }
    else {
        value = whole + "." + fraction;
    }
    if (negative) {
        value = "-" + value;
    }
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof (value) !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger$H.throwArgumentError("invalid decimal value", "value", value);
    }
    // Is it negative?
    const negative = (value.substring(0, 1) === "-");
    if (negative) {
        value = value.substring(1);
    }
    if (value === ".") {
        logger$H.throwArgumentError("missing value", "value", value);
    }
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) {
        logger$H.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
        whole = "0";
    }
    if (!fraction) {
        fraction = "0";
    }
    // Trim trailing zeros
    while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
    }
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") {
        fraction = "0";
    }
    // Fully pad the string with zeros to get to wei
    while (fraction.length < multiplier.length - 1) {
        fraction += "0";
    }
    const wholeValue = BigNumber.from(whole);
    const fractionValue = BigNumber.from(fraction);
    let wei = (wholeValue.mul(multiplier)).add(fractionValue);
    if (negative) {
        wei = wei.mul(NegativeOne$2);
    }
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard$3) {
            logger$H.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) {
            return value;
        }
        if (typeof (value) === "number") {
            value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof (value) === "string") {
            if (value === "fixed") ;
            else if (value === "ufixed") {
                signed = false;
            }
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                    logger$H.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = (match[1] !== "u");
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            const check = (key, type, defaultValue) => {
                if (value[key] == null) {
                    return defaultValue;
                }
                if (typeof (value[key]) !== type) {
                    logger$H.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
            logger$H.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
            logger$H.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard$3, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard$3) {
            logger$H.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) {
            logger$H.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || (decimals % 1)) {
            logger$H.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
            return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return (this._value === "0.0" || this._value === "0");
    }
    isNegative() {
        return (this._value[0] === "-");
    }
    toString() { return this._value; }
    toHexString(width) {
        if (width == null) {
            return this._hex;
        }
        if (width % 8) {
            logger$H.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
    }
    toUnsafeFloat() { return parseFloat(this.toString()); }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) {
            decimals = 0;
        }
        if (format == null) {
            format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero$2)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
        }
        else {
            hex = numeric.toHexString();
            hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof (value) === "string") {
            return FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
            return FixedNumber.fromBytes(value, format);
        }
        try {
            return FixedNumber.fromValue(value, 0, format);
        }
        catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== Logger.errors.INVALID_ARGUMENT) {
                throw error;
            }
        }
        return logger$H.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

const version$m = "properties/5.6.0";

var __awaiter$f = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$G = new Logger(version$m);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter$f(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof (object) !== "object") {
        logger$G.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key) => {
        if (!properties[key]) {
            logger$G.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger$G.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger$G.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}

const version$l = "abi/5.6.3";

const logger$F = new Logger(version$l);
const _constructorGuard$2 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger$F.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger$F.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger$F.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard$2) {
            logger$F.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$F.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard$2, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard$2) {
            logger$F.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger$F.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger$F.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$F.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger$F.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard$2, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger$F.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger$F.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger$F.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger$F.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger$F.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger$F.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger$F.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger$F.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger$F.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$F.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger$F.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger$F.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger$F.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard$2, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger$F.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$F.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger$F.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard$2, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger$F.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger$F.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger$F.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger$F.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$F.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger$F.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard$2, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger$F.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger$F.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger$F.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}

const logger$E = new Logger(version$l);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger$E.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return hexConcat(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(concat(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger$E.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return hexlify(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger$E.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
    }
}

var sha3$1 = {exports: {}};

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */

(function (module) {
	/*jslint bitwise: true */
	(function () {

	  var INPUT_ERROR = 'input is invalid type';
	  var FINALIZE_ERROR = 'finalize already called';
	  var WINDOW = typeof window === 'object';
	  var root = WINDOW ? window : {};
	  if (root.JS_SHA3_NO_WINDOW) {
	    WINDOW = false;
	  }
	  var WEB_WORKER = !WINDOW && typeof self === 'object';
	  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
	  if (NODE_JS) {
	    root = commonjsGlobal;
	  } else if (WEB_WORKER) {
	    root = self;
	  }
	  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
	  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
	  var HEX_CHARS = '0123456789abcdef'.split('');
	  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
	  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
	  var KECCAK_PADDING = [1, 256, 65536, 16777216];
	  var PADDING = [6, 1536, 393216, 100663296];
	  var SHIFT = [0, 8, 16, 24];
	  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
	    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
	    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
	    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
	    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
	  var BITS = [224, 256, 384, 512];
	  var SHAKE_BITS = [128, 256];
	  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
	  var CSHAKE_BYTEPAD = {
	    '128': 168,
	    '256': 136
	  };

	  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
	    Array.isArray = function (obj) {
	      return Object.prototype.toString.call(obj) === '[object Array]';
	    };
	  }

	  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
	    ArrayBuffer.isView = function (obj) {
	      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
	    };
	  }

	  var createOutputMethod = function (bits, padding, outputType) {
	    return function (message) {
	      return new Keccak(bits, padding, bits).update(message)[outputType]();
	    };
	  };

	  var createShakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits) {
	      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
	    };
	  };

	  var createCshakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits, n, s) {
	      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
	    };
	  };

	  var createKmacOutputMethod = function (bits, padding, outputType) {
	    return function (key, message, outputBits, s) {
	      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
	    };
	  };

	  var createOutputMethods = function (method, createMethod, bits, padding) {
	    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
	      var type = OUTPUT_TYPES[i];
	      method[type] = createMethod(bits, padding, type);
	    }
	    return method;
	  };

	  var createMethod = function (bits, padding) {
	    var method = createOutputMethod(bits, padding, 'hex');
	    method.create = function () {
	      return new Keccak(bits, padding, bits);
	    };
	    method.update = function (message) {
	      return method.create().update(message);
	    };
	    return createOutputMethods(method, createOutputMethod, bits, padding);
	  };

	  var createShakeMethod = function (bits, padding) {
	    var method = createShakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits) {
	      return new Keccak(bits, padding, outputBits);
	    };
	    method.update = function (message, outputBits) {
	      return method.create(outputBits).update(message);
	    };
	    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
	  };

	  var createCshakeMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createCshakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits, n, s) {
	      if (!n && !s) {
	        return methods['shake' + bits].create(outputBits);
	      } else {
	        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
	      }
	    };
	    method.update = function (message, outputBits, n, s) {
	      return method.create(outputBits, n, s).update(message);
	    };
	    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
	  };

	  var createKmacMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createKmacOutputMethod(bits, padding, 'hex');
	    method.create = function (key, outputBits, s) {
	      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
	    };
	    method.update = function (key, message, outputBits, s) {
	      return method.create(key, outputBits, s).update(message);
	    };
	    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
	  };

	  var algorithms = [
	    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
	    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
	    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
	  ];

	  var methods = {}, methodNames = [];

	  for (var i = 0; i < algorithms.length; ++i) {
	    var algorithm = algorithms[i];
	    var bits = algorithm.bits;
	    for (var j = 0; j < bits.length; ++j) {
	      var methodName = algorithm.name + '_' + bits[j];
	      methodNames.push(methodName);
	      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
	      if (algorithm.name !== 'sha3') {
	        var newMethodName = algorithm.name + bits[j];
	        methodNames.push(newMethodName);
	        methods[newMethodName] = methods[methodName];
	      }
	    }
	  }

	  function Keccak(bits, padding, outputBits) {
	    this.blocks = [];
	    this.s = [];
	    this.padding = padding;
	    this.outputBits = outputBits;
	    this.reset = true;
	    this.finalized = false;
	    this.block = 0;
	    this.start = 0;
	    this.blockCount = (1600 - (bits << 1)) >> 5;
	    this.byteCount = this.blockCount << 2;
	    this.outputBlocks = outputBits >> 5;
	    this.extraBytes = (outputBits & 31) >> 3;

	    for (var i = 0; i < 50; ++i) {
	      this.s[i] = 0;
	    }
	  }

	  Keccak.prototype.update = function (message) {
	    if (this.finalized) {
	      throw new Error(FINALIZE_ERROR);
	    }
	    var notString, type = typeof message;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (message === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
	          message = new Uint8Array(message);
	        } else if (!Array.isArray(message)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
	      blockCount = this.blockCount, index = 0, s = this.s, i, code;

	    while (index < length) {
	      if (this.reset) {
	        this.reset = false;
	        blocks[0] = this.block;
	        for (i = 1; i < blockCount + 1; ++i) {
	          blocks[i] = 0;
	        }
	      }
	      if (notString) {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
	        }
	      } else {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          code = message.charCodeAt(index);
	          if (code < 0x80) {
	            blocks[i >> 2] |= code << SHIFT[i++ & 3];
	          } else if (code < 0x800) {
	            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else if (code < 0xd800 || code >= 0xe000) {
	            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else {
	            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
	            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          }
	        }
	      }
	      this.lastByteIndex = i;
	      if (i >= byteCount) {
	        this.start = i - byteCount;
	        this.block = blocks[blockCount];
	        for (i = 0; i < blockCount; ++i) {
	          s[i] ^= blocks[i];
	        }
	        f(s);
	        this.reset = true;
	      } else {
	        this.start = i;
	      }
	    }
	    return this;
	  };

	  Keccak.prototype.encode = function (x, right) {
	    var o = x & 255, n = 1;
	    var bytes = [o];
	    x = x >> 8;
	    o = x & 255;
	    while (o > 0) {
	      bytes.unshift(o);
	      x = x >> 8;
	      o = x & 255;
	      ++n;
	    }
	    if (right) {
	      bytes.push(n);
	    } else {
	      bytes.unshift(n);
	    }
	    this.update(bytes);
	    return bytes.length;
	  };

	  Keccak.prototype.encodeString = function (str) {
	    var notString, type = typeof str;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (str === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
	          str = new Uint8Array(str);
	        } else if (!Array.isArray(str)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var bytes = 0, length = str.length;
	    if (notString) {
	      bytes = length;
	    } else {
	      for (var i = 0; i < str.length; ++i) {
	        var code = str.charCodeAt(i);
	        if (code < 0x80) {
	          bytes += 1;
	        } else if (code < 0x800) {
	          bytes += 2;
	        } else if (code < 0xd800 || code >= 0xe000) {
	          bytes += 3;
	        } else {
	          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
	          bytes += 4;
	        }
	      }
	    }
	    bytes += this.encode(bytes * 8);
	    this.update(str);
	    return bytes;
	  };

	  Keccak.prototype.bytepad = function (strs, w) {
	    var bytes = this.encode(w);
	    for (var i = 0; i < strs.length; ++i) {
	      bytes += this.encodeString(strs[i]);
	    }
	    var paddingBytes = w - bytes % w;
	    var zeros = [];
	    zeros.length = paddingBytes;
	    this.update(zeros);
	    return this;
	  };

	  Keccak.prototype.finalize = function () {
	    if (this.finalized) {
	      return;
	    }
	    this.finalized = true;
	    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
	    blocks[i >> 2] |= this.padding[i & 3];
	    if (this.lastByteIndex === this.byteCount) {
	      blocks[0] = blocks[blockCount];
	      for (i = 1; i < blockCount + 1; ++i) {
	        blocks[i] = 0;
	      }
	    }
	    blocks[blockCount - 1] |= 0x80000000;
	    for (i = 0; i < blockCount; ++i) {
	      s[i] ^= blocks[i];
	    }
	    f(s);
	  };

	  Keccak.prototype.toString = Keccak.prototype.hex = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var hex = '', block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        block = s[i];
	        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
	          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
	          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
	          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	        i = 0;
	      }
	    }
	    if (extraBytes) {
	      block = s[i];
	      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
	      if (extraBytes > 1) {
	        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
	      }
	      if (extraBytes > 2) {
	        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
	      }
	    }
	    return hex;
	  };

	  Keccak.prototype.arrayBuffer = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var bytes = this.outputBits >> 3;
	    var buffer;
	    if (extraBytes) {
	      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
	    } else {
	      buffer = new ArrayBuffer(bytes);
	    }
	    var array = new Uint32Array(buffer);
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        array[j] = s[i];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      array[i] = s[i];
	      buffer = buffer.slice(0, bytes);
	    }
	    return buffer;
	  };

	  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

	  Keccak.prototype.digest = Keccak.prototype.array = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var array = [], offset, block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        offset = j << 2;
	        block = s[i];
	        array[offset] = block & 0xFF;
	        array[offset + 1] = (block >> 8) & 0xFF;
	        array[offset + 2] = (block >> 16) & 0xFF;
	        array[offset + 3] = (block >> 24) & 0xFF;
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      offset = j << 2;
	      block = s[i];
	      array[offset] = block & 0xFF;
	      if (extraBytes > 1) {
	        array[offset + 1] = (block >> 8) & 0xFF;
	      }
	      if (extraBytes > 2) {
	        array[offset + 2] = (block >> 16) & 0xFF;
	      }
	    }
	    return array;
	  };

	  function Kmac(bits, padding, outputBits) {
	    Keccak.call(this, bits, padding, outputBits);
	  }

	  Kmac.prototype = new Keccak();

	  Kmac.prototype.finalize = function () {
	    this.encode(this.outputBits, true);
	    return Keccak.prototype.finalize.call(this);
	  };

	  var f = function (s) {
	    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
	      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
	      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
	      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
	    for (n = 0; n < 48; n += 2) {
	      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
	      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
	      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
	      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
	      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
	      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
	      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
	      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
	      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
	      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

	      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
	      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
	      s[0] ^= h;
	      s[1] ^= l;
	      s[10] ^= h;
	      s[11] ^= l;
	      s[20] ^= h;
	      s[21] ^= l;
	      s[30] ^= h;
	      s[31] ^= l;
	      s[40] ^= h;
	      s[41] ^= l;
	      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
	      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
	      s[2] ^= h;
	      s[3] ^= l;
	      s[12] ^= h;
	      s[13] ^= l;
	      s[22] ^= h;
	      s[23] ^= l;
	      s[32] ^= h;
	      s[33] ^= l;
	      s[42] ^= h;
	      s[43] ^= l;
	      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
	      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
	      s[4] ^= h;
	      s[5] ^= l;
	      s[14] ^= h;
	      s[15] ^= l;
	      s[24] ^= h;
	      s[25] ^= l;
	      s[34] ^= h;
	      s[35] ^= l;
	      s[44] ^= h;
	      s[45] ^= l;
	      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
	      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
	      s[6] ^= h;
	      s[7] ^= l;
	      s[16] ^= h;
	      s[17] ^= l;
	      s[26] ^= h;
	      s[27] ^= l;
	      s[36] ^= h;
	      s[37] ^= l;
	      s[46] ^= h;
	      s[47] ^= l;
	      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
	      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
	      s[8] ^= h;
	      s[9] ^= l;
	      s[18] ^= h;
	      s[19] ^= l;
	      s[28] ^= h;
	      s[29] ^= l;
	      s[38] ^= h;
	      s[39] ^= l;
	      s[48] ^= h;
	      s[49] ^= l;

	      b0 = s[0];
	      b1 = s[1];
	      b32 = (s[11] << 4) | (s[10] >>> 28);
	      b33 = (s[10] << 4) | (s[11] >>> 28);
	      b14 = (s[20] << 3) | (s[21] >>> 29);
	      b15 = (s[21] << 3) | (s[20] >>> 29);
	      b46 = (s[31] << 9) | (s[30] >>> 23);
	      b47 = (s[30] << 9) | (s[31] >>> 23);
	      b28 = (s[40] << 18) | (s[41] >>> 14);
	      b29 = (s[41] << 18) | (s[40] >>> 14);
	      b20 = (s[2] << 1) | (s[3] >>> 31);
	      b21 = (s[3] << 1) | (s[2] >>> 31);
	      b2 = (s[13] << 12) | (s[12] >>> 20);
	      b3 = (s[12] << 12) | (s[13] >>> 20);
	      b34 = (s[22] << 10) | (s[23] >>> 22);
	      b35 = (s[23] << 10) | (s[22] >>> 22);
	      b16 = (s[33] << 13) | (s[32] >>> 19);
	      b17 = (s[32] << 13) | (s[33] >>> 19);
	      b48 = (s[42] << 2) | (s[43] >>> 30);
	      b49 = (s[43] << 2) | (s[42] >>> 30);
	      b40 = (s[5] << 30) | (s[4] >>> 2);
	      b41 = (s[4] << 30) | (s[5] >>> 2);
	      b22 = (s[14] << 6) | (s[15] >>> 26);
	      b23 = (s[15] << 6) | (s[14] >>> 26);
	      b4 = (s[25] << 11) | (s[24] >>> 21);
	      b5 = (s[24] << 11) | (s[25] >>> 21);
	      b36 = (s[34] << 15) | (s[35] >>> 17);
	      b37 = (s[35] << 15) | (s[34] >>> 17);
	      b18 = (s[45] << 29) | (s[44] >>> 3);
	      b19 = (s[44] << 29) | (s[45] >>> 3);
	      b10 = (s[6] << 28) | (s[7] >>> 4);
	      b11 = (s[7] << 28) | (s[6] >>> 4);
	      b42 = (s[17] << 23) | (s[16] >>> 9);
	      b43 = (s[16] << 23) | (s[17] >>> 9);
	      b24 = (s[26] << 25) | (s[27] >>> 7);
	      b25 = (s[27] << 25) | (s[26] >>> 7);
	      b6 = (s[36] << 21) | (s[37] >>> 11);
	      b7 = (s[37] << 21) | (s[36] >>> 11);
	      b38 = (s[47] << 24) | (s[46] >>> 8);
	      b39 = (s[46] << 24) | (s[47] >>> 8);
	      b30 = (s[8] << 27) | (s[9] >>> 5);
	      b31 = (s[9] << 27) | (s[8] >>> 5);
	      b12 = (s[18] << 20) | (s[19] >>> 12);
	      b13 = (s[19] << 20) | (s[18] >>> 12);
	      b44 = (s[29] << 7) | (s[28] >>> 25);
	      b45 = (s[28] << 7) | (s[29] >>> 25);
	      b26 = (s[38] << 8) | (s[39] >>> 24);
	      b27 = (s[39] << 8) | (s[38] >>> 24);
	      b8 = (s[48] << 14) | (s[49] >>> 18);
	      b9 = (s[49] << 14) | (s[48] >>> 18);

	      s[0] = b0 ^ (~b2 & b4);
	      s[1] = b1 ^ (~b3 & b5);
	      s[10] = b10 ^ (~b12 & b14);
	      s[11] = b11 ^ (~b13 & b15);
	      s[20] = b20 ^ (~b22 & b24);
	      s[21] = b21 ^ (~b23 & b25);
	      s[30] = b30 ^ (~b32 & b34);
	      s[31] = b31 ^ (~b33 & b35);
	      s[40] = b40 ^ (~b42 & b44);
	      s[41] = b41 ^ (~b43 & b45);
	      s[2] = b2 ^ (~b4 & b6);
	      s[3] = b3 ^ (~b5 & b7);
	      s[12] = b12 ^ (~b14 & b16);
	      s[13] = b13 ^ (~b15 & b17);
	      s[22] = b22 ^ (~b24 & b26);
	      s[23] = b23 ^ (~b25 & b27);
	      s[32] = b32 ^ (~b34 & b36);
	      s[33] = b33 ^ (~b35 & b37);
	      s[42] = b42 ^ (~b44 & b46);
	      s[43] = b43 ^ (~b45 & b47);
	      s[4] = b4 ^ (~b6 & b8);
	      s[5] = b5 ^ (~b7 & b9);
	      s[14] = b14 ^ (~b16 & b18);
	      s[15] = b15 ^ (~b17 & b19);
	      s[24] = b24 ^ (~b26 & b28);
	      s[25] = b25 ^ (~b27 & b29);
	      s[34] = b34 ^ (~b36 & b38);
	      s[35] = b35 ^ (~b37 & b39);
	      s[44] = b44 ^ (~b46 & b48);
	      s[45] = b45 ^ (~b47 & b49);
	      s[6] = b6 ^ (~b8 & b0);
	      s[7] = b7 ^ (~b9 & b1);
	      s[16] = b16 ^ (~b18 & b10);
	      s[17] = b17 ^ (~b19 & b11);
	      s[26] = b26 ^ (~b28 & b20);
	      s[27] = b27 ^ (~b29 & b21);
	      s[36] = b36 ^ (~b38 & b30);
	      s[37] = b37 ^ (~b39 & b31);
	      s[46] = b46 ^ (~b48 & b40);
	      s[47] = b47 ^ (~b49 & b41);
	      s[8] = b8 ^ (~b0 & b2);
	      s[9] = b9 ^ (~b1 & b3);
	      s[18] = b18 ^ (~b10 & b12);
	      s[19] = b19 ^ (~b11 & b13);
	      s[28] = b28 ^ (~b20 & b22);
	      s[29] = b29 ^ (~b21 & b23);
	      s[38] = b38 ^ (~b30 & b32);
	      s[39] = b39 ^ (~b31 & b33);
	      s[48] = b48 ^ (~b40 & b42);
	      s[49] = b49 ^ (~b41 & b43);

	      s[0] ^= RC[n];
	      s[1] ^= RC[n + 1];
	    }
	  };

	  if (COMMON_JS) {
	    module.exports = methods;
	  } else {
	    for (i = 0; i < methodNames.length; ++i) {
	      root[methodNames[i]] = methods[methodNames[i]];
	    }
	  }
	})();
} (sha3$1));

var sha3 = sha3$1.exports;

function keccak256$1(data) {
    return '0x' + sha3.keccak_256(arrayify(data));
}

const version$k = "rlp/5.6.1";

const logger$D = new Logger(version$k);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!isBytesLike(object)) {
        logger$D.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(arrayify(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode$2(object) {
    return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger$D.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger$D.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$D.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
}
function decode$2(data) {
    const bytes = arrayify(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger$D.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}

var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    encode: encode$2,
    decode: decode$2
});

const version$j = "address/5.6.1";

const logger$C = new Logger(version$j);
function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
        logger$C.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = arrayify(keccak256$1(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger$C.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger$C.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger$C.throwArgumentError("bad icap checksum", "address", address);
        }
        result = _base36To16(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger$C.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
function getIcapAddress(address) {
    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger$C.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress(hexDataSlice(keccak256$1(encode$2([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if (hexDataLength(salt) !== 32) {
        logger$C.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if (hexDataLength(initCodeHash) !== 32) {
        logger$C.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress(hexDataSlice(keccak256$1(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}

class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = getAddress(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
}

// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

const logger$B = new Logger(version$l);
function pack$1(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger$B.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger$B.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger$B.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger$B.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger$B.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack$1(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger$B.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
}

// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
}

class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

const AddressZero = "0x0000000000000000000000000000000000000000";

const NegativeOne$1 = ( /*#__PURE__*/BigNumber.from(-1));
const Zero$1 = ( /*#__PURE__*/BigNumber.from(0));
const One$1 = ( /*#__PURE__*/BigNumber.from(1));
const Two = ( /*#__PURE__*/BigNumber.from(2));
const WeiPerEther = ( /*#__PURE__*/BigNumber.from("1000000000000000000"));
const MaxUint256$1 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
const MinInt256 = ( /*#__PURE__*/BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"));
const MaxInt256 = ( /*#__PURE__*/BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// NFKC (composed)             // (decomposed)
const EtherSymbol = "\u039e"; // "\uD835\uDF63";

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AddressZero: AddressZero,
    NegativeOne: NegativeOne$1,
    Zero: Zero$1,
    One: One$1,
    Two: Two,
    WeiPerEther: WeiPerEther,
    MaxUint256: MaxUint256$1,
    MinInt256: MinInt256,
    MaxInt256: MaxInt256,
    HashZero: HashZero,
    EtherSymbol: EtherSymbol
});

class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One$1).mul(NegativeOne$1))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero$1) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

const version$i = "strings/5.6.1";

const logger$A = new Logger(version$i);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger$A.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger$A.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}
function escapeChar(value) {
    const hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}

function formatBytes32String(text) {
    // Get the bytes
    const bytes = toUtf8Bytes(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
    const data = arrayify(bytes);
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
    }
    // Find the null termination
    let length = 31;
    while (data[length - 1] === 0) {
        length--;
    }
    // Determine the string value
    return toUtf8String(data.slice(0, length));
}

function bytes2(data) {
    if ((data.length % 4) !== 0) {
        throw new Error("bad data");
    }
    let result = [];
    for (let i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
    }
    return result;
}
function createTable(data, func) {
    if (!func) {
        func = function (value) { return [parseInt(value, 16)]; };
    }
    let lo = 0;
    let result = {};
    data.split(",").forEach((pair) => {
        let comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
    });
    return result;
}
function createRangeTable(data) {
    let hi = 0;
    return data.split(",").map((v) => {
        let comps = v.split("-");
        if (comps.length === 1) {
            comps[1] = "0";
        }
        else if (comps[1] === "") {
            comps[1] = "1";
        }
        let lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
    });
}
function matchMap(value, ranges) {
    let lo = 0;
    for (let i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {
            if (range.e && range.e.indexOf(value - lo) !== -1) {
                continue;
            }
            return range;
        }
    }
    return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
const Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
    return values.reduce((accum, value) => {
        value.forEach((value) => { accum.push(value); });
        return accum;
    }, []);
}
function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
    let range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
        return [codepoint + range.s];
    }
    let codes = Table_B_2_lut_abs[codepoint];
    if (codes) {
        return codes;
    }
    let shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
        return [codepoint + shift[0]];
    }
    let complex = Table_B_2_complex[codepoint];
    if (complex) {
        return complex;
    }
    return null;
}
function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
    // This allows platforms with incomplete normalize to bypass
    // it for very basic names which the built-in toLowerCase
    // will certainly handle correctly
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
    }
    // Get the code points (keeping the current normalization)
    let codes = toUtf8CodePoints(value);
    codes = flatten(codes.map((code) => {
        // Substitute Table B.1 (Maps to Nothing)
        if (Table_B_1_flags.indexOf(code) >= 0) {
            return [];
        }
        if (code >= 0xfe00 && code <= 0xfe0f) {
            return [];
        }
        // Substitute Table B.2 (Case Folding)
        let codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) {
            return codesTableB2;
        }
        // No Substitution
        return [code];
    }));
    // Normalize using form KC
    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
    codes.forEach((code) => {
        if (_nameprepTableC(code)) {
            throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
    });
    // Prohibit Unassigned Code Points (Table A.1)
    codes.forEach((code) => {
        if (_nameprepTableA1(code)) {
            throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
    });
    // IDNA extras
    let name = _toUtf8String(codes);
    // IDNA: 4.2.3.1
    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
        throw new Error("invalid hyphen");
    }
    // IDNA: 4.2.4
    if (name.length > 63) {
        throw new Error("too long");
    }
    return name;
}

class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack$1(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}

const logger$z = new Logger(version$l);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger$z.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger$z.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return logger$z.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger$z.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
    return keccak256$1(toUtf8Bytes(text));
}

const version$h = "hash/5.6.1";

const logger$y = new Logger(version$h);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
const Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName(name) {
    try {
        const comps = name.split(".");
        for (let i = 0; i < comps.length; i++) {
            if (nameprep(comps[i]).length === 0) {
                throw new Error("empty");
            }
        }
        return true;
    }
    catch (error) { }
    return false;
}
function namehash(name) {
    /* istanbul ignore if */
    if (typeof (name) !== "string") {
        logger$y.throwArgumentError("invalid ENS name; not a string", "name", name);
    }
    let current = name;
    let result = Zeros$1;
    while (current.length) {
        const partition = current.match(Partition);
        if (partition == null || partition[2] === "") {
            logger$y.throwArgumentError("invalid ENS address; missing component", "name", name);
        }
        const label = toUtf8Bytes(nameprep(partition[3]));
        result = keccak256$1(concat([result, keccak256$1(label)]));
        current = partition[2] || "";
    }
    return hexlify(result);
}
function dnsEncode(name) {
    return hexlify(concat(name.split(".").map((comp) => {
        // We jam in an _ prefix to fill in with the length later
        // Note: Nameprep throws if the component is over 63 bytes
        const bytes = toUtf8Bytes("_" + nameprep(comp));
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}

const messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
    if (typeof (message) === "string") {
        message = toUtf8Bytes(message);
    }
    return keccak256$1(concat([
        toUtf8Bytes(messagePrefix),
        toUtf8Bytes(String(message.length)),
        message
    ]));
}

var __awaiter$e = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$x = new Logger(version$h);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = arrayify(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return hexConcat([bytes, padding.slice(padOffset)]);
    }
    return hexlify(bytes);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        if (typeof (value) !== "string") {
            logger$x.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        }
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (value) {
        try {
            return BigNumber.from(value).toString();
        }
        catch (error) { }
        return logger$x.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function (value) {
        try {
            return getAddress(value).toLowerCase();
        }
        catch (error) { }
        return logger$x.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function (value) {
        try {
            const bytes = arrayify(value);
            if (bytes.length !== 32) {
                throw new Error("bad length");
            }
            return hexlify(bytes);
        }
        catch (error) { }
        return logger$x.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            const signed = (match[1] === "");
            const width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {
                logger$x.throwArgumentError("invalid numeric width", "type", type);
            }
            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);
            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
            return function (value) {
                const v = BigNumber.from(value);
                if (v.lt(boundsLower) || v.gt(boundsUpper)) {
                    logger$x.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
                }
                return hexZeroPad(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (width === 0 || width > 32 || match[1] !== String(width)) {
                logger$x.throwArgumentError("invalid bytes width", "type", type);
            }
            return function (value) {
                const bytes = arrayify(value);
                if (bytes.length !== width) {
                    logger$x.throwArgumentError(`invalid length for ${type}`, "value", value);
                }
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return hexZeroPad(getAddress(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return keccak256$1(value);
        };
        case "string": return function (value) {
            return id(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => (type + " " + name)).join(",")})`;
}
class TypedDataEncoder {
    constructor(types) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
        defineReadOnly(this, "_encoderCache", {});
        defineReadOnly(this, "_types", {});
        // Link struct types to their direct child structs
        const links = {};
        // Link structs to structs which contain them as a child
        const parents = {};
        // Link all subtypes within a given struct
        const subtypes = {};
        Object.keys(types).forEach((type) => {
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        for (const name in types) {
            const uniqueNames = {};
            types[name].forEach((field) => {
                // Check each field has a unique name
                if (uniqueNames[field.name]) {
                    logger$x.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
                }
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name) {
                    logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
                }
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    return;
                }
                if (!parents[baseType]) {
                    logger$x.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
                }
                // Add linkage
                parents[baseType].push(name);
                links[name][baseType] = true;
            });
        }
        // Deduce the primary type
        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));
        if (primaryTypes.length === 0) {
            logger$x.throwArgumentError("missing primary type", "types", types);
        }
        else if (primaryTypes.length > 1) {
            logger$x.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(", ")}`, "types", types);
        }
        defineReadOnly(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) {
                logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
            }
            found[type] = true;
            Object.keys(links[type]).forEach((child) => {
                if (!parents[child]) {
                    return;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach((subtype) => {
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for (const name in subtypes) {
            const st = Object.keys(subtypes[name]);
            st.sort();
            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join("");
        }
    }
    getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
            encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
    }
    _getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            const length = parseInt(match[3]);
            return (value) => {
                if (length >= 0 && value.length !== length) {
                    logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                }
                let result = value.map(subEncoder);
                if (this._types[subtype]) {
                    result = result.map(keccak256$1);
                }
                return keccak256$1(hexConcat(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = id(this._types[type]);
            return (value) => {
                const values = fields.map(({ name, type }) => {
                    const result = this.getEncoder(type)(value[name]);
                    if (this._types[type]) {
                        return keccak256$1(result);
                    }
                    return result;
                });
                values.unshift(encodedType);
                return hexConcat(values);
            };
        }
        return logger$x.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name) {
        const result = this._types[name];
        if (!result) {
            logger$x.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        }
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return keccak256$1(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const length = parseInt(match[3]);
            if (length >= 0 && value.length !== length) {
                logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            return value.map((v) => this._visit(subtype, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        return logger$x.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            const type = domainFieldTypes[name];
            if (!type) {
                logger$x.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            }
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    static encode(domain, types, value) {
        return hexConcat([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    static hash(domain, types, value) {
        return keccak256$1(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain, types, value, resolveName) {
        return __awaiter$e(this, void 0, void 0, function* () {
            // Make a copy to isolate it from the object passed in
            domain = shallowCopy(domain);
            // Look up all ENS names
            const ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
            }
            // We are going to use the encoder to visit all the base values
            const encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, (type, value) => {
                if (type === "address" && !isHexString(value, 20)) {
                    ensCache[value] = "0x";
                }
                return value;
            });
            // Lookup each name
            for (const name in ensCache) {
                ensCache[name] = yield resolveName(name);
            }
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            // Replace all ENS names with their address
            value = encoder.visit(value, (type, value) => {
                if (type === "address" && ensCache[value]) {
                    return ensCache[value];
                }
                return value;
            });
            return { domain, value };
        });
    }
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = shallowCopy(types);
        if (typesWithDomain.EIP712Domain) {
            logger$x.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        }
        else {
            typesWithDomain.EIP712Domain = domainTypes;
        }
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return hexlify(arrayify(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return BigNumber.from(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof (value) !== "string") {
                            logger$x.throwArgumentError(`invalid string`, "value", value);
                        }
                        return value;
                }
                return logger$x.throwArgumentError("unsupported type", "type", type);
            })
        };
    }
}

const logger$w = new Logger(version$l);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger$w.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineReadOnly(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger$w.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            logger$w.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return getAddress(address);
    }
    static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return id(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger$w.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$w.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger$w.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger$w.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger$w.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$w.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger$w.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger$w.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            const getSighash = getStatic(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger$w.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$w.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger$w.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger$w.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger$w.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return hexlify(concat([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger$w.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = hexlify(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return logger$w.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: hexlify(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger$w.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256$1(hexlify(value));
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger$w.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger$w.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger$w.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256$1(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger$w.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

const version$g = "abstract-provider/5.6.1";

var __awaiter$d = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$v = new Logger(version$g);
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
class ForkEvent extends Description {
    static isForkEvent(value) {
        return !!(value && value._isForkEvent);
    }
}
///////////////////////////////
// Exported Abstracts
class Provider {
    constructor() {
        logger$v.checkAbstract(new.target, Provider);
        defineReadOnly(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter$d(this, void 0, void 0, function* () {
            const { block, gasPrice } = yield resolveProperties({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error) => {
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                maxPriorityFeePerGas = BigNumber.from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}

const version$f = "abstract-signer/5.6.2";

var __awaiter$c = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$u = new Logger(version$f);
const allowedTransactionKeys$3 = [
    "accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"
];
const forwardErrors = [
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED,
];
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor() {
        logger$u.checkAbstract(new.target, Signer);
        defineReadOnly(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas");
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("call");
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return __awaiter$c(this, void 0, void 0, function* () {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys$3.indexOf(key) === -1) {
                logger$u.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
            tx.from = this.getAddress();
        }
        else {
            // Make sure any provided address matches this signer
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
            ]).then((result) => {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                    logger$u.throwArgumentError("from address mismatch", "transaction", transaction);
                }
                return result[0];
            });
        }
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return __awaiter$c(this, void 0, void 0, function* () {
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to) => __awaiter$c(this, void 0, void 0, function* () {
                    if (to == null) {
                        return null;
                    }
                    const address = yield this.resolveName(to);
                    if (address == null) {
                        logger$u.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return address;
                }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error) => { });
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                logger$u.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            }
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                logger$u.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            }
            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
                // Fully-formed EIP-1559 transaction (skip getFeeData)
                tx.type = 2;
            }
            else if (tx.type === 0 || tx.type === 1) {
                // Explicit Legacy or EIP-2930 transaction
                // Populate missing gasPrice
                if (tx.gasPrice == null) {
                    tx.gasPrice = this.getGasPrice();
                }
            }
            else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        }
                        else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) {
                                tx.maxFeePerGas = feeData.maxFeePerGas;
                            }
                            if (tx.maxPriorityFeePerGas == null) {
                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                            }
                        }
                    }
                    else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) {
                            logger$u.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                                operation: "populateTransaction"
                            });
                        }
                        // Populate missing fee data
                        if (tx.gasPrice == null) {
                            tx.gasPrice = feeData.gasPrice;
                        }
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    }
                    else {
                        // getFeeData has failed us.
                        logger$u.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "signer.getFeeData"
                        });
                    }
                }
                else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                }
            }
            if (tx.nonce == null) {
                tx.nonce = this.getTransactionCount("pending");
            }
            if (tx.gasLimit == null) {
                tx.gasLimit = this.estimateGas(tx).catch((error) => {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                        throw error;
                    }
                    return logger$u.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                        error: error,
                        tx: tx
                    });
                });
            }
            if (tx.chainId == null) {
                tx.chainId = this.getChainId();
            }
            else {
                tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                ]).then((results) => {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                        logger$u.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                });
            }
            return yield resolveProperties(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) {
            logger$u.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: (operation || "_checkProvider")
            });
        }
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends Signer {
    constructor(address, provider) {
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(() => {
            logger$u.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}

var hash = {};

var utils$a = {};

var minimalisticAssert$1 = assert$b;

function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert$b.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var inherits_browser$1 = {exports: {}};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser$1.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser$1.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

var assert$a = minimalisticAssert$1;
var inherits = inherits_browser$1.exports;

utils$a.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$a.toArray = toArray$1;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$a.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils$a.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$a.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils$a.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils$a.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils$a.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils$a.split32 = split32;

function rotr32$1(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils$a.rotr32 = rotr32$1;

function rotl32$2(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils$a.rotl32 = rotl32$2;

function sum32$3(a, b) {
  return (a + b) >>> 0;
}
utils$a.sum32 = sum32$3;

function sum32_3$1(a, b, c) {
  return (a + b + c) >>> 0;
}
utils$a.sum32_3 = sum32_3$1;

function sum32_4$2(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils$a.sum32_4 = sum32_4$2;

function sum32_5$2(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils$a.sum32_5 = sum32_5$2;

function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$a.sum64 = sum64$1;

function sum64_hi$1(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$a.sum64_hi = sum64_hi$1;

function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$a.sum64_lo = sum64_lo$1;

function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$a.sum64_4_hi = sum64_4_hi$1;

function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$a.sum64_4_lo = sum64_4_lo$1;

function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$a.sum64_5_hi = sum64_5_hi$1;

function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
utils$a.sum64_5_lo = sum64_5_lo$1;

function rotr64_hi$1(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
utils$a.rotr64_hi = rotr64_hi$1;

function rotr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$a.rotr64_lo = rotr64_lo$1;

function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$a.shr64_hi = shr64_hi$1;

function shr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$a.shr64_lo = shr64_lo$1;

var common$5 = {};

var utils$9 = utils$a;
var assert$9 = minimalisticAssert$1;

function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;

BlockHash$4.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$9.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils$9.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);

  return this._digest(enc);
};

BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

var sha = {};

var common$4 = {};

var utils$8 = utils$a;
var rotr32 = utils$8.rotr32;

function ft_1$1(s, x, y, z) {
  if (s === 0)
    return ch32$1(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;

function ch32$1(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
common$4.ch32 = ch32$1;

function maj32$1(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
common$4.maj32 = maj32$1;

function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;

function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;

function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;

function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
common$4.g0_256 = g0_256$1;

function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
common$4.g1_256 = g1_256$1;

var utils$7 = utils$a;
var common$3 = common$5;
var shaCommon$1 = common$4;

var rotl32$1 = utils$7.rotl32;
var sum32$2 = utils$7.sum32;
var sum32_5$1 = utils$7.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash$3.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils$7.inherits(SHA1, BlockHash$3);
var _1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$7.toHex32(this.h, 'big');
  else
    return utils$7.split32(this.h, 'big');
};

var utils$6 = utils$a;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;

var sum32$1 = utils$6.sum32;
var sum32_4$1 = utils$6.sum32_4;
var sum32_5 = utils$6.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash$2 = common$2.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();

  BlockHash$2.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$6.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;

SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;

SHA256$1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert$8(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }

  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};

SHA256$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$6.toHex32(this.h, 'big');
  else
    return utils$6.split32(this.h, 'big');
};

var utils$5 = utils$a;
var SHA256 = _256;

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils$5.inherits(SHA224, SHA256);
var _224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils$5.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils$5.split32(this.h.slice(0, 7), 'big');
};

var utils$4 = utils$a;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;

var rotr64_hi = utils$4.rotr64_hi;
var rotr64_lo = utils$4.rotr64_lo;
var shr64_hi = utils$4.shr64_hi;
var shr64_lo = utils$4.shr64_lo;
var sum64 = utils$4.sum64;
var sum64_hi = utils$4.sum64_hi;
var sum64_lo = utils$4.sum64_lo;
var sum64_4_hi = utils$4.sum64_4_hi;
var sum64_4_lo = utils$4.sum64_4_lo;
var sum64_5_hi = utils$4.sum64_5_hi;
var sum64_5_lo = utils$4.sum64_5_lo;

var BlockHash$1 = common$1.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();

  BlockHash$1.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$4.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;

SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;

SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512$1.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert$7(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$4.toHex32(this.h, 'big');
  else
    return utils$4.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

var utils$3 = utils$a;

var SHA512 = _512;

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils$3.inherits(SHA384, SHA512);
var _384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$3.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils$3.split32(this.h.slice(0, 12), 'big');
};

sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;

var ripemd = {};

var utils$2 = utils$a;
var common = common$5;

var rotl32 = utils$2.rotl32;
var sum32 = utils$2.sum32;
var sum32_3 = utils$2.sum32_3;
var sum32_4 = utils$2.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils$2.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$2.toHex32(this.h, 'little');
  else
    return utils$2.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

var utils$1 = utils$a;
var assert$6 = minimalisticAssert$1;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils$1.toArray(key, enc));
}
var hmac = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert$6(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

(function (exports) {
	var hash = exports;

	hash.utils = utils$a;
	hash.common = common$5;
	hash.sha = sha;
	hash.ripemd = ripemd;
	hash.hmac = hmac;

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160;
} (hash));

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var minimalisticAssert = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var utils_1 = createCommonjsModule(function (module, exports) {

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};
});

var utils_1$1 = createCommonjsModule(function (module, exports) {

var utils = exports;




utils.assert = minimalisticAssert;
utils.toArray = utils_1.toArray;
utils.zero2 = utils_1.zero2;
utils.toHex = utils_1.toHex;
utils.encode = utils_1.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN$1(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;
});



var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$1(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN$1.red(conf.prime) : BN$1.mont(this.p);

  // Useful for many curves
  this.zero = new BN$1(0).toRed(this.red);
  this.one = new BN$1(1).toRed(this.red);
  this.two = new BN$1(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN$1(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert$1(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});






var assert$2 = utils_1$1.assert;

function ShortCurve(conf) {
  base.call(this, 'short', conf);

  this.a = new BN$1(conf.a, 16).toRed(this.red);
  this.b = new BN$1(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$1(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$1(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$1(vec.a, 16),
        b: new BN$1(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN$1.mont(num);
  var tinv = new BN$1(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN$1(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$1(1);
  var y1 = new BN$1(0);
  var x2 = new BN$1(0);
  var y2 = new BN$1(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$1(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$1(x, 16);
    this.y = new BN$1(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN$1(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$1(0);
  } else {
    this.x = new BN$1(x, 16);
    this.y = new BN$1(y, 16);
    this.z = new BN$1(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN$1(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var curve_1 = createCommonjsModule(function (module, exports) {

var curve = exports;

curve.base = base;
curve.short = short_1;
curve.mont = /*RicMoo:ethers:require(./mont)*/(null);
curve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);
});

var curves_1 = createCommonjsModule(function (module, exports) {

var curves = exports;





var assert = utils_1$1.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve_1.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve_1.edwards(options);
  else
    this.curve = new curve_1.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});
});





function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils_1.toArray(entropy, entropyEnc);
  add = utils_1.toArray(add, addEnc);

  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils_1.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils_1.encode(res, enc);
};



var assert$3 = utils_1$1.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN$1(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$3(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert$3(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert$3(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};




var assert$4 = utils_1$1.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new BN$1(options.r, 16);
  this.s = new BN$1(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN$1(r);
  this.s = new BN$1(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};





var rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });
var assert$5 = utils_1$1.assert;




function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),
      'Unknown curve ' + options);

    options = curves_1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (;;) {
    var priv = new BN$1(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN$1(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN$1(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN$1(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature$1, key, enc) {
  msg = this._truncateToN(new BN$1(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature$1 = new signature(signature$1, 'hex');

  // Perform primitive values validation
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, 'The recovery param is more than two bits');
  signature$1 = new signature(signature$1, enc);

  var n = this.n;
  var e = new BN$1(msg);
  var r = signature$1.r;
  var s = signature$1.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

var elliptic_1 = createCommonjsModule(function (module, exports) {

var elliptic = exports;

elliptic.version = /*RicMoo:ethers*/{ version: "6.5.4" }.version;
elliptic.utils = utils_1$1;
elliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });
elliptic.curve = curve_1;
elliptic.curves = curves_1;

// Protocols
elliptic.ec = ec;
elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);
});

var EC$1 = elliptic_1.ec;

const version$e = "signing-key/5.6.2";

const logger$t = new Logger(version$e);
let _curve = null;
function getCurve() {
    if (!_curve) {
        _curve = new EC$1("secp256k1");
    }
    return _curve;
}
class SigningKey {
    constructor(privateKey) {
        defineReadOnly(this, "curve", "secp256k1");
        defineReadOnly(this, "privateKey", hexlify(privateKey));
        if (hexDataLength(this.privateKey) !== 32) {
            logger$t.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
        defineReadOnly(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        defineReadOnly(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        defineReadOnly(this, "_isSigningKey", true);
    }
    _addPoint(other) {
        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
        const p1 = getCurve().keyFromPublic(arrayify(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const digestBytes = arrayify(digest);
        if (digestBytes.length !== 32) {
            logger$t.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature = keyPair.sign(digestBytes, { canonical: true });
        return splitSignature({
            recoveryParam: signature.recoveryParam,
            r: hexZeroPad("0x" + signature.r.toString(16), 32),
            s: hexZeroPad("0x" + signature.s.toString(16), 32),
        });
    }
    computeSharedSecret(otherKey) {
        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
        return hexZeroPad("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
        return !!(value && value._isSigningKey);
    }
}
function recoverPublicKey(digest, signature) {
    const sig = splitSignature(signature);
    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
    return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
    const bytes = arrayify(key);
    if (bytes.length === 32) {
        const signingKey = new SigningKey(bytes);
        if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
    }
    else if (bytes.length === 33) {
        if (compressed) {
            return hexlify(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    }
    else if (bytes.length === 65) {
        if (!compressed) {
            return hexlify(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger$t.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

const version$d = "transactions/5.6.2";

const logger$s = new Logger(version$d);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return getAddress(value);
}
function handleNumber(value) {
    if (value === "0x") {
        return Zero$1;
    }
    return BigNumber.from(value);
}
// Legacy Transaction Fields
const transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" },
];
const allowedTransactionKeys$2 = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true
};
function computeAddress(key) {
    const publicKey = computePublicKey(key);
    return getAddress(hexDataSlice(keccak256$1(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
    return computeAddress(recoverPublicKey(arrayify(digest), signature));
}
function formatNumber(value, name) {
    const result = stripZeros(BigNumber.from(value).toHexString());
    if (result.length > 32) {
        logger$s.throwArgumentError("invalid length for " + name, ("transaction:" + name), value);
    }
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: getAddress(addr),
        storageKeys: (storageKeys || []).map((storageKey, index) => {
            if (hexDataLength(storageKey) !== 32) {
                logger$s.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    logger$s.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        const gasPrice = BigNumber.from(transaction.gasPrice);
        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
            logger$s.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                gasPrice, maxFeePerGas
            });
        }
    }
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? getAddress(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = splitSignature(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push(stripZeros(sig.r));
        fields.push(stripZeros(sig.s));
    }
    return hexConcat(["0x02", encode$2(fields)]);
}
function _serializeEip2930(transaction, signature) {
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? getAddress(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = splitSignature(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push(stripZeros(sig.r));
        fields.push(stripZeros(sig.s));
    }
    return hexConcat(["0x01", encode$2(fields)]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    checkProperties(transaction, allowedTransactionKeys$2);
    const raw = [];
    transactionFields.forEach(function (fieldInfo) {
        let value = transaction[fieldInfo.name] || ([]);
        const options = {};
        if (fieldInfo.numeric) {
            options.hexPad = "left";
        }
        value = arrayify(hexlify(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
            logger$s.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
        }
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = stripZeros(value);
            if (value.length > fieldInfo.maxLength) {
                logger$s.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
            }
        }
        raw.push(hexlify(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof (chainId) !== "number") {
            logger$s.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
    }
    else if (signature && !isBytesLike(signature) && signature.v > 28) {
        // No chainId provided, but the signature is signing with EIP-155; derive chainId
        chainId = Math.floor((signature.v - 35) / 2);
    }
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push(hexlify(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) {
        return encode$2(raw);
    }
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    const sig = splitSignature(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    let v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) {
            logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
    }
    else if (sig.v !== v) {
        logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
    raw.push(hexlify(v));
    raw.push(stripZeros(arrayify(sig.r)));
    raw.push(stripZeros(arrayify(sig.s)));
    return encode$2(raw);
}
function serialize$1(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
            logger$s.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch (transaction.type) {
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
    }
    return logger$s.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
function _parseEipSignature(tx, fields, serialize) {
    try {
        const recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
            throw new Error("bad recid");
        }
        tx.v = recid;
    }
    catch (error) {
        logger$s.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = hexZeroPad(fields[1], 32);
    tx.s = hexZeroPad(fields[2], 32);
    try {
        const digest = keccak256$1(serialize(tx));
        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    }
    catch (error) { }
}
function _parseEip1559(payload) {
    const transaction = decode$2(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
        logger$s.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
    }
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8]),
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) {
        return tx;
    }
    tx.hash = keccak256$1(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    const transaction = decode$2(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
        logger$s.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
    }
    const tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) {
        return tx;
    }
    tx.hash = keccak256$1(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    const transaction = decode$2(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
        logger$s.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    const tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) {
        return tx;
    }
    try {
        tx.v = BigNumber.from(transaction[6]).toNumber();
    }
    catch (error) {
        // @TODO: What makes snese to do? The v is too big
        return tx;
    }
    tx.r = hexZeroPad(transaction[7], 32);
    tx.s = hexZeroPad(transaction[8], 32);
    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    }
    else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        let recoveryParam = tx.v - 27;
        const raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push(hexlify(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        const digest = keccak256$1(encode$2(raw));
        try {
            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });
        }
        catch (error) { }
        tx.hash = keccak256$1(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    const payload = arrayify(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) {
        return _parse(payload);
    }
    // Typed Transaction (EIP-2718)
    switch (payload[0]) {
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
    }
    return logger$s.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}

const version$c = "contracts/5.6.2";

var __awaiter$b = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$r = new Logger(version$c);
///////////////////////////////
const allowedTransactionKeys$1 = {
    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,
    type: true, accessList: true,
    maxFeePerGas: true, maxPriorityFeePerGas: true,
    customData: true,
    ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
    return __awaiter$b(this, void 0, void 0, function* () {
        const name = yield nameOrPromise;
        if (typeof (name) !== "string") {
            logger$r.throwArgumentError("invalid address or ENS name", "name", name);
        }
        // If it is already an address, just use it (after adding checksum)
        try {
            return getAddress(name);
        }
        catch (error) { }
        if (!resolver) {
            logger$r.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName"
            });
        }
        const address = yield resolver.resolveName(name);
        if (address == null) {
            logger$r.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        }
        return address;
    });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
    return __awaiter$b(this, void 0, void 0, function* () {
        if (Array.isArray(paramType)) {
            return yield Promise.all(paramType.map((paramType, index) => {
                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);
            }));
        }
        if (paramType.type === "address") {
            return yield resolveName(resolver, value);
        }
        if (paramType.type === "tuple") {
            return yield resolveAddresses(resolver, value, paramType.components);
        }
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) {
                return Promise.reject(logger$r.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value
                }));
            }
            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
}
function populateTransaction(contract, fragment, args) {
    return __awaiter$b(this, void 0, void 0, function* () {
        // If an extra argument is given, it is overrides
        let overrides = {};
        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
            overrides = shallowCopy(args.pop());
        }
        // Make sure the parameter count matches
        logger$r.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
        // Populate "from" override (allow promises)
        if (contract.signer) {
            if (overrides.from) {
                // Contracts with a Signer are from the Signer's frame-of-reference;
                // but we allow overriding "from" if it matches the signer
                overrides.from = resolveProperties({
                    override: resolveName(contract.signer, overrides.from),
                    signer: contract.signer.getAddress()
                }).then((check) => __awaiter$b(this, void 0, void 0, function* () {
                    if (getAddress(check.signer) !== check.override) {
                        logger$r.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "overrides.from"
                        });
                    }
                    return check.override;
                }));
            }
            else {
                overrides.from = contract.signer.getAddress();
            }
        }
        else if (overrides.from) {
            overrides.from = resolveName(contract.provider, overrides.from);
            //} else {
            // Contracts without a signer can override "from", and if
            // unspecified the zero address is used
            //overrides.from = AddressZero;
        }
        // Wait for all dependencies to be resolved (prefer the signer over the provider)
        const resolved = yield resolveProperties({
            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
            address: contract.resolvedAddress,
            overrides: (resolveProperties(overrides) || {})
        });
        // The ABI coded transaction
        const data = contract.interface.encodeFunctionData(fragment, resolved.args);
        const tx = {
            data: data,
            to: resolved.address
        };
        // Resolved Overrides
        const ro = resolved.overrides;
        // Populate simple overrides
        if (ro.nonce != null) {
            tx.nonce = BigNumber.from(ro.nonce).toNumber();
        }
        if (ro.gasLimit != null) {
            tx.gasLimit = BigNumber.from(ro.gasLimit);
        }
        if (ro.gasPrice != null) {
            tx.gasPrice = BigNumber.from(ro.gasPrice);
        }
        if (ro.maxFeePerGas != null) {
            tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
        }
        if (ro.maxPriorityFeePerGas != null) {
            tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
        }
        if (ro.from != null) {
            tx.from = ro.from;
        }
        if (ro.type != null) {
            tx.type = ro.type;
        }
        if (ro.accessList != null) {
            tx.accessList = accessListify(ro.accessList);
        }
        // If there was no "gasLimit" override, but the ABI specifies a default, use it
        if (tx.gasLimit == null && fragment.gas != null) {
            // Compute the intrinsic gas cost for this transaction
            // @TODO: This is based on the yellow paper as of Petersburg; this is something
            // we may wish to parameterize in v6 as part of the Network object. Since this
            // is always a non-nil to address, we can ignore G_create, but may wish to add
            // similar logic to the ContractFactory.
            let intrinsic = 21000;
            const bytes = arrayify(data);
            for (let i = 0; i < bytes.length; i++) {
                intrinsic += 4;
                if (bytes[i]) {
                    intrinsic += 64;
                }
            }
            tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
        }
        // Populate "value" override
        if (ro.value) {
            const roValue = BigNumber.from(ro.value);
            if (!roValue.isZero() && !fragment.payable) {
                logger$r.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: overrides.value
                });
            }
            tx.value = roValue;
        }
        if (ro.customData) {
            tx.customData = shallowCopy(ro.customData);
        }
        if (ro.ccipReadEnabled) {
            tx.ccipReadEnabled = !!ro.ccipReadEnabled;
        }
        // Remove the overrides
        delete overrides.nonce;
        delete overrides.gasLimit;
        delete overrides.gasPrice;
        delete overrides.from;
        delete overrides.value;
        delete overrides.type;
        delete overrides.accessList;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        delete overrides.customData;
        delete overrides.ccipReadEnabled;
        // Make sure there are no stray overrides, which may indicate a
        // typo or using an unsupported key.
        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));
        if (leftovers.length) {
            logger$r.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides",
                overrides: leftovers
            });
        }
        return tx;
    });
}
function buildPopulate(contract, fragment) {
    return function (...args) {
        return populateTransaction(contract, fragment, args);
    };
}
function buildEstimate(contract, fragment) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter$b(this, void 0, void 0, function* () {
            if (!signerOrProvider) {
                logger$r.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "estimateGas"
                });
            }
            const tx = yield populateTransaction(contract, fragment, args);
            return yield signerOrProvider.estimateGas(tx);
        });
    };
}
function addContractWait(contract, tx) {
    const wait = tx.wait.bind(tx);
    tx.wait = (confirmations) => {
        return wait(confirmations).then((receipt) => {
            receipt.events = receipt.logs.map((log) => {
                let event = deepCopy(log);
                let parsed = null;
                try {
                    parsed = contract.interface.parseLog(log);
                }
                catch (e) { }
                // Successfully parsed the event log; include it
                if (parsed) {
                    event.args = parsed.args;
                    event.decode = (data, topics) => {
                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                    };
                    event.event = parsed.name;
                    event.eventSignature = parsed.signature;
                }
                // Useful operations
                event.removeListener = () => { return contract.provider; };
                event.getBlock = () => {
                    return contract.provider.getBlock(receipt.blockHash);
                };
                event.getTransaction = () => {
                    return contract.provider.getTransaction(receipt.transactionHash);
                };
                event.getTransactionReceipt = () => {
                    return Promise.resolve(receipt);
                };
                return event;
            });
            return receipt;
        });
    };
}
function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter$b(this, void 0, void 0, function* () {
            // Extract the "blockTag" override if present
            let blockTag = undefined;
            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
                const overrides = shallowCopy(args.pop());
                if (overrides.blockTag != null) {
                    blockTag = yield overrides.blockTag;
                }
                delete overrides.blockTag;
                args.push(overrides);
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed(blockTag);
            }
            // Call a node and get the result
            const tx = yield populateTransaction(contract, fragment, args);
            const result = yield signerOrProvider.call(tx, blockTag);
            try {
                let value = contract.interface.decodeFunctionResult(fragment, result);
                if (collapseSimple && fragment.outputs.length === 1) {
                    value = value[0];
                }
                return value;
            }
            catch (error) {
                if (error.code === Logger.errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                }
                throw error;
            }
        });
    };
}
function buildSend(contract, fragment) {
    return function (...args) {
        return __awaiter$b(this, void 0, void 0, function* () {
            if (!contract.signer) {
                logger$r.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction"
                });
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed();
            }
            const txRequest = yield populateTransaction(contract, fragment, args);
            const tx = yield contract.signer.sendTransaction(txRequest);
            // Tweak the tx.wait so the receipt has extra properties
            addContractWait(contract, tx);
            return tx;
        });
    };
}
function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
        return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
}
function getEventTag$1(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
        return "*";
    }
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
        if (Array.isArray(topic)) {
            return topic.join("|");
        }
        return topic;
    }).join(":") : "");
}
class RunningEvent {
    constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
    }
    addListener(listener, once) {
        this._listeners.push({ listener: listener, once: once });
    }
    removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
            if (done || item.listener !== listener) {
                return true;
            }
            done = true;
            return false;
        });
    }
    removeAllListeners() {
        this._listeners = [];
    }
    listeners() {
        return this._listeners.map((i) => i.listener);
    }
    listenerCount() {
        return this._listeners.length;
    }
    run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
            const argsCopy = args.slice();
            // Call the callback in the next event loop
            setTimeout(() => {
                item.listener.apply(this, argsCopy);
            }, 0);
            // Reschedule it if it not "once"
            return !(item.once);
        });
        return listenerCount;
    }
    prepareEvent(event) {
    }
    // Returns the array that will be applied to an emit
    getEmit(event) {
        return [event];
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor() {
        super("error", null);
    }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
        const filter = {
            address: address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
            if (topic !== topics[0]) {
                logger$r.throwArgumentError("topic mismatch", "topics", topics);
            }
            filter.topics = topics.slice();
        }
        else {
            filter.topics = [topic];
        }
        super(getEventTag$1(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
            return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        }
        catch (error) {
            event.args = null;
            event.decodeError = error;
        }
    }
    getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
            throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
    }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
    constructor(address, contractInterface) {
        super("*", { address: address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        try {
            const parsed = this.interface.parseLog(event);
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
            event.decode = (data, topics) => {
                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.args = parsed.args;
        }
        catch (error) {
            // No matching event
        }
    }
}
class BaseContract {
    constructor(addressOrName, contractInterface, signerOrProvider) {
        // @TODO: Maybe still check the addressOrName looks like a valid address or name?
        //address = getAddress(address);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
            defineReadOnly(this, "provider", null);
            defineReadOnly(this, "signer", null);
        }
        else if (Signer.isSigner(signerOrProvider)) {
            defineReadOnly(this, "provider", signerOrProvider.provider || null);
            defineReadOnly(this, "signer", signerOrProvider);
        }
        else if (Provider.isProvider(signerOrProvider)) {
            defineReadOnly(this, "provider", signerOrProvider);
            defineReadOnly(this, "signer", null);
        }
        else {
            logger$r.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
            const uniqueFilters = {};
            Object.keys(this.interface.events).forEach((eventSignature) => {
                const event = this.interface.events[eventSignature];
                defineReadOnly(this.filters, eventSignature, (...args) => {
                    return {
                        address: this.address,
                        topics: this.interface.encodeFilterTopics(event, args)
                    };
                });
                if (!uniqueFilters[event.name]) {
                    uniqueFilters[event.name] = [];
                }
                uniqueFilters[event.name].push(eventSignature);
            });
            Object.keys(uniqueFilters).forEach((name) => {
                const filters = uniqueFilters[name];
                if (filters.length === 1) {
                    defineReadOnly(this.filters, name, this.filters[filters[0]]);
                }
                else {
                    logger$r.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
                }
            });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
            logger$r.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
            defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        }
        else {
            try {
                defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
            }
            catch (error) {
                // Without a provider, we cannot use ENS names
                logger$r.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract"
                });
            }
        }
        // Swallow bad ENS names to prevent Unhandled Exceptions
        this.resolvedAddress.catch((e) => { });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
            const fragment = this.interface.functions[signature];
            // Check that the signature is unique; if not the ABI generation has
            // not been cleaned or may be incorrectly generated
            if (uniqueSignatures[signature]) {
                logger$r.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
                return;
            }
            uniqueSignatures[signature] = true;
            // Track unique names; we only expose bare named functions if they
            // are ambiguous
            {
                const name = fragment.name;
                if (!uniqueNames[`%${name}`]) {
                    uniqueNames[`%${name}`] = [];
                }
                uniqueNames[`%${name}`].push(signature);
            }
            if (this[signature] == null) {
                defineReadOnly(this, signature, buildDefault(this, fragment, true));
            }
            // We do not collapse simple calls on this bucket, which allows
            // frameworks to safely use this without introspection as well as
            // allows decoding error recovery.
            if (this.functions[signature] == null) {
                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
            }
            if (this.callStatic[signature] == null) {
                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
            }
            if (this.populateTransaction[signature] == null) {
                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
            }
            if (this.estimateGas[signature] == null) {
                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
            }
        });
        Object.keys(uniqueNames).forEach((name) => {
            // Ambiguous names to not get attached as bare names
            const signatures = uniqueNames[name];
            if (signatures.length > 1) {
                return;
            }
            // Strip off the leading "%" used for prototype protection
            name = name.substring(1);
            const signature = signatures[0];
            // If overwriting a member property that is null, swallow the error
            try {
                if (this[name] == null) {
                    defineReadOnly(this, name, this[signature]);
                }
            }
            catch (e) { }
            if (this.functions[name] == null) {
                defineReadOnly(this.functions, name, this.functions[signature]);
            }
            if (this.callStatic[name] == null) {
                defineReadOnly(this.callStatic, name, this.callStatic[signature]);
            }
            if (this.populateTransaction[name] == null) {
                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
            }
            if (this.estimateGas[name] == null) {
                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
            }
        });
    }
    static getContractAddress(transaction) {
        return getContractAddress(transaction);
    }
    static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
            return contractInterface;
        }
        return new Interface(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
        return this._deployed();
    }
    _deployed(blockTag) {
        if (!this._deployedPromise) {
            // If we were just deployed, we know the transaction we should occur in
            if (this.deployTransaction) {
                this._deployedPromise = this.deployTransaction.wait().then(() => {
                    return this;
                });
            }
            else {
                // @TODO: Once we allow a timeout to be passed in, we will wait
                // up to that many blocks for getCode
                // Otherwise, poll for our code to be deployed
                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
                    if (code === "0x") {
                        logger$r.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                            contractAddress: this.address,
                            operation: "getDeployed"
                        });
                    }
                    return this;
                });
            }
        }
        return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
        if (!this.signer) {
            logger$r.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function (key) {
            if (tx[key] == null) {
                return;
            }
            logger$r.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
            return this.signer.sendTransaction(tx);
        });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
        if (typeof (signerOrProvider) === "string") {
            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
            defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
        return Indexed.isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
        // Already have an instance of this event running; we can re-use it
        if (this._runningEvents[runningEvent.tag]) {
            return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
    }
    _getRunningEvent(eventName) {
        if (typeof (eventName) === "string") {
            // Listen for "error" events (if your contract has an error event, include
            // the full signature to bypass this special event keyword)
            if (eventName === "error") {
                return this._normalizeRunningEvent(new ErrorRunningEvent());
            }
            // Listen for any event that is registered
            if (eventName === "event") {
                return this._normalizeRunningEvent(new RunningEvent("event", null));
            }
            // Listen for any event
            if (eventName === "*") {
                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
            }
            // Get the event Fragment (throws if ambiguous/unknown event)
            const fragment = this.interface.getEvent(eventName);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        // We have topics to filter by...
        if (eventName.topics && eventName.topics.length > 0) {
            // Is it a known topichash? (throws if no matching topichash)
            try {
                const topic = eventName.topics[0];
                if (typeof (topic) !== "string") {
                    throw new Error("invalid topic"); // @TODO: May happen for anonymous events
                }
                const fragment = this.interface.getEvent(topic);
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
            }
            catch (error) { }
            // Filter by the unknown topichash
            const filter = {
                address: this.address,
                topics: eventName.topics
            };
            return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
            delete this._runningEvents[runningEvent.tag];
            // If we have a poller for this, remove it
            const emit = this._wrappedEmits[runningEvent.tag];
            if (emit && runningEvent.filter) {
                this.provider.off(runningEvent.filter, emit);
                delete this._wrappedEmits[runningEvent.tag];
            }
        }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
        const event = deepCopy(log);
        event.removeListener = () => {
            if (!listener) {
                return;
            }
            runningEvent.removeListener(listener);
            this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };
        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };
        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };
        // This may throw if the topics and data mismatch the signature
        runningEvent.prepareEvent(event);
        return event;
    }
    _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
            logger$r.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        // Track this running event and its listeners (may already be there; but no hard in updating)
        this._runningEvents[runningEvent.tag] = runningEvent;
        // If we are not polling the provider, start polling
        if (!this._wrappedEmits[runningEvent.tag]) {
            const wrappedEmit = (log) => {
                let event = this._wrapEvent(runningEvent, log, listener);
                // Try to emit the result for the parameterized event...
                if (event.decodeError == null) {
                    try {
                        const args = runningEvent.getEmit(event);
                        this.emit(runningEvent.filter, ...args);
                    }
                    catch (error) {
                        event.decodeError = error.error;
                    }
                }
                // Always emit "event" for fragment-base events
                if (runningEvent.filter != null) {
                    this.emit("event", event);
                }
                // Emit "error" if there was an error
                if (event.decodeError != null) {
                    this.emit("error", event.decodeError, event);
                }
            };
            this._wrappedEmits[runningEvent.tag] = wrappedEmit;
            // Special events, like "error" do not have a filter
            if (runningEvent.filter != null) {
                this.provider.on(runningEvent.filter, wrappedEmit);
            }
        }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof (fromBlockOrBlockhash) === "string" && isHexString(fromBlockOrBlockhash, 32)) {
            if (toBlock != null) {
                logger$r.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
            }
            filter.blockHash = fromBlockOrBlockhash;
        }
        else {
            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);
            filter.toBlock = ((toBlock != null) ? toBlock : "latest");
        }
        return this.provider.getLogs(filter).then((logs) => {
            return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
    }
    on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
    }
    once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
    }
    emit(eventName, ...args) {
        if (!this.provider) {
            return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = (runningEvent.run(args) > 0);
        // May have drained all the "once" events; check for living events
        this._checkRunningEvents(runningEvent);
        return result;
    }
    listenerCount(eventName) {
        if (!this.provider) {
            return 0;
        }
        if (eventName == null) {
            return Object.keys(this._runningEvents).reduce((accum, key) => {
                return accum + this._runningEvents[key].listenerCount();
            }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
        if (!this.provider) {
            return [];
        }
        if (eventName == null) {
            const result = [];
            for (let tag in this._runningEvents) {
                this._runningEvents[tag].listeners().forEach((listener) => {
                    result.push(listener);
                });
            }
            return result;
        }
        return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
        if (!this.provider) {
            return this;
        }
        if (eventName == null) {
            for (const tag in this._runningEvents) {
                const runningEvent = this._runningEvents[tag];
                runningEvent.removeAllListeners();
                this._checkRunningEvents(runningEvent);
            }
            return this;
        }
        // Delete any listeners
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
    }
    off(eventName, listener) {
        if (!this.provider) {
            return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
    }
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
}
class Contract extends BaseContract {
}
class ContractFactory {
    constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof (bytecode) === "string") {
            bytecodeHex = bytecode;
        }
        else if (isBytes(bytecode)) {
            bytecodeHex = hexlify(bytecode);
        }
        else if (bytecode && typeof (bytecode.object) === "string") {
            // Allow the bytecode object from the Solidity compiler
            bytecodeHex = bytecode.object;
        }
        else {
            // Crash in the next verification step
            bytecodeHex = "!";
        }
        // Make sure it is 0x prefixed
        if (bytecodeHex.substring(0, 2) !== "0x") {
            bytecodeHex = "0x" + bytecodeHex;
        }
        // Make sure the final result is valid bytecode
        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {
            logger$r.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        // If we have a signer, make sure it is valid
        if (signer && !Signer.isSigner(signer)) {
            logger$r.throwArgumentError("invalid signer", "signer", signer);
        }
        defineReadOnly(this, "bytecode", bytecodeHex);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        defineReadOnly(this, "signer", signer || null);
    }
    // @TODO: Future; rename to populateTransaction?
    getDeployTransaction(...args) {
        let tx = {};
        // If we have 1 additional argument, we allow transaction overrides
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
            tx = shallowCopy(args.pop());
            for (const key in tx) {
                if (!allowedTransactionKeys$1[key]) {
                    throw new Error("unknown transaction override " + key);
                }
            }
        }
        // Do not allow these to be overridden in a deployment transaction
        ["data", "from", "to"].forEach((key) => {
            if (tx[key] == null) {
                return;
            }
            logger$r.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        if (tx.value) {
            const value = BigNumber.from(tx.value);
            if (!value.isZero() && !this.interface.deploy.payable) {
                logger$r.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: tx.value
                });
            }
        }
        // Make sure the call matches the constructor signature
        logger$r.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        // Set the data to the bytecode + the encoded constructor arguments
        tx.data = hexlify(concat([
            this.bytecode,
            this.interface.encodeDeploy(args)
        ]));
        return tx;
    }
    deploy(...args) {
        return __awaiter$b(this, void 0, void 0, function* () {
            let overrides = {};
            // If 1 extra parameter was passed in, it contains overrides
            if (args.length === this.interface.deploy.inputs.length + 1) {
                overrides = args.pop();
            }
            // Make sure the call matches the constructor signature
            logger$r.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
            // Resolve ENS names and promises in the arguments
            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
            params.push(overrides);
            // Get the deployment transaction (with optional overrides)
            const unsignedTx = this.getDeployTransaction(...params);
            // Send the deployment transaction
            const tx = yield this.signer.sendTransaction(unsignedTx);
            const address = getStatic(this.constructor, "getContractAddress")(tx);
            const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
            // Add the modified wait that wraps events
            addContractWait(contract, tx);
            defineReadOnly(contract, "deployTransaction", tx);
            return contract;
        });
    }
    attach(address) {
        return (this.constructor).getContract(address, this.interface, this.signer);
    }
    connect(signer) {
        return new (this.constructor)(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
            logger$r.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof (compilerOutput) === "string") {
            compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
            bytecode = compilerOutput.bytecode;
        }
        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
            bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
        return getContractAddress(tx);
    }
    static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
    }
}

/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */
class BaseX {
    constructor(alphabet) {
        defineReadOnly(this, "alphabet", alphabet);
        defineReadOnly(this, "base", alphabet.length);
        defineReadOnly(this, "_alphabetMap", {});
        defineReadOnly(this, "_leader", alphabet.charAt(0));
        // pre-compute lookup table
        for (let i = 0; i < alphabet.length; i++) {
            this._alphabetMap[alphabet.charAt(i)] = i;
        }
    }
    encode(value) {
        let source = arrayify(value);
        if (source.length === 0) {
            return "";
        }
        let digits = [0];
        for (let i = 0; i < source.length; ++i) {
            let carry = source[i];
            for (let j = 0; j < digits.length; ++j) {
                carry += digits[j] << 8;
                digits[j] = carry % this.base;
                carry = (carry / this.base) | 0;
            }
            while (carry > 0) {
                digits.push(carry % this.base);
                carry = (carry / this.base) | 0;
            }
        }
        let string = "";
        // deal with leading zeros
        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
            string += this._leader;
        }
        // convert digits to a string
        for (let q = digits.length - 1; q >= 0; --q) {
            string += this.alphabet[digits[q]];
        }
        return string;
    }
    decode(value) {
        if (typeof (value) !== "string") {
            throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value.length === 0) {
            return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i = 0; i < value.length; i++) {
            let byte = this._alphabetMap[value[i]];
            if (byte === undefined) {
                throw new Error("Non-base" + this.base + " character");
            }
            let carry = byte;
            for (let j = 0; j < bytes.length; ++j) {
                carry += bytes[j] * this.base;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while (carry > 0) {
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        // deal with leading zeros
        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
            bytes.push(0);
        }
        return arrayify(new Uint8Array(bytes.reverse()));
    }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
//console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))

var SupportedAlgorithm;
(function (SupportedAlgorithm) {
    SupportedAlgorithm["sha256"] = "sha256";
    SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

const version$b = "sha2/5.6.1";

const logger$q = new Logger(version$b);
function ripemd160(data) {
    return "0x" + (hash.ripemd160().update(arrayify(data)).digest("hex"));
}
function sha256$1(data) {
    return "0x" + (hash.sha256().update(arrayify(data)).digest("hex"));
}
function sha512(data) {
    return "0x" + (hash.sha512().update(arrayify(data)).digest("hex"));
}
function computeHmac(algorithm, key, data) {
    if (!SupportedAlgorithm[algorithm]) {
        logger$q.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "hmac",
            algorithm: algorithm
        });
    }
    return "0x" + hash.hmac(hash[algorithm], arrayify(key)).update(arrayify(data)).digest("hex");
}

function pbkdf2$1(password, salt, iterations, keylen, hashAlgorithm) {
    password = arrayify(password);
    salt = arrayify(salt);
    let hLen;
    let l = 1;
    const DK = new Uint8Array(keylen);
    const block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    //salt.copy(block1, 0, 0, salt.length)
    let r;
    let T;
    for (let i = 1; i <= l; i++) {
        //block1.writeUInt32BE(i, salt.length)
        block1[salt.length] = (i >> 24) & 0xff;
        block1[salt.length + 1] = (i >> 16) & 0xff;
        block1[salt.length + 2] = (i >> 8) & 0xff;
        block1[salt.length + 3] = i & 0xff;
        //let U = createHmac(password).update(block1).digest();
        let U = arrayify(computeHmac(hashAlgorithm, password, block1));
        if (!hLen) {
            hLen = U.length;
            T = new Uint8Array(hLen);
            l = Math.ceil(keylen / hLen);
            r = keylen - (l - 1) * hLen;
        }
        //U.copy(T, 0, 0, hLen)
        T.set(U);
        for (let j = 1; j < iterations; j++) {
            //U = createHmac(password).update(U).digest();
            U = arrayify(computeHmac(hashAlgorithm, password, U));
            for (let k = 0; k < hLen; k++)
                T[k] ^= U[k];
        }
        const destPos = (i - 1) * hLen;
        const len = (i === l ? r : hLen);
        //T.copy(DK, destPos, 0, len)
        DK.set(arrayify(T).slice(0, len), destPos);
    }
    return hexlify(DK);
}

const version$a = "wordlists/5.6.1";

const logger$p = new Logger(version$a);
class Wordlist {
    constructor(locale) {
        logger$p.checkAbstract(new.target, Wordlist);
        defineReadOnly(this, "locale", locale);
    }
    // Subclasses may override this
    split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
    }
    // Subclasses may override this
    join(words) {
        return words.join(" ");
    }
    static check(wordlist) {
        const words = [];
        for (let i = 0; i < 2048; i++) {
            const word = wordlist.getWord(i);
            /* istanbul ignore if */
            if (i !== wordlist.getWordIndex(word)) {
                return "0x";
            }
            words.push(word);
        }
        return id(words.join("\n") + "\n");
    }
    static register(lang, name) {
    }
}

const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
    if (wordlist != null) {
        return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
}
class LangEn extends Wordlist {
    constructor() {
        super("en");
    }
    getWord(index) {
        loadWords(this);
        return wordlist[index];
    }
    getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
    }
}
const langEn = new LangEn();
Wordlist.register(langEn);

const wordlists = {
    en: langEn
};

const version$9 = "hdnode/5.6.2";

const logger$o = new Logger(version$9);
const N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
// "Bitcoin seed"
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 0x80000000;
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
    return ((1 << bits) - 1) << (8 - bits);
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
    return (1 << bits) - 1;
}
function bytes32(value) {
    return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
    return Base58.encode(concat([data, hexDataSlice(sha256$1(sha256$1(data)), 0, 4)]));
}
function getWordlist(wordlist) {
    if (wordlist == null) {
        return wordlists["en"];
    }
    if (typeof (wordlist) === "string") {
        const words = wordlists[wordlist];
        if (words == null) {
            logger$o.throwArgumentError("unknown locale", "wordlist", wordlist);
        }
        return words;
    }
    return wordlist;
}
const _constructorGuard$1 = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
    /**
     *  This constructor should not be called directly.
     *
     *  Please use:
     *   - fromMnemonic
     *   - fromSeed
     */
    constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        /* istanbul ignore if */
        if (constructorGuard !== _constructorGuard$1) {
            throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "privateKey", signingKey.privateKey);
            defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
        }
        else {
            defineReadOnly(this, "privateKey", null);
            defineReadOnly(this, "publicKey", hexlify(publicKey));
        }
        defineReadOnly(this, "parentFingerprint", parentFingerprint);
        defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256$1(this.publicKey)), 0, 4));
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        defineReadOnly(this, "chainCode", chainCode);
        defineReadOnly(this, "index", index);
        defineReadOnly(this, "depth", depth);
        if (mnemonicOrPath == null) {
            // From a source that does not preserve the path (e.g. extended keys)
            defineReadOnly(this, "mnemonic", null);
            defineReadOnly(this, "path", null);
        }
        else if (typeof (mnemonicOrPath) === "string") {
            // From a source that does not preserve the mnemonic (e.g. neutered)
            defineReadOnly(this, "mnemonic", null);
            defineReadOnly(this, "path", mnemonicOrPath);
        }
        else {
            // From a fully qualified source
            defineReadOnly(this, "mnemonic", mnemonicOrPath);
            defineReadOnly(this, "path", mnemonicOrPath.path);
        }
    }
    get extendedKey() {
        // We only support the mainnet values for now, but if anyone needs
        // testnet values, let me know. I believe current sentiment is that
        // we should always use mainnet, and use BIP-44 to derive the network
        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
        //   - Testnet: public=0x043587CF, private=0x04358394
        if (this.depth >= 256) {
            throw new Error("Depth too large!");
        }
        return base58check(concat([
            ((this.privateKey != null) ? "0x0488ADE4" : "0x0488B21E"),
            hexlify(this.depth),
            this.parentFingerprint,
            hexZeroPad(hexlify(this.index), 4),
            this.chainCode,
            ((this.privateKey != null) ? concat(["0x00", this.privateKey]) : this.publicKey),
        ]));
    }
    neuter() {
        return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(index) {
        if (index > 0xffffffff) {
            throw new Error("invalid index - " + String(index));
        }
        // Base path
        let path = this.path;
        if (path) {
            path += "/" + (index & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
            if (!this.privateKey) {
                throw new Error("cannot derive child of neutered node");
            }
            // Data = 0x00 || ser_256(k_par)
            data.set(arrayify(this.privateKey), 1);
            // Hardened path
            if (path) {
                path += "'";
            }
        }
        else {
            // Data = ser_p(point(k_par))
            data.set(arrayify(this.publicKey));
        }
        // Data += ser_32(i)
        for (let i = 24; i >= 0; i -= 8) {
            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);
        }
        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // The private key
        let ki = null;
        // The public key
        let Ki = null;
        if (this.privateKey) {
            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
        }
        else {
            const ek = new SigningKey(hexlify(IL));
            Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
            mnemonicOrPath = Object.freeze({
                phrase: srcMnemonic.phrase,
                path: path,
                locale: (srcMnemonic.locale || "en")
            });
        }
        return new HDNode(_constructorGuard$1, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
    }
    derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || (components[0] === "m" && this.depth !== 0)) {
            throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
            components.shift();
        }
        let result = this;
        for (let i = 0; i < components.length; i++) {
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
                const index = parseInt(component.substring(0, component.length - 1));
                if (index >= HardenedBit) {
                    throw new Error("invalid path index - " + component);
                }
                result = result._derive(HardenedBit + index);
            }
            else if (component.match(/^[0-9]+$/)) {
                const index = parseInt(component);
                if (index >= HardenedBit) {
                    throw new Error("invalid path index - " + component);
                }
                result = result._derive(index);
            }
            else {
                throw new Error("invalid path component - " + component);
            }
        }
        return result;
    }
    static _fromSeed(seed, mnemonic) {
        const seedArray = arrayify(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
            throw new Error("invalid seed");
        }
        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard$1, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
    }
    static fromMnemonic(mnemonic, password, wordlist) {
        // If a locale name was passed in, find the associated wordlist
        wordlist = getWordlist(wordlist);
        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
            phrase: mnemonic,
            path: "m",
            locale: wordlist.locale
        });
    }
    static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
    }
    static fromExtendedKey(extendedKey) {
        const bytes = Base58.decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
            logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes[4];
        const parentFingerprint = hexlify(bytes.slice(5, 9));
        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = hexlify(bytes.slice(13, 45));
        const key = bytes.slice(45, 78);
        switch (hexlify(bytes.slice(0, 4))) {
            // Public Key
            case "0x0488b21e":
            case "0x043587cf":
                return new HDNode(_constructorGuard$1, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
                if (key[0] !== 0) {
                    break;
                }
                return new HDNode(_constructorGuard$1, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
}
function mnemonicToSeed(mnemonic, password) {
    if (!password) {
        password = "";
    }
    const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
    return pbkdf2$1(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = getWordlist(wordlist);
    logger$o.checkNormalize();
    const words = wordlist.split(mnemonic);
    if ((words.length % 3) !== 0) {
        throw new Error("invalid mnemonic");
    }
    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));
    let offset = 0;
    for (let i = 0; i < words.length; i++) {
        let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
        if (index === -1) {
            throw new Error("invalid mnemonic");
        }
        for (let bit = 0; bit < 11; bit++) {
            if (index & (1 << (10 - bit))) {
                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));
            }
            offset++;
        }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = arrayify(sha256$1(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
        throw new Error("invalid checksum");
    }
    return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
    wordlist = getWordlist(wordlist);
    entropy = arrayify(entropy);
    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {
        throw new Error("invalid entropy");
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i++) {
        // Consume the whole byte (with still more to go)
        if (remainingBits > 8) {
            indices[indices.length - 1] <<= 8;
            indices[indices.length - 1] |= entropy[i];
            remainingBits -= 8;
            // This byte will complete an 11-bit index
        }
        else {
            indices[indices.length - 1] <<= remainingBits;
            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
            // Start the next word
            indices.push(entropy[i] & getLowerMask(8 - remainingBits));
            remainingBits += 3;
        }
    }
    // Compute the checksum bits
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha256$1(entropy))[0] & getUpperMask(checksumBits);
    // Shift the checksum into the word indices
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));
    return wordlist.join(indices.map((index) => wordlist.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
        return true;
    }
    catch (error) { }
    return false;
}
function getAccountPath(index) {
    if (typeof (index) !== "number" || index < 0 || index >= HardenedBit || index % 1) {
        logger$o.throwArgumentError("invalid account index", "index", index);
    }
    return `m/44'/60'/${index}'/0/0`;
}

const version$8 = "random/5.6.1";

const logger$n = new Logger(version$8);
// Debugging line for testing browser lib in node
//const window = { crypto: { getRandomValues: () => { } } };
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
function getGlobal() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
}
const anyGlobal = getGlobal();
let crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto || !crypto.getRandomValues) {
    logger$n.warn("WARNING: Missing strong random number source");
    crypto = {
        getRandomValues: function (buffer) {
            return logger$n.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "crypto.getRandomValues"
            });
        }
    };
}
function randomBytes(length) {
    if (length <= 0 || length > 1024 || (length % 1) || length != length) {
        logger$n.throwArgumentError("invalid length", "length", length);
    }
    const result = new Uint8Array(length);
    crypto.getRandomValues(result);
    return arrayify(result);
}

function shuffled(array) {
    array = array.slice();
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    return array;
}

var aesJs = {exports: {}};

(function (module, exports) {

	(function(root) {

	    function checkInt(value) {
	        return (parseInt(value) === value);
	    }

	    function checkInts(arrayish) {
	        if (!checkInt(arrayish.length)) { return false; }

	        for (var i = 0; i < arrayish.length; i++) {
	            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
	                return false;
	            }
	        }

	        return true;
	    }

	    function coerceArray(arg, copy) {

	        // ArrayBuffer view
	        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {

	            if (copy) {
	                if (arg.slice) {
	                    arg = arg.slice();
	                } else {
	                    arg = Array.prototype.slice.call(arg);
	                }
	            }

	            return arg;
	        }

	        // It's an array; check it is a valid representation of a byte
	        if (Array.isArray(arg)) {
	            if (!checkInts(arg)) {
	                throw new Error('Array contains invalid value: ' + arg);
	            }

	            return new Uint8Array(arg);
	        }

	        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
	        if (checkInt(arg.length) && checkInts(arg)) {
	            return new Uint8Array(arg);
	        }

	        throw new Error('unsupported array-like object');
	    }

	    function createArray(length) {
	        return new Uint8Array(length);
	    }

	    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
	        if (sourceStart != null || sourceEnd != null) {
	            if (sourceArray.slice) {
	                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
	            } else {
	                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
	            }
	        }
	        targetArray.set(sourceArray, targetStart);
	    }



	    var convertUtf8 = (function() {
	        function toBytes(text) {
	            var result = [], i = 0;
	            text = encodeURI(text);
	            while (i < text.length) {
	                var c = text.charCodeAt(i++);

	                // if it is a % sign, encode the following 2 bytes as a hex value
	                if (c === 37) {
	                    result.push(parseInt(text.substr(i, 2), 16));
	                    i += 2;

	                // otherwise, just the actual byte
	                } else {
	                    result.push(c);
	                }
	            }

	            return coerceArray(result);
	        }

	        function fromBytes(bytes) {
	            var result = [], i = 0;

	            while (i < bytes.length) {
	                var c = bytes[i];

	                if (c < 128) {
	                    result.push(String.fromCharCode(c));
	                    i++;
	                } else if (c > 191 && c < 224) {
	                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
	                    i += 2;
	                } else {
	                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
	                    i += 3;
	                }
	            }

	            return result.join('');
	        }

	        return {
	            toBytes: toBytes,
	            fromBytes: fromBytes,
	        }
	    })();

	    var convertHex = (function() {
	        function toBytes(text) {
	            var result = [];
	            for (var i = 0; i < text.length; i += 2) {
	                result.push(parseInt(text.substr(i, 2), 16));
	            }

	            return result;
	        }

	        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
	        var Hex = '0123456789abcdef';

	        function fromBytes(bytes) {
	                var result = [];
	                for (var i = 0; i < bytes.length; i++) {
	                    var v = bytes[i];
	                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
	                }
	                return result.join('');
	        }

	        return {
	            toBytes: toBytes,
	            fromBytes: fromBytes,
	        }
	    })();


	    // Number of rounds by keysize
	    var numberOfRounds = {16: 10, 24: 12, 32: 14};

	    // Round constant words
	    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

	    // S-box and Inverse S-box (S is for Substitution)
	    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
	    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

	    // Transformations for encryption
	    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
	    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
	    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
	    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

	    // Transformations for decryption
	    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
	    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
	    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
	    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

	    // Transformations for decryption key expansion
	    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
	    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
	    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
	    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

	    function convertToInt32(bytes) {
	        var result = [];
	        for (var i = 0; i < bytes.length; i += 4) {
	            result.push(
	                (bytes[i    ] << 24) |
	                (bytes[i + 1] << 16) |
	                (bytes[i + 2] <<  8) |
	                 bytes[i + 3]
	            );
	        }
	        return result;
	    }

	    var AES = function(key) {
	        if (!(this instanceof AES)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        Object.defineProperty(this, 'key', {
	            value: coerceArray(key, true)
	        });

	        this._prepare();
	    };


	    AES.prototype._prepare = function() {

	        var rounds = numberOfRounds[this.key.length];
	        if (rounds == null) {
	            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
	        }

	        // encryption round keys
	        this._Ke = [];

	        // decryption round keys
	        this._Kd = [];

	        for (var i = 0; i <= rounds; i++) {
	            this._Ke.push([0, 0, 0, 0]);
	            this._Kd.push([0, 0, 0, 0]);
	        }

	        var roundKeyCount = (rounds + 1) * 4;
	        var KC = this.key.length / 4;

	        // convert the key into ints
	        var tk = convertToInt32(this.key);

	        // copy values into round key arrays
	        var index;
	        for (var i = 0; i < KC; i++) {
	            index = i >> 2;
	            this._Ke[index][i % 4] = tk[i];
	            this._Kd[rounds - index][i % 4] = tk[i];
	        }

	        // key expansion (fips-197 section 5.2)
	        var rconpointer = 0;
	        var t = KC, tt;
	        while (t < roundKeyCount) {
	            tt = tk[KC - 1];
	            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
	                      (S[(tt >>  8) & 0xFF] << 16) ^
	                      (S[ tt        & 0xFF] <<  8) ^
	                       S[(tt >> 24) & 0xFF]        ^
	                      (rcon[rconpointer] << 24));
	            rconpointer += 1;

	            // key expansion (for non-256 bit)
	            if (KC != 8) {
	                for (var i = 1; i < KC; i++) {
	                    tk[i] ^= tk[i - 1];
	                }

	            // key expansion for 256-bit keys is "slightly different" (fips-197)
	            } else {
	                for (var i = 1; i < (KC / 2); i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	                tt = tk[(KC / 2) - 1];

	                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
	                              (S[(tt >>  8) & 0xFF] <<  8) ^
	                              (S[(tt >> 16) & 0xFF] << 16) ^
	                              (S[(tt >> 24) & 0xFF] << 24));

	                for (var i = (KC / 2) + 1; i < KC; i++) {
	                    tk[i] ^= tk[i - 1];
	                }
	            }

	            // copy values into round key arrays
	            var i = 0, r, c;
	            while (i < KC && t < roundKeyCount) {
	                r = t >> 2;
	                c = t % 4;
	                this._Ke[r][c] = tk[i];
	                this._Kd[rounds - r][c] = tk[i++];
	                t++;
	            }
	        }

	        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
	        for (var r = 1; r < rounds; r++) {
	            for (var c = 0; c < 4; c++) {
	                tt = this._Kd[r][c];
	                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
	                                  U2[(tt >> 16) & 0xFF] ^
	                                  U3[(tt >>  8) & 0xFF] ^
	                                  U4[ tt        & 0xFF]);
	            }
	        }
	    };

	    AES.prototype.encrypt = function(plaintext) {
	        if (plaintext.length != 16) {
	            throw new Error('invalid plaintext size (must be 16 bytes)');
	        }

	        var rounds = this._Ke.length - 1;
	        var a = [0, 0, 0, 0];

	        // convert plaintext to (ints ^ key)
	        var t = convertToInt32(plaintext);
	        for (var i = 0; i < 4; i++) {
	            t[i] ^= this._Ke[0][i];
	        }

	        // apply round transforms
	        for (var r = 1; r < rounds; r++) {
	            for (var i = 0; i < 4; i++) {
	                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
	                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
	                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
	                        T4[ t[(i + 3) % 4]        & 0xff] ^
	                        this._Ke[r][i]);
	            }
	            t = a.slice();
	        }

	        // the last round is special
	        var result = createArray(16), tt;
	        for (var i = 0; i < 4; i++) {
	            tt = this._Ke[rounds][i];
	            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
	            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
	            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
	            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
	        }

	        return result;
	    };

	    AES.prototype.decrypt = function(ciphertext) {
	        if (ciphertext.length != 16) {
	            throw new Error('invalid ciphertext size (must be 16 bytes)');
	        }

	        var rounds = this._Kd.length - 1;
	        var a = [0, 0, 0, 0];

	        // convert plaintext to (ints ^ key)
	        var t = convertToInt32(ciphertext);
	        for (var i = 0; i < 4; i++) {
	            t[i] ^= this._Kd[0][i];
	        }

	        // apply round transforms
	        for (var r = 1; r < rounds; r++) {
	            for (var i = 0; i < 4; i++) {
	                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
	                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
	                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
	                        T8[ t[(i + 1) % 4]        & 0xff] ^
	                        this._Kd[r][i]);
	            }
	            t = a.slice();
	        }

	        // the last round is special
	        var result = createArray(16), tt;
	        for (var i = 0; i < 4; i++) {
	            tt = this._Kd[rounds][i];
	            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
	            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
	            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
	            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
	        }

	        return result;
	    };


	    /**
	     *  Mode Of Operation - Electonic Codebook (ECB)
	     */
	    var ModeOfOperationECB = function(key) {
	        if (!(this instanceof ModeOfOperationECB)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Electronic Code Block";
	        this.name = "ecb";

	        this._aes = new AES(key);
	    };

	    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
	        plaintext = coerceArray(plaintext);

	        if ((plaintext.length % 16) !== 0) {
	            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
	        }

	        var ciphertext = createArray(plaintext.length);
	        var block = createArray(16);

	        for (var i = 0; i < plaintext.length; i += 16) {
	            copyArray(plaintext, block, 0, i, i + 16);
	            block = this._aes.encrypt(block);
	            copyArray(block, ciphertext, i);
	        }

	        return ciphertext;
	    };

	    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
	        ciphertext = coerceArray(ciphertext);

	        if ((ciphertext.length % 16) !== 0) {
	            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
	        }

	        var plaintext = createArray(ciphertext.length);
	        var block = createArray(16);

	        for (var i = 0; i < ciphertext.length; i += 16) {
	            copyArray(ciphertext, block, 0, i, i + 16);
	            block = this._aes.decrypt(block);
	            copyArray(block, plaintext, i);
	        }

	        return plaintext;
	    };


	    /**
	     *  Mode Of Operation - Cipher Block Chaining (CBC)
	     */
	    var ModeOfOperationCBC = function(key, iv) {
	        if (!(this instanceof ModeOfOperationCBC)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Cipher Block Chaining";
	        this.name = "cbc";

	        if (!iv) {
	            iv = createArray(16);

	        } else if (iv.length != 16) {
	            throw new Error('invalid initialation vector size (must be 16 bytes)');
	        }

	        this._lastCipherblock = coerceArray(iv, true);

	        this._aes = new AES(key);
	    };

	    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
	        plaintext = coerceArray(plaintext);

	        if ((plaintext.length % 16) !== 0) {
	            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
	        }

	        var ciphertext = createArray(plaintext.length);
	        var block = createArray(16);

	        for (var i = 0; i < plaintext.length; i += 16) {
	            copyArray(plaintext, block, 0, i, i + 16);

	            for (var j = 0; j < 16; j++) {
	                block[j] ^= this._lastCipherblock[j];
	            }

	            this._lastCipherblock = this._aes.encrypt(block);
	            copyArray(this._lastCipherblock, ciphertext, i);
	        }

	        return ciphertext;
	    };

	    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
	        ciphertext = coerceArray(ciphertext);

	        if ((ciphertext.length % 16) !== 0) {
	            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
	        }

	        var plaintext = createArray(ciphertext.length);
	        var block = createArray(16);

	        for (var i = 0; i < ciphertext.length; i += 16) {
	            copyArray(ciphertext, block, 0, i, i + 16);
	            block = this._aes.decrypt(block);

	            for (var j = 0; j < 16; j++) {
	                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
	            }

	            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
	        }

	        return plaintext;
	    };


	    /**
	     *  Mode Of Operation - Cipher Feedback (CFB)
	     */
	    var ModeOfOperationCFB = function(key, iv, segmentSize) {
	        if (!(this instanceof ModeOfOperationCFB)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Cipher Feedback";
	        this.name = "cfb";

	        if (!iv) {
	            iv = createArray(16);

	        } else if (iv.length != 16) {
	            throw new Error('invalid initialation vector size (must be 16 size)');
	        }

	        if (!segmentSize) { segmentSize = 1; }

	        this.segmentSize = segmentSize;

	        this._shiftRegister = coerceArray(iv, true);

	        this._aes = new AES(key);
	    };

	    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
	        if ((plaintext.length % this.segmentSize) != 0) {
	            throw new Error('invalid plaintext size (must be segmentSize bytes)');
	        }

	        var encrypted = coerceArray(plaintext, true);

	        var xorSegment;
	        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
	            xorSegment = this._aes.encrypt(this._shiftRegister);
	            for (var j = 0; j < this.segmentSize; j++) {
	                encrypted[i + j] ^= xorSegment[j];
	            }

	            // Shift the register
	            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
	            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
	        }

	        return encrypted;
	    };

	    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
	        if ((ciphertext.length % this.segmentSize) != 0) {
	            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
	        }

	        var plaintext = coerceArray(ciphertext, true);

	        var xorSegment;
	        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
	            xorSegment = this._aes.encrypt(this._shiftRegister);

	            for (var j = 0; j < this.segmentSize; j++) {
	                plaintext[i + j] ^= xorSegment[j];
	            }

	            // Shift the register
	            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
	            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
	        }

	        return plaintext;
	    };

	    /**
	     *  Mode Of Operation - Output Feedback (OFB)
	     */
	    var ModeOfOperationOFB = function(key, iv) {
	        if (!(this instanceof ModeOfOperationOFB)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Output Feedback";
	        this.name = "ofb";

	        if (!iv) {
	            iv = createArray(16);

	        } else if (iv.length != 16) {
	            throw new Error('invalid initialation vector size (must be 16 bytes)');
	        }

	        this._lastPrecipher = coerceArray(iv, true);
	        this._lastPrecipherIndex = 16;

	        this._aes = new AES(key);
	    };

	    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
	        var encrypted = coerceArray(plaintext, true);

	        for (var i = 0; i < encrypted.length; i++) {
	            if (this._lastPrecipherIndex === 16) {
	                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
	                this._lastPrecipherIndex = 0;
	            }
	            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
	        }

	        return encrypted;
	    };

	    // Decryption is symetric
	    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


	    /**
	     *  Counter object for CTR common mode of operation
	     */
	    var Counter = function(initialValue) {
	        if (!(this instanceof Counter)) {
	            throw Error('Counter must be instanitated with `new`');
	        }

	        // We allow 0, but anything false-ish uses the default 1
	        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

	        if (typeof(initialValue) === 'number') {
	            this._counter = createArray(16);
	            this.setValue(initialValue);

	        } else {
	            this.setBytes(initialValue);
	        }
	    };

	    Counter.prototype.setValue = function(value) {
	        if (typeof(value) !== 'number' || parseInt(value) != value) {
	            throw new Error('invalid counter value (must be an integer)');
	        }

	        for (var index = 15; index >= 0; --index) {
	            this._counter[index] = value % 256;
	            value = value >> 8;
	        }
	    };

	    Counter.prototype.setBytes = function(bytes) {
	        bytes = coerceArray(bytes, true);

	        if (bytes.length != 16) {
	            throw new Error('invalid counter bytes size (must be 16 bytes)');
	        }

	        this._counter = bytes;
	    };

	    Counter.prototype.increment = function() {
	        for (var i = 15; i >= 0; i--) {
	            if (this._counter[i] === 255) {
	                this._counter[i] = 0;
	            } else {
	                this._counter[i]++;
	                break;
	            }
	        }
	    };


	    /**
	     *  Mode Of Operation - Counter (CTR)
	     */
	    var ModeOfOperationCTR = function(key, counter) {
	        if (!(this instanceof ModeOfOperationCTR)) {
	            throw Error('AES must be instanitated with `new`');
	        }

	        this.description = "Counter";
	        this.name = "ctr";

	        if (!(counter instanceof Counter)) {
	            counter = new Counter(counter);
	        }

	        this._counter = counter;

	        this._remainingCounter = null;
	        this._remainingCounterIndex = 16;

	        this._aes = new AES(key);
	    };

	    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
	        var encrypted = coerceArray(plaintext, true);

	        for (var i = 0; i < encrypted.length; i++) {
	            if (this._remainingCounterIndex === 16) {
	                this._remainingCounter = this._aes.encrypt(this._counter._counter);
	                this._remainingCounterIndex = 0;
	                this._counter.increment();
	            }
	            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
	        }

	        return encrypted;
	    };

	    // Decryption is symetric
	    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


	    ///////////////////////
	    // Padding

	    // See:https://tools.ietf.org/html/rfc2315
	    function pkcs7pad(data) {
	        data = coerceArray(data, true);
	        var padder = 16 - (data.length % 16);
	        var result = createArray(data.length + padder);
	        copyArray(data, result);
	        for (var i = data.length; i < result.length; i++) {
	            result[i] = padder;
	        }
	        return result;
	    }

	    function pkcs7strip(data) {
	        data = coerceArray(data, true);
	        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

	        var padder = data[data.length - 1];
	        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

	        var length = data.length - padder;
	        for (var i = 0; i < padder; i++) {
	            if (data[length + i] !== padder) {
	                throw new Error('PKCS#7 invalid padding byte');
	            }
	        }

	        var result = createArray(length);
	        copyArray(data, result, 0, 0, length);
	        return result;
	    }

	    ///////////////////////
	    // Exporting


	    // The block cipher
	    var aesjs = {
	        AES: AES,
	        Counter: Counter,

	        ModeOfOperation: {
	            ecb: ModeOfOperationECB,
	            cbc: ModeOfOperationCBC,
	            cfb: ModeOfOperationCFB,
	            ofb: ModeOfOperationOFB,
	            ctr: ModeOfOperationCTR
	        },

	        utils: {
	            hex: convertHex,
	            utf8: convertUtf8
	        },

	        padding: {
	            pkcs7: {
	                pad: pkcs7pad,
	                strip: pkcs7strip
	            }
	        },

	        _arrayTest: {
	            coerceArray: coerceArray,
	            createArray: createArray,
	            copyArray: copyArray,
	        }
	    };


	    // node.js
	    {
	        module.exports = aesjs;

	    // RequireJS/AMD
	    // http://www.requirejs.org/docs/api.html
	    // https://github.com/amdjs/amdjs-api/wiki/AMD
	    }


	})();
} (aesJs));

var aes = aesJs.exports;

const version$7 = "json-wallets/5.6.1";

function looseArrayify(hexString) {
    if (typeof (hexString) === 'string' && hexString.substring(0, 2) !== '0x') {
        hexString = '0x' + hexString;
    }
    return arrayify(hexString);
}
function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
        value = '0' + value;
    }
    return value;
}
function getPassword(password) {
    if (typeof (password) === 'string') {
        return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
    }
    return arrayify(password);
}
function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split('/');
    for (let i = 0; i < comps.length; i++) {
        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for (const key in currentChild) {
            if (key.toLowerCase() === comps[i]) {
                matchingChild = currentChild[key];
                break;
            }
        }
        // Didn't find one. :'(
        if (matchingChild === null) {
            return null;
        }
        // Now check this child...
        currentChild = matchingChild;
    }
    return currentChild;
}
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
function uuidV4(randomBytes) {
    const bytes = arrayify(randomBytes);
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    const value = hexlify(bytes);
    return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34),
    ].join("-");
}

const logger$m = new Logger(version$7);
class CrowdsaleAccount extends Description {
    isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
    }
}
// See: https://github.com/ethereum/pyethsaletool
function decrypt$1(json, password) {
    const data = JSON.parse(json);
    password = getPassword(password);
    // Ethereum Address
    const ethaddr = getAddress(searchPath(data, "ethaddr"));
    // Encrypted Seed
    const encseed = looseArrayify(searchPath(data, "encseed"));
    if (!encseed || (encseed.length % 16) !== 0) {
        logger$m.throwArgumentError("invalid encseed", "json", json);
    }
    const key = arrayify(pbkdf2$1(password, password, 2000, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    // Decrypt the seed
    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);
    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
    // This wallet format is weird... Convert the binary encoded hex to a string.
    let seedHex = "";
    for (let i = 0; i < seed.length; i++) {
        seedHex += String.fromCharCode(seed[i]);
    }
    const seedHexBytes = toUtf8Bytes(seedHex);
    const privateKey = keccak256$1(seedHexBytes);
    return new CrowdsaleAccount({
        _isCrowdsaleAccount: true,
        address: ethaddr,
        privateKey: privateKey
    });
}

function isCrowdsaleWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    }
    catch (error) {
        return false;
    }
    return (data.encseed && data.ethaddr);
}
function isKeystoreWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    }
    catch (error) {
        return false;
    }
    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
        return false;
    }
    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff
    return true;
}
//export function isJsonWallet(json: string): boolean {
//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));
//}
function getJsonWalletAddress(json) {
    if (isCrowdsaleWallet(json)) {
        try {
            return getAddress(JSON.parse(json).ethaddr);
        }
        catch (error) {
            return null;
        }
    }
    if (isKeystoreWallet(json)) {
        try {
            return getAddress(JSON.parse(json).address);
        }
        catch (error) {
            return null;
        }
    }
    return null;
}

var scrypt$1 = {exports: {}};

(function (module, exports) {

	(function(root) {
	    const MAX_VALUE = 0x7fffffff;

	    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
	    // See: https://github.com/dchest/scrypt-async-js
	    function SHA256(m) {
	        const K = new Uint32Array([
	           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
	           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
	           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
	           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
	           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
	           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
	           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
	           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
	           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
	           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	       ]);

	        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
	        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
	        const w = new Uint32Array(64);

	        function blocks(p) {
	            let off = 0, len = p.length;
	            while (len >= 64) {
	                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;

	                for (i = 0; i < 16; i++) {
	                    j = off + i*4;
	                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |
	                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);
	                }

	                for (i = 16; i < 64; i++) {
	                    u = w[i-2];
	                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);

	                    u = w[i-15];
	                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);

	                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;
	                }

	                for (i = 0; i < 64; i++) {
	                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^
	                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +
	                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;

	                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^
	                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;

	                    h = g;
	                    g = f;
	                    f = e;
	                    e = (d + t1) | 0;
	                    d = c;
	                    c = b;
	                    b = a;
	                    a = (t1 + t2) | 0;
	                }

	                h0 = (h0 + a) | 0;
	                h1 = (h1 + b) | 0;
	                h2 = (h2 + c) | 0;
	                h3 = (h3 + d) | 0;
	                h4 = (h4 + e) | 0;
	                h5 = (h5 + f) | 0;
	                h6 = (h6 + g) | 0;
	                h7 = (h7 + h) | 0;

	                off += 64;
	                len -= 64;
	            }
	        }

	        blocks(m);

	        let i, bytesLeft = m.length % 64,
	        bitLenHi = (m.length / 0x20000000) | 0,
	        bitLenLo = m.length << 3,
	        numZeros = (bytesLeft < 56) ? 56 : 120,
	        p = m.slice(m.length - bytesLeft, m.length);

	        p.push(0x80);
	        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }
	        p.push((bitLenHi >>> 24) & 0xff);
	        p.push((bitLenHi >>> 16) & 0xff);
	        p.push((bitLenHi >>> 8)  & 0xff);
	        p.push((bitLenHi >>> 0)  & 0xff);
	        p.push((bitLenLo >>> 24) & 0xff);
	        p.push((bitLenLo >>> 16) & 0xff);
	        p.push((bitLenLo >>> 8)  & 0xff);
	        p.push((bitLenLo >>> 0)  & 0xff);

	        blocks(p);

	        return [
	            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,
	            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,
	            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,
	            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,
	            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,
	            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,
	            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,
	            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff
	        ];
	    }

	    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
	        // compress password if it's longer than hash block length
	        password = (password.length <= 64) ? password : SHA256(password);

	        const innerLen = 64 + salt.length + 4;
	        const inner = new Array(innerLen);
	        const outerKey = new Array(64);

	        let i;
	        let dk = [];

	        // inner = (password ^ ipad) || salt || counter
	        for (i = 0; i < 64; i++) { inner[i] = 0x36; }
	        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }
	        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }
	        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }

	        // outerKey = password ^ opad
	        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
	        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

	        // increments counter inside inner
	        function incrementCounter() {
	            for (let i = innerLen - 1; i >= innerLen - 4; i--) {
	                inner[i]++;
	                if (inner[i] <= 0xff) return;
	                inner[i] = 0;
	            }
	        }

	        // output blocks = SHA256(outerKey || SHA256(inner)) ...
	        while (dkLen >= 32) {
	            incrementCounter();
	            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
	            dkLen -= 32;
	        }
	        if (dkLen > 0) {
	            incrementCounter();
	            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
	        }

	        return dk;
	    }

	    // The following is an adaptation of scryptsy
	    // See: https://www.npmjs.com/package/scryptsy
	    function blockmix_salsa8(BY, Yi, r, x, _X) {
	        let i;

	        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
	        for (i = 0; i < 2 * r; i++) {
	            blockxor(BY, i * 16, _X, 16);
	            salsa20_8(_X, x);
	            arraycopy(_X, 0, BY, Yi + (i * 16), 16);
	        }

	        for (i = 0; i < r; i++) {
	            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);
	        }

	        for (i = 0; i < r; i++) {
	            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
	        }
	    }

	    function R(a, b) {
	        return (a << b) | (a >>> (32 - b));
	    }

	    function salsa20_8(B, x) {
	        arraycopy(B, 0, x, 0, 16);

	        for (let i = 8; i > 0; i -= 2) {
	            x[ 4] ^= R(x[ 0] + x[12], 7);
	            x[ 8] ^= R(x[ 4] + x[ 0], 9);
	            x[12] ^= R(x[ 8] + x[ 4], 13);
	            x[ 0] ^= R(x[12] + x[ 8], 18);
	            x[ 9] ^= R(x[ 5] + x[ 1], 7);
	            x[13] ^= R(x[ 9] + x[ 5], 9);
	            x[ 1] ^= R(x[13] + x[ 9], 13);
	            x[ 5] ^= R(x[ 1] + x[13], 18);
	            x[14] ^= R(x[10] + x[ 6], 7);
	            x[ 2] ^= R(x[14] + x[10], 9);
	            x[ 6] ^= R(x[ 2] + x[14], 13);
	            x[10] ^= R(x[ 6] + x[ 2], 18);
	            x[ 3] ^= R(x[15] + x[11], 7);
	            x[ 7] ^= R(x[ 3] + x[15], 9);
	            x[11] ^= R(x[ 7] + x[ 3], 13);
	            x[15] ^= R(x[11] + x[ 7], 18);
	            x[ 1] ^= R(x[ 0] + x[ 3], 7);
	            x[ 2] ^= R(x[ 1] + x[ 0], 9);
	            x[ 3] ^= R(x[ 2] + x[ 1], 13);
	            x[ 0] ^= R(x[ 3] + x[ 2], 18);
	            x[ 6] ^= R(x[ 5] + x[ 4], 7);
	            x[ 7] ^= R(x[ 6] + x[ 5], 9);
	            x[ 4] ^= R(x[ 7] + x[ 6], 13);
	            x[ 5] ^= R(x[ 4] + x[ 7], 18);
	            x[11] ^= R(x[10] + x[ 9], 7);
	            x[ 8] ^= R(x[11] + x[10], 9);
	            x[ 9] ^= R(x[ 8] + x[11], 13);
	            x[10] ^= R(x[ 9] + x[ 8], 18);
	            x[12] ^= R(x[15] + x[14], 7);
	            x[13] ^= R(x[12] + x[15], 9);
	            x[14] ^= R(x[13] + x[12], 13);
	            x[15] ^= R(x[14] + x[13], 18);
	        }

	        for (let i = 0; i < 16; ++i) {
	            B[i] += x[i];
	        }
	    }

	    // naive approach... going back to loop unrolling may yield additional performance
	    function blockxor(S, Si, D, len) {
	        for (let i = 0; i < len; i++) {
	            D[i] ^= S[Si + i];
	        }
	    }

	    function arraycopy(src, srcPos, dest, destPos, length) {
	        while (length--) {
	            dest[destPos++] = src[srcPos++];
	        }
	    }

	    function checkBufferish(o) {
	        if (!o || typeof(o.length) !== 'number') { return false; }

	        for (let i = 0; i < o.length; i++) {
	            const v = o[i];
	            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {
	                return false;
	            }
	        }

	        return true;
	    }

	    function ensureInteger(value, name) {
	        if (typeof(value) !== "number" || (value % 1)) { throw new Error('invalid ' + name); }
	        return value;
	    }

	    // N = Cpu cost, r = Memory cost, p = parallelization cost
	    // callback(error, progress, key)
	    function _scrypt(password, salt, N, r, p, dkLen, callback) {

	        N = ensureInteger(N, 'N');
	        r = ensureInteger(r, 'r');
	        p = ensureInteger(p, 'p');

	        dkLen = ensureInteger(dkLen, 'dkLen');

	        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }

	        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }
	        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }

	        if (!checkBufferish(password)) {
	            throw new Error('password must be an array or buffer');
	        }
	        password = Array.prototype.slice.call(password);

	        if (!checkBufferish(salt)) {
	            throw new Error('salt must be an array or buffer');
	        }
	        salt = Array.prototype.slice.call(salt);

	        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
	        const B = new Uint32Array(p * 32 * r);
	        for (let i = 0; i < B.length; i++) {
	            const j = i * 4;
	            B[i] = ((b[j + 3] & 0xff) << 24) |
	                   ((b[j + 2] & 0xff) << 16) |
	                   ((b[j + 1] & 0xff) << 8) |
	                   ((b[j + 0] & 0xff) << 0);
	        }

	        const XY = new Uint32Array(64 * r);
	        const V = new Uint32Array(32 * r * N);

	        const Yi = 32 * r;

	        // scratch space
	        const x = new Uint32Array(16);       // salsa20_8
	        const _X = new Uint32Array(16);      // blockmix_salsa8

	        const totalOps = p * N * 2;
	        let currentOp = 0;
	        let lastPercent10 = null;

	        // Set this to true to abandon the scrypt on the next step
	        let stop = false;

	        // State information
	        let state = 0;
	        let i0 = 0, i1;
	        let Bi;

	        // How many blockmix_salsa8 can we do per step?
	        const limit = callback ? parseInt(1000 / r): 0xffffffff;

	        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
	        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;

	        // This is really all I changed; making scryptsy a state machine so we occasionally
	        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
	        const incrementalSMix = function() {
	            if (stop) {
	                return callback(new Error('cancelled'), currentOp / totalOps);
	            }

	            let steps;

	            switch (state) {
	                case 0:
	                    // for (var i = 0; i < p; i++)...
	                    Bi = i0 * 32 * r;

	                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1

	                    state = 1;                                         // Move to ROMix 2
	                    i1 = 0;

	                    // Fall through

	                case 1:

	                    // Run up to 1000 steps of the first inner smix loop
	                    steps = N - i1;
	                    if (steps > limit) { steps = limit; }
	                    for (let i = 0; i < steps; i++) {                  // ROMix - 2
	                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);         // ROMix - 3
	                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4
	                    }

	                    // for (var i = 0; i < N; i++)
	                    i1 += steps;
	                    currentOp += steps;

	                    if (callback) {
	                        // Call the callback with the progress (optionally stopping us)
	                        const percent10 = parseInt(1000 * currentOp / totalOps);
	                        if (percent10 !== lastPercent10) {
	                            stop = callback(null, currentOp / totalOps);
	                            if (stop) { break; }
	                            lastPercent10 = percent10;
	                        }
	                    }

	                    if (i1 < N) { break; }

	                    i1 = 0;                                          // Move to ROMix 6
	                    state = 2;

	                    // Fall through

	                case 2:

	                    // Run up to 1000 steps of the second inner smix loop
	                    steps = N - i1;
	                    if (steps > limit) { steps = limit; }
	                    for (let i = 0; i < steps; i++) {                // ROMix - 6
	                        const offset = (2 * r - 1) * 16;             // ROMix - 7
	                        const j = XY[offset] & (N - 1);
	                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)
	                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)
	                    }

	                    // for (var i = 0; i < N; i++)...
	                    i1 += steps;
	                    currentOp += steps;

	                    // Call the callback with the progress (optionally stopping us)
	                    if (callback) {
	                        const percent10 = parseInt(1000 * currentOp / totalOps);
	                        if (percent10 !== lastPercent10) {
	                            stop = callback(null, currentOp / totalOps);
	                            if (stop) { break; }
	                            lastPercent10 = percent10;
	                        }
	                    }

	                    if (i1 < N) { break; }

	                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10

	                    // for (var i = 0; i < p; i++)...
	                    i0++;
	                    if (i0 < p) {
	                        state = 0;
	                        break;
	                    }

	                    b = [];
	                    for (let i = 0; i < B.length; i++) {
	                        b.push((B[i] >>  0) & 0xff);
	                        b.push((B[i] >>  8) & 0xff);
	                        b.push((B[i] >> 16) & 0xff);
	                        b.push((B[i] >> 24) & 0xff);
	                    }

	                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

	                    // Send the result to the callback
	                    if (callback) { callback(null, 1.0, derivedKey); }

	                    // Done; don't break (which would reschedule)
	                    return derivedKey;
	            }

	            // Schedule the next steps
	            if (callback) { nextTick(incrementalSMix); }
	        };

	        // Run the smix state machine until completion
	        if (!callback) {
	            while (true) {
	                const derivedKey = incrementalSMix();
	                if (derivedKey != undefined) { return derivedKey; }
	            }
	        }

	        // Bootstrap the async incremental smix
	        incrementalSMix();
	    }

	    const lib = {
	        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
	            return new Promise(function(resolve, reject) {
	                let lastProgress = 0;
	                if (progressCallback) { progressCallback(0); }
	                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
	                    if (error) {
	                        reject(error);
	                    } else if (key) {
	                        if (progressCallback && lastProgress !== 1) {
	                            progressCallback(1);
	                        }
	                        resolve(new Uint8Array(key));
	                    } else if (progressCallback && progress !== lastProgress) {
	                        lastProgress = progress;
	                        return progressCallback(progress);
	                    }
	                });
	            });
	        },
	        syncScrypt: function(password, salt, N, r, p, dkLen) {
	            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
	        }
	    };

	    // node.js
	    {
	       module.exports = lib;

	    // RequireJS/AMD
	    // http://www.requirejs.org/docs/api.html
	    // https://github.com/amdjs/amdjs-api/wiki/AMD
	    }

	})();
} (scrypt$1));

var scrypt = scrypt$1.exports;

var __awaiter$a = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$l = new Logger(version$7);
// Exported Types
function hasMnemonic$1(value) {
    return (value != null && value.mnemonic && value.mnemonic.phrase);
}
class KeystoreAccount extends Description {
    isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
    }
}
function _decrypt(data, key, ciphertext) {
    const cipher = searchPath(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
        const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
        const counter = new aes.Counter(iv);
        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);
        return arrayify(aesCtr.decrypt(ciphertext));
    }
    return null;
}
function _getAccount(data, key) {
    const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
    const computedMAC = hexlify(keccak256$1(concat([key.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
    }
    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
    if (!privateKey) {
        logger$l.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "decrypt"
        });
    }
    const mnemonicKey = key.slice(32, 64);
    const address = computeAddress(privateKey);
    if (data.address) {
        let check = data.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") {
            check = "0x" + check;
        }
        if (getAddress(check) !== address) {
            throw new Error("address mismatch");
        }
    }
    const account = {
        _isKeystoreAccount: true,
        address: address,
        privateKey: hexlify(privateKey)
    };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    if (searchPath(data, "x-ethers/version") === "0.1") {
        const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
        const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
        const mnemonicCounter = new aes.Counter(mnemonicIv);
        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const path = searchPath(data, "x-ethers/path") || defaultPath;
        const locale = searchPath(data, "x-ethers/locale") || "en";
        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
            const mnemonic = entropyToMnemonic(entropy, locale);
            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
            account.mnemonic = node.mnemonic;
        }
        catch (error) {
            // If we don't have the locale wordlist installed to
            // read this mnemonic, just bail and don't set the
            // mnemonic
            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
                throw error;
            }
        }
    }
    return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return arrayify(pbkdf2$1(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = getPassword(password);
    const kdf = searchPath(data, "crypto/kdf");
    if (kdf && typeof (kdf) === "string") {
        const throwError = function (name, value) {
            return logger$l.throwArgumentError("invalid key-derivation function parameters", name, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
            const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
            const N = parseInt(searchPath(data, "crypto/kdfparams/n"));
            const r = parseInt(searchPath(data, "crypto/kdfparams/r"));
            const p = parseInt(searchPath(data, "crypto/kdfparams/p"));
            // Check for all required parameters
            if (!N || !r || !p) {
                throwError("kdf", kdf);
            }
            // Make sure N is a power of 2
            if ((N & (N - 1)) !== 0) {
                throwError("N", N);
            }
            const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        }
        else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
            let prfFunc = null;
            const prf = searchPath(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") {
                prfFunc = "sha256";
            }
            else if (prf === "hmac-sha512") {
                prfFunc = "sha512";
            }
            else {
                throwError("prf", prf);
            }
            const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
            const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
    }
    return logger$l.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
    const data = JSON.parse(json);
    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);
    return _getAccount(data, key);
}
function decrypt(json, password, progressCallback) {
    return __awaiter$a(this, void 0, void 0, function* () {
        const data = JSON.parse(json);
        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);
        return _getAccount(data, key);
    });
}
function encrypt(account, password, options, progressCallback) {
    try {
        // Check the address matches the private key
        if (getAddress(account.address) !== computeAddress(account.privateKey)) {
            throw new Error("address/privateKey mismatch");
        }
        // Check the mnemonic (if any) matches the private key
        if (hasMnemonic$1(account)) {
            const mnemonic = account.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
        }
    }
    catch (e) {
        return Promise.reject(e);
    }
    // The options are optional, so adjust the call as needed
    if (typeof (options) === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    const privateKey = arrayify(account.privateKey);
    const passwordBytes = getPassword(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic$1(account)) {
        const srcMnemonic = account.mnemonic;
        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path = srcMnemonic.path || defaultPath;
        locale = srcMnemonic.locale || "en";
    }
    let client = options.client;
    if (!client) {
        client = "ethers.js";
    }
    // Check/generate the salt
    let salt = null;
    if (options.salt) {
        salt = arrayify(options.salt);
    }
    else {
        salt = randomBytes(32);
    }
    // Override initialization vector
    let iv = null;
    if (options.iv) {
        iv = arrayify(options.iv);
        if (iv.length !== 16) {
            throw new Error("invalid iv");
        }
    }
    else {
        iv = randomBytes(16);
    }
    // Override the uuid
    let uuidRandom = null;
    if (options.uuid) {
        uuidRandom = arrayify(options.uuid);
        if (uuidRandom.length !== 16) {
            throw new Error("invalid uuid");
        }
    }
    else {
        uuidRandom = randomBytes(16);
    }
    // Override the scrypt password-based key derivation function parameters
    let N = (1 << 17), r = 8, p = 1;
    if (options.scrypt) {
        if (options.scrypt.N) {
            N = options.scrypt.N;
        }
        if (options.scrypt.r) {
            r = options.scrypt.r;
        }
        if (options.scrypt.p) {
            p = options.scrypt.p;
        }
    }
    // We take 64 bytes:
    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
        key = arrayify(key);
        // This will be used to encrypt the wallet (as per Web3 secret storage)
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        // This will be used to encrypt the mnemonic phrase (if any)
        const mnemonicKey = key.slice(32, 64);
        // Encrypt the private key
        const counter = new aes.Counter(iv);
        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
        const ciphertext = arrayify(aesCtr.encrypt(privateKey));
        // Compute the message authentication code, used to check the password
        const mac = keccak256$1(concat([macPrefix, ciphertext]));
        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
        const data = {
            address: account.address.substring(2).toLowerCase(),
            id: uuidV4(uuidRandom),
            version: 3,
            Crypto: {
                cipher: "aes-128-ctr",
                cipherparams: {
                    iv: hexlify(iv).substring(2),
                },
                ciphertext: hexlify(ciphertext).substring(2),
                kdf: "scrypt",
                kdfparams: {
                    salt: hexlify(salt).substring(2),
                    n: N,
                    dklen: 32,
                    p: p,
                    r: r
                },
                mac: mac.substring(2)
            }
        };
        // If we have a mnemonic, encrypt it into the JSON wallet
        if (entropy) {
            const mnemonicIv = randomBytes(16);
            const mnemonicCounter = new aes.Counter(mnemonicIv);
            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
            const now = new Date();
            const timestamp = (now.getUTCFullYear() + "-" +
                zpad(now.getUTCMonth() + 1, 2) + "-" +
                zpad(now.getUTCDate(), 2) + "T" +
                zpad(now.getUTCHours(), 2) + "-" +
                zpad(now.getUTCMinutes(), 2) + "-" +
                zpad(now.getUTCSeconds(), 2) + ".0Z");
            data["x-ethers"] = {
                client: client,
                gethFilename: ("UTC--" + timestamp + "--" + data.address),
                mnemonicCounter: hexlify(mnemonicIv).substring(2),
                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
                path: path,
                locale: locale,
                version: "0.1"
            };
        }
        return JSON.stringify(data);
    });
}

function decryptJsonWallet(json, password, progressCallback) {
    if (isCrowdsaleWallet(json)) {
        if (progressCallback) {
            progressCallback(0);
        }
        const account = decrypt$1(json, password);
        if (progressCallback) {
            progressCallback(1);
        }
        return Promise.resolve(account);
    }
    if (isKeystoreWallet(json)) {
        return decrypt(json, password, progressCallback);
    }
    return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
    if (isCrowdsaleWallet(json)) {
        return decrypt$1(json, password);
    }
    if (isKeystoreWallet(json)) {
        return decryptSync(json, password);
    }
    throw new Error("invalid JSON wallet");
}

const version$6 = "wallet/5.6.2";

var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$k = new Logger(version$6);
function isAccount(value) {
    return (value != null && isHexString(value.privateKey, 32) && value.address != null);
}
function hasMnemonic(value) {
    const mnemonic = value.mnemonic;
    return (mnemonic && mnemonic.phrase);
}
class Wallet extends Signer {
    constructor(privateKey, provider) {
        super();
        if (isAccount(privateKey)) {
            const signingKey = new SigningKey(privateKey.privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
            defineReadOnly(this, "address", computeAddress(this.publicKey));
            if (this.address !== getAddress(privateKey.address)) {
                logger$k.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
            }
            if (hasMnemonic(privateKey)) {
                const srcMnemonic = privateKey.mnemonic;
                defineReadOnly(this, "_mnemonic", () => ({
                    phrase: srcMnemonic.phrase,
                    path: srcMnemonic.path || defaultPath,
                    locale: srcMnemonic.locale || "en"
                }));
                const mnemonic = this.mnemonic;
                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
                if (computeAddress(node.privateKey) !== this.address) {
                    logger$k.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
                }
            }
            else {
                defineReadOnly(this, "_mnemonic", () => null);
            }
        }
        else {
            if (SigningKey.isSigningKey(privateKey)) {
                /* istanbul ignore if */
                if (privateKey.curve !== "secp256k1") {
                    logger$k.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
                }
                defineReadOnly(this, "_signingKey", () => privateKey);
            }
            else {
                // A lot of common tools do not prefix private keys with a 0x (see: #1166)
                if (typeof (privateKey) === "string") {
                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                        privateKey = "0x" + privateKey;
                    }
                }
                const signingKey = new SigningKey(privateKey);
                defineReadOnly(this, "_signingKey", () => signingKey);
            }
            defineReadOnly(this, "_mnemonic", () => null);
            defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        /* istanbul ignore if */
        if (provider && !Provider.isProvider(provider)) {
            logger$k.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
    }
    get mnemonic() { return this._mnemonic(); }
    get privateKey() { return this._signingKey().privateKey; }
    get publicKey() { return this._signingKey().publicKey; }
    getAddress() {
        return Promise.resolve(this.address);
    }
    connect(provider) {
        return new Wallet(this, provider);
    }
    signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
            if (tx.from != null) {
                if (getAddress(tx.from) !== this.address) {
                    logger$k.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
                }
                delete tx.from;
            }
            const signature = this._signingKey().signDigest(keccak256$1(serialize$1(tx)));
            return serialize$1(tx, signature);
        });
    }
    signMessage(message) {
        return __awaiter$9(this, void 0, void 0, function* () {
            return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter$9(this, void 0, void 0, function* () {
            // Populate any ENS names
            const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
                if (this.provider == null) {
                    logger$k.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "resolveName",
                        value: name
                    });
                }
                return this.provider.resolveName(name);
            });
            return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
    }
    encrypt(password, options, progressCallback) {
        if (typeof (options) === "function" && !progressCallback) {
            progressCallback = options;
            options = {};
        }
        if (progressCallback && typeof (progressCallback) !== "function") {
            throw new Error("invalid callback");
        }
        if (!options) {
            options = {};
        }
        return encrypt(this, password, options, progressCallback);
    }
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
            options = {};
        }
        if (options.extraEntropy) {
            entropy = arrayify(hexDataSlice(keccak256$1(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
            return new Wallet(account);
        });
    }
    static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
            path = defaultPath;
        }
        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    }
}
function verifyMessage(message, signature) {
    return recoverAddress(hashMessage(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}

const version$5 = "networks/5.6.3";

const logger$j = new Logger(version$5);
function isRenetworkable(value) {
    return (value && typeof (value.renetwork) === "function");
}
function ethDefaultProvider(network) {
    const func = function (providers, options) {
        if (options == null) {
            options = {};
        }
        const providerList = [];
        if (providers.InfuraProvider && options.infura !== "-") {
            try {
                providerList.push(new providers.InfuraProvider(network, options.infura));
            }
            catch (error) { }
        }
        if (providers.EtherscanProvider && options.etherscan !== "-") {
            try {
                providerList.push(new providers.EtherscanProvider(network, options.etherscan));
            }
            catch (error) { }
        }
        if (providers.AlchemyProvider && options.alchemy !== "-") {
            try {
                providerList.push(new providers.AlchemyProvider(network, options.alchemy));
            }
            catch (error) { }
        }
        if (providers.PocketProvider && options.pocket !== "-") {
            // These networks are currently faulty on Pocket as their
            // network does not handle the Berlin hardfork, which is
            // live on these ones.
            // @TODO: This goes away once Pocket has upgraded their nodes
            const skip = ["goerli", "ropsten", "rinkeby"];
            try {
                const provider = new providers.PocketProvider(network, options.pocket);
                if (provider.network && skip.indexOf(provider.network.name) === -1) {
                    providerList.push(provider);
                }
            }
            catch (error) { }
        }
        if (providers.CloudflareProvider && options.cloudflare !== "-") {
            try {
                providerList.push(new providers.CloudflareProvider(network));
            }
            catch (error) { }
        }
        if (providers.AnkrProvider && options.ankr !== "-") {
            try {
                providerList.push(new providers.AnkrProvider(network, options.ankr));
            }
            catch (error) { }
        }
        if (providerList.length === 0) {
            return null;
        }
        if (providers.FallbackProvider) {
            let quorum = 1;
            if (options.quorum != null) {
                quorum = options.quorum;
            }
            else if (network === "homestead") {
                quorum = 2;
            }
            return new providers.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
    };
    func.renetwork = function (network) {
        return ethDefaultProvider(network);
    };
    return func;
}
function etcDefaultProvider(url, network) {
    const func = function (providers, options) {
        if (providers.JsonRpcProvider) {
            return new providers.JsonRpcProvider(url, network);
        }
        return null;
    };
    func.renetwork = function (network) {
        return etcDefaultProvider(url, network);
    };
    return func;
}
const homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
// See: https://chainlist.org
const networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead: homestead,
    mainnet: homestead,
    morden: { chainId: 2, name: "morden" },
    ropsten: ropsten,
    testnet: ropsten,
    rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
    },
    kintsugi: { chainId: 1337702, name: "kintsugi" },
    // ETC (See: #351)
    classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor: classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
    },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
    },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" },
};
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */
function getNetwork(network) {
    // No network (null)
    if (network == null) {
        return null;
    }
    if (typeof (network) === "number") {
        for (const name in networks) {
            const standard = networks[name];
            if (standard.chainId === network) {
                return {
                    name: standard.name,
                    chainId: standard.chainId,
                    ensAddress: (standard.ensAddress || null),
                    _defaultProvider: (standard._defaultProvider || null)
                };
            }
        }
        return {
            chainId: network,
            name: "unknown"
        };
    }
    if (typeof (network) === "string") {
        const standard = networks[network];
        if (standard == null) {
            return null;
        }
        return {
            name: standard.name,
            chainId: standard.chainId,
            ensAddress: standard.ensAddress,
            _defaultProvider: (standard._defaultProvider || null)
        };
    }
    const standard = networks[network.name];
    // Not a standard network; check that it is a valid network in general
    if (!standard) {
        if (typeof (network.chainId) !== "number") {
            logger$j.throwArgumentError("invalid network chainId", "network", network);
        }
        return network;
    }
    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
        logger$j.throwArgumentError("network chainId mismatch", "network", network);
    }
    // @TODO: In the next major version add an attach function to a defaultProvider
    // class and move the _defaultProvider internal to this file (extend Network)
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) {
            defaultProvider = standard._defaultProvider.renetwork(network);
        }
        else {
            defaultProvider = standard._defaultProvider;
        }
    }
    // Standard Network (allow overriding the ENS address)
    return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: (network.ensAddress || standard.ensAddress || null),
        _defaultProvider: defaultProvider
    };
}

function decode$1(textData) {
    textData = atob(textData);
    const data = [];
    for (let i = 0; i < textData.length; i++) {
        data.push(textData.charCodeAt(i));
    }
    return arrayify(data);
}
function encode$1(data) {
    data = arrayify(data);
    let textData = "";
    for (let i = 0; i < data.length; i++) {
        textData += String.fromCharCode(data[i]);
    }
    return btoa(textData);
}

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    decode: decode$1,
    encode: encode$1
});

const version$4 = "web/5.6.1";

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getUrl(href, options) {
    return __awaiter$8(this, void 0, void 0, function* () {
        if (options == null) {
            options = {};
        }
        const request = {
            method: (options.method || "GET"),
            headers: (options.headers || {}),
            body: (options.body || undefined),
        };
        if (options.skipFetchSetup !== true) {
            request.mode = "cors"; // no-cors, cors, *same-origin
            request.cache = "no-cache"; // *default, no-cache, reload, force-cache, only-if-cached
            request.credentials = "same-origin"; // include, *same-origin, omit
            request.redirect = "follow"; // manual, *follow, error
            request.referrer = "client"; // no-referrer, *client
        }
        const response = yield fetch(href, request);
        const body = yield response.arrayBuffer();
        const headers = {};
        if (response.headers.forEach) {
            response.headers.forEach((value, key) => {
                headers[key.toLowerCase()] = value;
            });
        }
        else {
            ((response.headers).keys)().forEach((key) => {
                headers[key.toLowerCase()] = response.headers.get(key);
            });
        }
        return {
            headers: headers,
            statusCode: response.status,
            statusMessage: response.statusText,
            body: arrayify(new Uint8Array(body)),
        };
    });
}

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$i = new Logger(version$4);
function staller(duration) {
    return new Promise((resolve) => {
        setTimeout(resolve, duration);
    });
}
function bodyify(value, type) {
    if (value == null) {
        return null;
    }
    if (typeof (value) === "string") {
        return value;
    }
    if (isBytesLike(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
            try {
                return toUtf8String(value);
            }
            catch (error) { }
        }
        return hexlify(value);
    }
    return value;
}
// This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized
function _fetchData(connection, body, processFunc) {
    // How many times to retry in the event of a throttle
    const attemptLimit = (typeof (connection) === "object" && connection.throttleLimit != null) ? connection.throttleLimit : 12;
    logger$i.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    const throttleCallback = ((typeof (connection) === "object") ? connection.throttleCallback : null);
    const throttleSlotInterval = ((typeof (connection) === "object" && typeof (connection.throttleSlotInterval) === "number") ? connection.throttleSlotInterval : 100);
    logger$i.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    const errorPassThrough = ((typeof (connection) === "object") ? !!(connection.errorPassThrough) : false);
    const headers = {};
    let url = null;
    // @TODO: Allow ConnectionInfo to override some of these values
    const options = {
        method: "GET",
    };
    let allow304 = false;
    let timeout = 2 * 60 * 1000;
    if (typeof (connection) === "string") {
        url = connection;
    }
    else if (typeof (connection) === "object") {
        if (connection == null || connection.url == null) {
            logger$i.throwArgumentError("missing URL", "connection.url", connection);
        }
        url = connection.url;
        if (typeof (connection.timeout) === "number" && connection.timeout > 0) {
            timeout = connection.timeout;
        }
        if (connection.headers) {
            for (const key in connection.headers) {
                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };
                if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
                    allow304 = true;
                }
            }
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
                logger$i.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url: url, user: connection.user, password: "[REDACTED]" });
            }
            const authorization = connection.user + ":" + connection.password;
            headers["authorization"] = {
                key: "Authorization",
                value: "Basic " + encode$1(toUtf8Bytes(authorization))
            };
        }
        if (connection.skipFetchSetup != null) {
            options.skipFetchSetup = !!connection.skipFetchSetup;
        }
    }
    const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
    const dataMatch = ((url) ? url.match(reData) : null);
    if (dataMatch) {
        try {
            const response = {
                statusCode: 200,
                statusMessage: "OK",
                headers: { "content-type": dataMatch[1] },
                body: decode$1(dataMatch[2])
            };
            let result = response.body;
            if (processFunc) {
                result = processFunc(response.body, response);
            }
            return Promise.resolve(result);
        }
        catch (error) {
            logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                body: bodyify(dataMatch[1], dataMatch[2]),
                error: error,
                requestBody: null,
                requestMethod: "GET",
                url: url
            });
        }
    }
    if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) {
            headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
        }
        if (headers["content-length"] == null) {
            headers["content-length"] = { key: "Content-Length", value: String(body.length) };
        }
    }
    const flatHeaders = {};
    Object.keys(headers).forEach((key) => {
        const header = headers[key];
        flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    const runningTimeout = (function () {
        let timer = null;
        const promise = new Promise(function (resolve, reject) {
            if (timeout) {
                timer = setTimeout(() => {
                    if (timer == null) {
                        return;
                    }
                    timer = null;
                    reject(logger$i.makeError("timeout", Logger.errors.TIMEOUT, {
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        timeout: timeout,
                        url: url
                    }));
                }, timeout);
            }
        });
        const cancel = function () {
            if (timer == null) {
                return;
            }
            clearTimeout(timer);
            timer = null;
        };
        return { promise, cancel };
    })();
    const runningFetch = (function () {
        return __awaiter$7(this, void 0, void 0, function* () {
            for (let attempt = 0; attempt < attemptLimit; attempt++) {
                let response = null;
                try {
                    response = yield getUrl(url, options);
                    if (attempt < attemptLimit) {
                        if (response.statusCode === 301 || response.statusCode === 302) {
                            // Redirection; for now we only support absolute locataions
                            const location = response.headers.location || "";
                            if (options.method === "GET" && location.match(/^https:/)) {
                                url = response.headers.location;
                                continue;
                            }
                        }
                        else if (response.statusCode === 429) {
                            // Exponential back-off throttling
                            let tryAgain = true;
                            if (throttleCallback) {
                                tryAgain = yield throttleCallback(attempt, url);
                            }
                            if (tryAgain) {
                                let stall = 0;
                                const retryAfter = response.headers["retry-after"];
                                if (typeof (retryAfter) === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                                    stall = parseInt(retryAfter) * 1000;
                                }
                                else {
                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                                }
                                //console.log("Stalling 429");
                                yield staller(stall);
                                continue;
                            }
                        }
                    }
                }
                catch (error) {
                    response = error.response;
                    if (response == null) {
                        runningTimeout.cancel();
                        logger$i.throwError("missing response", Logger.errors.SERVER_ERROR, {
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            serverError: error,
                            url: url
                        });
                    }
                }
                let body = response.body;
                if (allow304 && response.statusCode === 304) {
                    body = null;
                }
                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
                    runningTimeout.cancel();
                    logger$i.throwError("bad response", Logger.errors.SERVER_ERROR, {
                        status: response.statusCode,
                        headers: response.headers,
                        body: bodyify(body, ((response.headers) ? response.headers["content-type"] : null)),
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        url: url
                    });
                }
                if (processFunc) {
                    try {
                        const result = yield processFunc(body, response);
                        runningTimeout.cancel();
                        return result;
                    }
                    catch (error) {
                        // Allow the processFunc to trigger a throttle
                        if (error.throttleRetry && attempt < attemptLimit) {
                            let tryAgain = true;
                            if (throttleCallback) {
                                tryAgain = yield throttleCallback(attempt, url);
                            }
                            if (tryAgain) {
                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                                //console.log("Stalling callback");
                                yield staller(timeout);
                                continue;
                            }
                        }
                        runningTimeout.cancel();
                        logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                            body: bodyify(body, ((response.headers) ? response.headers["content-type"] : null)),
                            error: error,
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            url: url
                        });
                    }
                }
                runningTimeout.cancel();
                // If we had a processFunc, it either returned a T or threw above.
                // The "body" is now a Uint8Array.
                return body;
            }
            return logger$i.throwError("failed response", Logger.errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url: url
            });
        });
    })();
    return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
    let processJsonFunc = (value, response) => {
        let result = null;
        if (value != null) {
            try {
                result = JSON.parse(toUtf8String(value));
            }
            catch (error) {
                logger$i.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
                    body: value,
                    error: error
                });
            }
        }
        if (processFunc) {
            result = processFunc(result, response);
        }
        return result;
    };
    // If we have json to send, we must
    // - add content-type of application/json (unless already overridden)
    // - convert the json to bytes
    let body = null;
    if (json != null) {
        body = toUtf8Bytes(json);
        // Create a connection with the content-type set for JSON
        const updated = (typeof (connection) === "string") ? ({ url: connection }) : shallowCopy(connection);
        if (updated.headers) {
            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === "content-type")).length) !== 0;
            if (!hasContentType) {
                updated.headers = shallowCopy(updated.headers);
                updated.headers["content-type"] = "application/json";
            }
        }
        else {
            updated.headers = { "content-type": "application/json" };
        }
        connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
    if (!options) {
        options = {};
    }
    options = shallowCopy(options);
    if (options.floor == null) {
        options.floor = 0;
    }
    if (options.ceiling == null) {
        options.ceiling = 10000;
    }
    if (options.interval == null) {
        options.interval = 250;
    }
    return new Promise(function (resolve, reject) {
        let timer = null;
        let done = false;
        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.
        const cancel = () => {
            if (done) {
                return false;
            }
            done = true;
            if (timer) {
                clearTimeout(timer);
            }
            return true;
        };
        if (options.timeout) {
            timer = setTimeout(() => {
                if (cancel()) {
                    reject(new Error("timeout"));
                }
            }, options.timeout);
        }
        const retryLimit = options.retryLimit;
        let attempt = 0;
        function check() {
            return func().then(function (result) {
                // If we have a result, or are allowed null then we're done
                if (result !== undefined) {
                    if (cancel()) {
                        resolve(result);
                    }
                }
                else if (options.oncePoll) {
                    options.oncePoll.once("poll", check);
                }
                else if (options.onceBlock) {
                    options.onceBlock.once("block", check);
                    // Otherwise, exponential back-off (up to 10s) our next request
                }
                else if (!done) {
                    attempt++;
                    if (attempt > retryLimit) {
                        if (cancel()) {
                            reject(new Error("retry limit reached"));
                        }
                        return;
                    }
                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                    if (timeout < options.floor) {
                        timeout = options.floor;
                    }
                    if (timeout > options.ceiling) {
                        timeout = options.ceiling;
                    }
                    setTimeout(check, timeout);
                }
                return null;
            }, function (error) {
                if (cancel()) {
                    reject(error);
                }
            });
        }
        check();
    });
}

var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

// pre-compute lookup table
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);

  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
  ALPHABET_MAP[x] = z;
}

function polymodStep (pre) {
  var b = pre >> 25;
  return ((pre & 0x1FFFFFF) << 5) ^
    (-((b >> 0) & 1) & 0x3b6a57b2) ^
    (-((b >> 1) & 1) & 0x26508e6d) ^
    (-((b >> 2) & 1) & 0x1ea119fa) ^
    (-((b >> 3) & 1) & 0x3d4233dd) ^
    (-((b >> 4) & 1) & 0x2a1462b3)
}

function prefixChk (prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'

    chk = polymodStep(chk) ^ (c >> 5);
  }
  chk = polymodStep(chk);

  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ (v & 0x1f);
  }
  return chk
}

function encode (prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')

  prefix = prefix.toLowerCase();

  // determine chk mod
  var chk = prefixChk(prefix);
  if (typeof chk === 'string') throw new Error(chk)

  var result = prefix + '1';
  for (var i = 0; i < words.length; ++i) {
    var x = words[i];
    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')

    chk = polymodStep(chk) ^ x;
    result += ALPHABET.charAt(x);
  }

  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk);
  }
  chk ^= 1;

  for (i = 0; i < 6; ++i) {
    var v = (chk >> ((5 - i) * 5)) & 0x1f;
    result += ALPHABET.charAt(v);
  }

  return result
}

function __decode (str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8) return str + ' too short'
  if (str.length > LIMIT) return 'Exceeds length limit'

  // don't allow mixed case
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str
  str = lowered;

  var split = str.lastIndexOf('1');
  if (split === -1) return 'No separator character for ' + str
  if (split === 0) return 'Missing prefix for ' + str

  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6) return 'Data too short'

  var chk = prefixChk(prefix);
  if (typeof chk === 'string') return chk

  var words = [];
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i);
    var v = ALPHABET_MAP[c];
    if (v === undefined) return 'Unknown character ' + c
    chk = polymodStep(chk) ^ v;

    // not in the checksum?
    if (i + 6 >= wordChars.length) continue
    words.push(v);
  }

  if (chk !== 1) return 'Invalid checksum for ' + str
  return { prefix: prefix, words: words }
}

function decodeUnsafe () {
  var res = __decode.apply(null, arguments);
  if (typeof res === 'object') return res
}

function decode (str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === 'object') return res

  throw new Error(res)
}

function convert (data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;

  var result = [];
  for (var i = 0; i < data.length; ++i) {
    value = (value << inBits) | data[i];
    bits += inBits;

    while (bits >= outBits) {
      bits -= outBits;
      result.push((value >> bits) & maxV);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push((value << (outBits - bits)) & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding'
    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
  }

  return result
}

function toWordsUnsafe (bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res
}

function toWords (bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res

  throw new Error(res)
}

function fromWordsUnsafe (words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res
}

function fromWords (words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res

  throw new Error(res)
}

var bech32 = {
  decodeUnsafe: decodeUnsafe,
  decode: decode,
  encode: encode,
  toWordsUnsafe: toWordsUnsafe,
  toWords: toWords,
  fromWordsUnsafe: fromWordsUnsafe,
  fromWords: fromWords
};

const version$3 = "providers/5.6.8";

const logger$h = new Logger(version$3);
class Formatter {
    constructor() {
        this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
        const formats = ({});
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const blockTag = this.blockTag.bind(this);
        const data = this.data.bind(this);
        const hash = this.hash.bind(this);
        const hex = this.hex.bind(this);
        const number = this.number.bind(this);
        const type = this.type.bind(this);
        const strictData = (v) => { return this.data(v, true); };
        formats.transaction = {
            hash: hash,
            type: type,
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
            blockHash: Formatter.allowNull(hash, null),
            blockNumber: Formatter.allowNull(number, null),
            transactionIndex: Formatter.allowNull(number, null),
            confirmations: Formatter.allowNull(number, null),
            from: address,
            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
            // must be set
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            gasLimit: bigNumber,
            to: Formatter.allowNull(address, null),
            value: bigNumber,
            nonce: number,
            data: data,
            r: Formatter.allowNull(this.uint256),
            s: Formatter.allowNull(this.uint256),
            v: Formatter.allowNull(number),
            creates: Formatter.allowNull(address, null),
            raw: Formatter.allowNull(data),
        };
        formats.transactionRequest = {
            from: Formatter.allowNull(address),
            nonce: Formatter.allowNull(number),
            gasLimit: Formatter.allowNull(bigNumber),
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            to: Formatter.allowNull(address),
            value: Formatter.allowNull(bigNumber),
            data: Formatter.allowNull(strictData),
            type: Formatter.allowNull(number),
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
        };
        formats.receiptLog = {
            transactionIndex: number,
            blockNumber: number,
            transactionHash: hash,
            address: address,
            topics: Formatter.arrayOf(hash),
            data: data,
            logIndex: number,
            blockHash: hash,
        };
        formats.receipt = {
            to: Formatter.allowNull(this.address, null),
            from: Formatter.allowNull(this.address, null),
            contractAddress: Formatter.allowNull(address, null),
            transactionIndex: number,
            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
            root: Formatter.allowNull(hex),
            gasUsed: bigNumber,
            logsBloom: Formatter.allowNull(data),
            blockHash: hash,
            transactionHash: hash,
            logs: Formatter.arrayOf(this.receiptLog.bind(this)),
            blockNumber: number,
            confirmations: Formatter.allowNull(number, null),
            cumulativeGasUsed: bigNumber,
            effectiveGasPrice: Formatter.allowNull(bigNumber),
            status: Formatter.allowNull(number),
            type: type
        };
        formats.block = {
            hash: Formatter.allowNull(hash),
            parentHash: hash,
            number: number,
            timestamp: number,
            nonce: Formatter.allowNull(hex),
            difficulty: this.difficulty.bind(this),
            gasLimit: bigNumber,
            gasUsed: bigNumber,
            miner: Formatter.allowNull(address),
            extraData: data,
            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
            baseFeePerGas: Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = shallowCopy(formats.block);
        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
            fromBlock: Formatter.allowNull(blockTag, undefined),
            toBlock: Formatter.allowNull(blockTag, undefined),
            blockHash: Formatter.allowNull(hash, undefined),
            address: Formatter.allowNull(address, undefined),
            topics: Formatter.allowNull(this.topics.bind(this), undefined),
        };
        formats.filterLog = {
            blockNumber: Formatter.allowNull(number),
            blockHash: Formatter.allowNull(hash),
            transactionIndex: number,
            removed: Formatter.allowNull(this.boolean.bind(this)),
            address: address,
            data: Formatter.allowFalsish(data, "0x"),
            topics: Formatter.arrayOf(hash),
            transactionHash: hash,
            logIndex: number,
        };
        return formats;
    }
    accessList(accessList) {
        return accessListify(accessList || []);
    }
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    number(number) {
        if (number === "0x") {
            return 0;
        }
        return BigNumber.from(number).toNumber();
    }
    type(number) {
        if (number === "0x" || number == null) {
            return 0;
        }
        return BigNumber.from(number).toNumber();
    }
    // Strict! Used on input.
    bigNumber(value) {
        return BigNumber.from(value);
    }
    // Requires a boolean, "true" or  "false"; returns a boolean
    boolean(value) {
        if (typeof (value) === "boolean") {
            return value;
        }
        if (typeof (value) === "string") {
            value = value.toLowerCase();
            if (value === "true") {
                return true;
            }
            if (value === "false") {
                return false;
            }
        }
        throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
        if (typeof (value) === "string") {
            if (!strict && value.substring(0, 2) !== "0x") {
                value = "0x" + value;
            }
            if (isHexString(value)) {
                return value.toLowerCase();
            }
        }
        return logger$h.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
        const result = this.hex(value, strict);
        if ((result.length % 2) !== 0) {
            throw new Error("invalid data; odd-length - " + value);
        }
        return result;
    }
    // Requires an address
    // Strict! Used on input.
    address(value) {
        return getAddress(value);
    }
    callAddress(value) {
        if (!isHexString(value, 32)) {
            return null;
        }
        const address = getAddress(hexDataSlice(value, 12));
        return (address === AddressZero) ? null : address;
    }
    contractAddress(value) {
        return getContractAddress(value);
    }
    // Strict! Used on input.
    blockTag(blockTag) {
        if (blockTag == null) {
            return "latest";
        }
        if (blockTag === "earliest") {
            return "0x0";
        }
        if (blockTag === "latest" || blockTag === "pending") {
            return blockTag;
        }
        if (typeof (blockTag) === "number" || isHexString(blockTag)) {
            return hexValue(blockTag);
        }
        throw new Error("invalid blockTag");
    }
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    hash(value, strict) {
        const result = this.hex(value, strict);
        if (hexDataLength(result) !== 32) {
            return logger$h.throwArgumentError("invalid hash", "value", value);
        }
        return result;
    }
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    difficulty(value) {
        if (value == null) {
            return null;
        }
        const v = BigNumber.from(value);
        try {
            return v.toNumber();
        }
        catch (error) { }
        return null;
    }
    uint256(value) {
        if (!isHexString(value)) {
            throw new Error("invalid uint256");
        }
        return hexZeroPad(value, 32);
    }
    _block(value, format) {
        if (value.author != null && value.miner == null) {
            value.miner = value.author;
        }
        // The difficulty may need to come from _difficulty in recursed blocks
        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;
        const result = Formatter.check(format, value);
        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));
        return result;
    }
    block(value) {
        return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
        return this._block(value, this.formats.blockWithTransactions);
    }
    // Strict! Used on input.
    transactionRequest(value) {
        return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction) {
        // Rename gas to gasLimit
        if (transaction.gas != null && transaction.gasLimit == null) {
            transaction.gasLimit = transaction.gas;
        }
        // Some clients (TestRPC) do strange things like return 0x0 for the
        // 0 address; correct this to be a real address
        if (transaction.to && BigNumber.from(transaction.to).isZero()) {
            transaction.to = "0x0000000000000000000000000000000000000000";
        }
        // Rename input to data
        if (transaction.input != null && transaction.data == null) {
            transaction.data = transaction.input;
        }
        // If to and creates are empty, populate the creates from the transaction
        if (transaction.to == null && transaction.creates == null) {
            transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
            transaction.accessList = [];
        }
        const result = Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
            let chainId = transaction.chainId;
            if (isHexString(chainId)) {
                chainId = BigNumber.from(chainId).toNumber();
            }
            result.chainId = chainId;
        }
        else {
            let chainId = transaction.networkId;
            // geth-etc returns chainId
            if (chainId == null && result.v == null) {
                chainId = transaction.chainId;
            }
            if (isHexString(chainId)) {
                chainId = BigNumber.from(chainId).toNumber();
            }
            if (typeof (chainId) !== "number" && result.v != null) {
                chainId = (result.v - 35) / 2;
                if (chainId < 0) {
                    chainId = 0;
                }
                chainId = parseInt(chainId);
            }
            if (typeof (chainId) !== "number") {
                chainId = 0;
            }
            result.chainId = chainId;
        }
        // 0x0000... should actually be null
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
            result.blockHash = null;
        }
        return result;
    }
    transaction(value) {
        return parse(value);
    }
    receiptLog(value) {
        return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
        const result = Formatter.check(this.formats.receipt, value);
        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it
        if (result.root != null) {
            if (result.root.length <= 4) {
                // Could be 0x00, 0x0, 0x01 or 0x1
                const value = BigNumber.from(result.root).toNumber();
                if (value === 0 || value === 1) {
                    // Make sure if both are specified, they match
                    if (result.status != null && (result.status !== value)) {
                        logger$h.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
                    }
                    result.status = value;
                    delete result.root;
                }
                else {
                    logger$h.throwArgumentError("invalid alt-root-status", "value.root", result.root);
                }
            }
            else if (result.root.length !== 66) {
                // Must be a valid bytes32
                logger$h.throwArgumentError("invalid root hash", "value.root", result.root);
            }
        }
        if (result.status != null) {
            result.byzantium = true;
        }
        return result;
    }
    topics(value) {
        if (Array.isArray(value)) {
            return value.map((v) => this.topics(v));
        }
        else if (value != null) {
            return this.hash(value, true);
        }
        return null;
    }
    filter(value) {
        return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
        return Formatter.check(this.formats.filterLog, value);
    }
    static check(format, object) {
        const result = {};
        for (const key in format) {
            try {
                const value = format[key](object[key]);
                if (value !== undefined) {
                    result[key] = value;
                }
            }
            catch (error) {
                error.checkKey = key;
                error.checkValue = object[key];
                throw error;
            }
        }
        return result;
    }
    // if value is null-ish, nullValue is returned
    static allowNull(format, nullValue) {
        return (function (value) {
            if (value == null) {
                return nullValue;
            }
            return format(value);
        });
    }
    // If value is false-ish, replaceValue is returned
    static allowFalsish(format, replaceValue) {
        return (function (value) {
            if (!value) {
                return replaceValue;
            }
            return format(value);
        });
    }
    // Requires an Array satisfying check
    static arrayOf(format) {
        return (function (array) {
            if (!Array.isArray(array)) {
                throw new Error("not an array");
            }
            const result = [];
            array.forEach(function (value) {
                result.push(format(value));
            });
            return result;
        });
    }
}
function isCommunityResourcable(value) {
    return (value && typeof (value.isCommunityResource) === "function");
}
function isCommunityResource(value) {
    return (isCommunityResourcable(value) && value.isCommunityResource());
}
// Show the throttle message only once
let throttleMessage = false;
function showThrottleMessage() {
    if (throttleMessage) {
        return;
    }
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https:/\/docs.ethers.io/api-keys/");
    console.log("==========================");
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$g = new Logger(version$3);
const MAX_CCIP_REDIRECTS = 10;
//////////////////////////////
// Event Serializeing
function checkTopic(topic) {
    if (topic == null) {
        return "null";
    }
    if (hexDataLength(topic) !== 32) {
        logger$g.throwArgumentError("invalid topic", "topic", topic);
    }
    return topic.toLowerCase();
}
function serializeTopics(topics) {
    // Remove trailing null AND-topics; they are redundant
    topics = topics.slice();
    while (topics.length > 0 && topics[topics.length - 1] == null) {
        topics.pop();
    }
    return topics.map((topic) => {
        if (Array.isArray(topic)) {
            // Only track unique OR-topics
            const unique = {};
            topic.forEach((topic) => {
                unique[checkTopic(topic)] = true;
            });
            // The order of OR-topics does not matter
            const sorted = Object.keys(unique);
            sorted.sort();
            return sorted.join("|");
        }
        else {
            return checkTopic(topic);
        }
    }).join("&");
}
function deserializeTopics(data) {
    if (data === "") {
        return [];
    }
    return data.split(/&/g).map((topic) => {
        if (topic === "") {
            return [];
        }
        const comps = topic.split("|").map((topic) => {
            return ((topic === "null") ? null : topic);
        });
        return ((comps.length === 1) ? comps[0] : comps);
    });
}
function getEventTag(eventName) {
    if (typeof (eventName) === "string") {
        eventName = eventName.toLowerCase();
        if (hexDataLength(eventName) === 32) {
            return "tx:" + eventName;
        }
        if (eventName.indexOf(":") === -1) {
            return eventName;
        }
    }
    else if (Array.isArray(eventName)) {
        return "filter:*:" + serializeTopics(eventName);
    }
    else if (ForkEvent.isForkEvent(eventName)) {
        logger$g.warn("not implemented");
        throw new Error("not implemented");
    }
    else if (eventName && typeof (eventName) === "object") {
        return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    }
    throw new Error("invalid event - " + eventName);
}
//////////////////////////////
// Helper Object
function getTime() {
    return (new Date()).getTime();
}
function stall$1(duration) {
    return new Promise((resolve) => {
        setTimeout(resolve, duration);
    });
}
//////////////////////////////
// Provider Object
/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */
const PollableEvents = ["block", "network", "pending", "poll"];
class Event$1 {
    constructor(tag, listener, once) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "listener", listener);
        defineReadOnly(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash;
            case "filter":
                return this.filter;
        }
        return this.tag;
    }
    get type() {
        return this.tag.split(":")[0];
    }
    get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") {
            return null;
        }
        return comps[1];
    }
    get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") {
            return null;
        }
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) {
            filter.topics = topics;
        }
        if (address && address !== "*") {
            filter.address = address;
        }
        return filter;
    }
    pollable() {
        return (this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0);
    }
}
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const coinInfos = {
    "0": { symbol: "btc", p2pkh: 0x00, p2sh: 0x05, prefix: "bc" },
    "2": { symbol: "ltc", p2pkh: 0x30, p2sh: 0x32, prefix: "ltc" },
    "3": { symbol: "doge", p2pkh: 0x1e, p2sh: 0x16 },
    "60": { symbol: "eth", ilk: "eth" },
    "61": { symbol: "etc", ilk: "eth" },
    "700": { symbol: "xdai", ilk: "eth" },
};
function bytes32ify(value) {
    return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)
function base58Encode(data) {
    return Base58.encode(concat([data, hexDataSlice(sha256$1(sha256$1(data)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
const matchers = [
    new RegExp("^(https):/\/(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
];
function _parseString(result, start) {
    try {
        return toUtf8String(_parseBytes(result, start));
    }
    catch (error) { }
    return null;
}
function _parseBytes(result, start) {
    if (result === "0x") {
        return null;
    }
    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
    return hexDataSlice(result, offset + 32, offset + 32 + length);
}
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
    }
    else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
    }
    else {
        logger$g.throwArgumentError("unsupported IPFS format", "link", link);
    }
    return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
    const result = arrayify(value);
    if (result.length > 32) {
        throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
}
function bytesPad(value) {
    if ((value.length % 32) === 0) {
        return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
}
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    // Add place-holders for pointers as we add items
    for (let i = 0; i < datas.length; i++) {
        result.push(null);
        byteCount += 32;
    }
    for (let i = 0; i < datas.length; i++) {
        const data = arrayify(datas[i]);
        // Update the bytes offset
        result[i] = numPad(byteCount);
        // The length and padded value of data
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return hexConcat(result);
}
class Resolver {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    constructor(provider, address, name, resolvedAddress) {
        defineReadOnly(this, "provider", provider);
        defineReadOnly(this, "name", name);
        defineReadOnly(this, "address", provider.formatter.address(address));
        defineReadOnly(this, "_resolvedAddress", resolvedAddress);
    }
    supportsWildcard() {
        if (!this._supportsEip2544) {
            // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
            this._supportsEip2544 = this.provider.call({
                to: this.address,
                data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
            }).then((result) => {
                return BigNumber.from(result).eq(1);
            }).catch((error) => {
                if (error.code === Logger.errors.CALL_EXCEPTION) {
                    return false;
                }
                // Rethrow the error: link is down, etc. Let future attempts retry.
                this._supportsEip2544 = null;
                throw error;
            });
        }
        return this._supportsEip2544;
    }
    _fetch(selector, parameters) {
        return __awaiter$6(this, void 0, void 0, function* () {
            // e.g. keccak256("addr(bytes32,uint256)")
            const tx = {
                to: this.address,
                ccipReadEnabled: true,
                data: hexConcat([selector, namehash(this.name), (parameters || "0x")])
            };
            // Wildcard support; use EIP-2544 to resolve the request
            let parseBytes = false;
            if (yield this.supportsWildcard()) {
                parseBytes = true;
                // selector("resolve(bytes,bytes)")
                tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
            }
            try {
                let result = yield this.provider.call(tx);
                if ((arrayify(result).length % 32) === 4) {
                    logger$g.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
                        transaction: tx, data: result
                    });
                }
                if (parseBytes) {
                    result = _parseBytes(result, 0);
                }
                return result;
            }
            catch (error) {
                if (error.code === Logger.errors.CALL_EXCEPTION) {
                    return null;
                }
                throw error;
            }
        });
    }
    _fetchBytes(selector, parameters) {
        return __awaiter$6(this, void 0, void 0, function* () {
            const result = yield this._fetch(selector, parameters);
            if (result != null) {
                return _parseBytes(result, 0);
            }
            return null;
        });
    }
    _getAddress(coinType, hexBytes) {
        const coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
            logger$g.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${coinType})`
            });
        }
        if (coinInfo.ilk === "eth") {
            return this.provider.formatter.address(hexBytes);
        }
        const bytes = arrayify(hexBytes);
        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        if (coinInfo.p2pkh != null) {
            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (p2pkh) {
                const length = parseInt(p2pkh[1], 16);
                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
                    return base58Encode(concat([[coinInfo.p2pkh], ("0x" + p2pkh[2])]));
                }
            }
        }
        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
        if (coinInfo.p2sh != null) {
            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (p2sh) {
                const length = parseInt(p2sh[1], 16);
                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
                    return base58Encode(concat([[coinInfo.p2sh], ("0x" + p2sh[2])]));
                }
            }
        }
        // Bech32
        if (coinInfo.prefix != null) {
            const length = bytes[1];
            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program
            let version = bytes[0];
            if (version === 0x00) {
                if (length !== 20 && length !== 32) {
                    version = -1;
                }
            }
            else {
                version = -1;
            }
            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
                const words = bech32.toWords(bytes.slice(2));
                words.unshift(version);
                return bech32.encode(coinInfo.prefix, words);
            }
        }
        return null;
    }
    getAddress(coinType) {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (coinType == null) {
                coinType = 60;
            }
            // If Ethereum, use the standard `addr(bytes32)`
            if (coinType === 60) {
                try {
                    // keccak256("addr(bytes32)")
                    const result = yield this._fetch("0x3b3b57de");
                    // No address
                    if (result === "0x" || result === HashZero) {
                        return null;
                    }
                    return this.provider.formatter.callAddress(result);
                }
                catch (error) {
                    if (error.code === Logger.errors.CALL_EXCEPTION) {
                        return null;
                    }
                    throw error;
                }
            }
            // keccak256("addr(bytes32,uint256")
            const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
            // No address
            if (hexBytes == null || hexBytes === "0x") {
                return null;
            }
            // Compute the address
            const address = this._getAddress(coinType, hexBytes);
            if (address == null) {
                logger$g.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: `getAddress(${coinType})`,
                    coinType: coinType,
                    data: hexBytes
                });
            }
            return address;
        });
    }
    getAvatar() {
        return __awaiter$6(this, void 0, void 0, function* () {
            const linkage = [{ type: "name", content: this.name }];
            try {
                // test data for ricmoo.eth
                //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
                const avatar = yield this.getText("avatar");
                if (avatar == null) {
                    return null;
                }
                for (let i = 0; i < matchers.length; i++) {
                    const match = avatar.match(matchers[i]);
                    if (match == null) {
                        continue;
                    }
                    const scheme = match[1].toLowerCase();
                    switch (scheme) {
                        case "https":
                            linkage.push({ type: "url", content: avatar });
                            return { linkage, url: avatar };
                        case "data":
                            linkage.push({ type: "data", content: avatar });
                            return { linkage, url: avatar };
                        case "ipfs":
                            linkage.push({ type: "ipfs", content: avatar });
                            return { linkage, url: getIpfsLink(avatar) };
                        case "erc721":
                        case "erc1155": {
                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                            const selector = (scheme === "erc721") ? "0xc87b56dd" : "0x0e89341c";
                            linkage.push({ type: scheme, content: avatar });
                            // The owner of this name
                            const owner = (this._resolvedAddress || (yield this.getAddress()));
                            const comps = (match[2] || "").split("/");
                            if (comps.length !== 2) {
                                return null;
                            }
                            const addr = yield this.provider.formatter.address(comps[0]);
                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
                            // Check that this account owns the token
                            if (scheme === "erc721") {
                                // ownerOf(uint256 tokenId)
                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                                    to: addr, data: hexConcat(["0x6352211e", tokenId])
                                }));
                                if (owner !== tokenOwner) {
                                    return null;
                                }
                                linkage.push({ type: "owner", content: tokenOwner });
                            }
                            else if (scheme === "erc1155") {
                                // balanceOf(address owner, uint256 tokenId)
                                const balance = BigNumber.from(yield this.provider.call({
                                    to: addr, data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                                }));
                                if (balance.isZero()) {
                                    return null;
                                }
                                linkage.push({ type: "balance", content: balance.toString() });
                            }
                            // Call the token contract for the metadata URL
                            const tx = {
                                to: this.provider.formatter.address(comps[0]),
                                data: hexConcat([selector, tokenId])
                            };
                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);
                            if (metadataUrl == null) {
                                return null;
                            }
                            linkage.push({ type: "metadata-url-base", content: metadataUrl });
                            // ERC-1155 allows a generic {id} in the URL
                            if (scheme === "erc1155") {
                                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                            }
                            // Transform IPFS metadata links
                            if (metadataUrl.match(/^ipfs:/i)) {
                                metadataUrl = getIpfsLink(metadataUrl);
                            }
                            linkage.push({ type: "metadata-url", content: metadataUrl });
                            // Get the token metadata
                            const metadata = yield fetchJson(metadataUrl);
                            if (!metadata) {
                                return null;
                            }
                            linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                            // Pull the image URL out
                            let imageUrl = metadata.image;
                            if (typeof (imageUrl) !== "string") {
                                return null;
                            }
                            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                                // Allow
                            }
                            else {
                                // Transform IPFS link to gateway
                                const ipfs = imageUrl.match(matcherIpfs);
                                if (ipfs == null) {
                                    return null;
                                }
                                linkage.push({ type: "url-ipfs", content: imageUrl });
                                imageUrl = getIpfsLink(imageUrl);
                            }
                            linkage.push({ type: "url", content: imageUrl });
                            return { linkage, url: imageUrl };
                        }
                    }
                }
            }
            catch (error) { }
            return null;
        });
    }
    getContentHash() {
        return __awaiter$6(this, void 0, void 0, function* () {
            // keccak256("contenthash()")
            const hexBytes = yield this._fetchBytes("0xbc1c58d1");
            // No contenthash
            if (hexBytes == null || hexBytes === "0x") {
                return null;
            }
            // IPFS (CID: 1, Type: DAG-PB)
            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipfs) {
                const length = parseInt(ipfs[3], 16);
                if (ipfs[4].length === length * 2) {
                    return "ipfs:/\/" + Base58.encode("0x" + ipfs[1]);
                }
            }
            // IPNS (CID: 1, Type: libp2p-key)
            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipns) {
                const length = parseInt(ipns[3], 16);
                if (ipns[4].length === length * 2) {
                    return "ipns:/\/" + Base58.encode("0x" + ipns[1]);
                }
            }
            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (swarm) {
                if (swarm[1].length === (32 * 2)) {
                    return "bzz:/\/" + swarm[1];
                }
            }
            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
            if (skynet) {
                if (skynet[1].length === (34 * 2)) {
                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5
                    const urlSafe = { "=": "", "+": "-", "/": "_" };
                    const hash = encode$1("0x" + skynet[1]).replace(/[=+\/]/g, (a) => (urlSafe[a]));
                    return "sia:/\/" + hash;
                }
            }
            return logger$g.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: hexBytes
            });
        });
    }
    getText(key) {
        return __awaiter$6(this, void 0, void 0, function* () {
            // The key encoded as parameter to fetchBytes
            let keyBytes = toUtf8Bytes(key);
            // The nodehash consumes the first slot, so the string pointer targets
            // offset 64, with the length at offset 64 and data starting at offset 96
            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
            // Pad to word-size (32 bytes)
            if ((keyBytes.length % 32) !== 0) {
                keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - (key.length % 32))]);
            }
            const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
            if (hexBytes == null || hexBytes === "0x") {
                return null;
            }
            return toUtf8String(hexBytes);
        });
    }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    constructor(network) {
        super();
        // Events being listened to
        this._events = [];
        this._emitted = { block: -2 };
        this.disableCcipRead = false;
        this.formatter = new.target.getFormatter();
        // If network is any, this Provider allows the underlying
        // network to change dynamically, and we auto-detect the
        // current network
        defineReadOnly(this, "anyNetwork", (network === "any"));
        if (this.anyNetwork) {
            network = this.detectNetwork();
        }
        if (network instanceof Promise) {
            this._networkPromise = network;
            // Squash any "unhandled promise" errors; that do not need to be handled
            network.catch((error) => { });
            // Trigger initial network setting (async)
            this._ready().catch((error) => { });
        }
        else {
            const knownNetwork = getStatic(new.target, "getNetwork")(network);
            if (knownNetwork) {
                defineReadOnly(this, "_network", knownNetwork);
                this.emit("network", knownNetwork, null);
            }
            else {
                logger$g.throwArgumentError("invalid network", "network", network);
            }
        }
        this._maxInternalBlockNumber = -1024;
        this._lastBlockNumber = -2;
        this._maxFilterBlockRange = 10;
        this._pollingInterval = 4000;
        this._fastQueryDate = 0;
    }
    _ready() {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (this._network == null) {
                let network = null;
                if (this._networkPromise) {
                    try {
                        network = yield this._networkPromise;
                    }
                    catch (error) { }
                }
                // Try the Provider's network detection (this MUST throw if it cannot)
                if (network == null) {
                    network = yield this.detectNetwork();
                }
                // This should never happen; every Provider sub-class should have
                // suggested a network by here (or have thrown).
                if (!network) {
                    logger$g.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
                }
                // Possible this call stacked so do not call defineReadOnly again
                if (this._network == null) {
                    if (this.anyNetwork) {
                        this._network = network;
                    }
                    else {
                        defineReadOnly(this, "_network", network);
                    }
                    this.emit("network", network, null);
                }
            }
            return this._network;
        });
    }
    // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change
    get ready() {
        return poll(() => {
            return this._ready().then((network) => {
                return network;
            }, (error) => {
                // If the network isn't running yet, we will wait
                if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
                    return undefined;
                }
                throw error;
            });
        });
    }
    // @TODO: Remove this and just create a singleton formatter
    static getFormatter() {
        if (defaultFormatter == null) {
            defaultFormatter = new Formatter();
        }
        return defaultFormatter;
    }
    // @TODO: Remove this and just use getNetwork
    static getNetwork(network) {
        return getNetwork((network == null) ? "homestead" : network);
    }
    ccipReadFetch(tx, calldata, urls) {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (this.disableCcipRead || urls.length === 0) {
                return null;
            }
            const sender = tx.to.toLowerCase();
            const data = calldata.toLowerCase();
            const errorMessages = [];
            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                // URL expansion
                const href = url.replace("{sender}", sender).replace("{data}", data);
                // If no {data} is present, use POST; otherwise GET
                const json = (url.indexOf("{data}") >= 0) ? null : JSON.stringify({ data, sender });
                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
                    value.status = response.statusCode;
                    return value;
                });
                if (result.data) {
                    return result.data;
                }
                const errorMessage = (result.message || "unknown error");
                // 4xx indicates the result is not present; stop
                if (result.status >= 400 && result.status < 500) {
                    return logger$g.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
                }
                // 5xx indicates server issue; try the next url
                errorMessages.push(errorMessage);
            }
            return logger$g.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, Logger.errors.SERVER_ERROR, {
                urls, errorMessages
            });
        });
    }
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    _getInternalBlockNumber(maxAge) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this._ready();
            // Allowing stale data up to maxAge old
            if (maxAge > 0) {
                // While there are pending internal block requests...
                while (this._internalBlockNumber) {
                    // ..."remember" which fetch we started with
                    const internalBlockNumber = this._internalBlockNumber;
                    try {
                        // Check the result is not too stale
                        const result = yield internalBlockNumber;
                        if ((getTime() - result.respTime) <= maxAge) {
                            return result.blockNumber;
                        }
                        // Too old; fetch a new value
                        break;
                    }
                    catch (error) {
                        // The fetch rejected; if we are the first to get the
                        // rejection, drop through so we replace it with a new
                        // fetch; all others blocked will then get that fetch
                        // which won't match the one they "remembered" and loop
                        if (this._internalBlockNumber === internalBlockNumber) {
                            break;
                        }
                    }
                }
            }
            const reqTime = getTime();
            const checkInternalBlockNumber = resolveProperties({
                blockNumber: this.perform("getBlockNumber", {}),
                networkError: this.getNetwork().then((network) => (null), (error) => (error))
            }).then(({ blockNumber, networkError }) => {
                if (networkError) {
                    // Unremember this bad internal block number
                    if (this._internalBlockNumber === checkInternalBlockNumber) {
                        this._internalBlockNumber = null;
                    }
                    throw networkError;
                }
                const respTime = getTime();
                blockNumber = BigNumber.from(blockNumber).toNumber();
                if (blockNumber < this._maxInternalBlockNumber) {
                    blockNumber = this._maxInternalBlockNumber;
                }
                this._maxInternalBlockNumber = blockNumber;
                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?
                return { blockNumber, reqTime, respTime };
            });
            this._internalBlockNumber = checkInternalBlockNumber;
            // Swallow unhandled exceptions; if needed they are handled else where
            checkInternalBlockNumber.catch((error) => {
                // Don't null the dead (rejected) fetch, if it has already been updated
                if (this._internalBlockNumber === checkInternalBlockNumber) {
                    this._internalBlockNumber = null;
                }
            });
            return (yield checkInternalBlockNumber).blockNumber;
        });
    }
    poll() {
        return __awaiter$6(this, void 0, void 0, function* () {
            const pollId = nextPollId++;
            // Track all running promises, so we can trigger a post-poll once they are complete
            const runners = [];
            let blockNumber = null;
            try {
                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
            }
            catch (error) {
                this.emit("error", error);
                return;
            }
            this._setFastBlockNumber(blockNumber);
            // Emit a poll event after we have the latest (fast) block number
            this.emit("poll", pollId, blockNumber);
            // If the block has not changed, meh.
            if (blockNumber === this._lastBlockNumber) {
                this.emit("didPoll", pollId);
                return;
            }
            // First polling cycle, trigger a "block" events
            if (this._emitted.block === -2) {
                this._emitted.block = blockNumber - 1;
            }
            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {
                logger$g.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
                this.emit("error", logger$g.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
                    blockNumber: blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                }));
                this.emit("block", blockNumber);
            }
            else {
                // Notify all listener for each block that has passed
                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
                    this.emit("block", i);
                }
            }
            // The emitted block was updated, check for obsolete events
            if (this._emitted.block !== blockNumber) {
                this._emitted.block = blockNumber;
                Object.keys(this._emitted).forEach((key) => {
                    // The block event does not expire
                    if (key === "block") {
                        return;
                    }
                    // The block we were at when we emitted this event
                    const eventBlockNumber = this._emitted[key];
                    // We cannot garbage collect pending transactions or blocks here
                    // They should be garbage collected by the Provider when setting
                    // "pending" events
                    if (eventBlockNumber === "pending") {
                        return;
                    }
                    // Evict any transaction hashes or block hashes over 12 blocks
                    // old, since they should not return null anyways
                    if (blockNumber - eventBlockNumber > 12) {
                        delete this._emitted[key];
                    }
                });
            }
            // First polling cycle
            if (this._lastBlockNumber === -2) {
                this._lastBlockNumber = blockNumber - 1;
            }
            // Find all transaction hashes we are waiting on
            this._events.forEach((event) => {
                switch (event.type) {
                    case "tx": {
                        const hash = event.hash;
                        let runner = this.getTransactionReceipt(hash).then((receipt) => {
                            if (!receipt || receipt.blockNumber == null) {
                                return null;
                            }
                            this._emitted["t:" + hash] = receipt.blockNumber;
                            this.emit(hash, receipt);
                            return null;
                        }).catch((error) => { this.emit("error", error); });
                        runners.push(runner);
                        break;
                    }
                    case "filter": {
                        // We only allow a single getLogs to be in-flight at a time
                        if (!event._inflight) {
                            event._inflight = true;
                            // Filter from the last known event; due to load-balancing
                            // and some nodes returning updated block numbers before
                            // indexing events, a logs result with 0 entries cannot be
                            // trusted and we must retry a range which includes it again
                            const filter = event.filter;
                            filter.fromBlock = event._lastBlockNumber + 1;
                            filter.toBlock = blockNumber;
                            // Prevent fitler ranges from growing too wild
                            if (filter.toBlock - this._maxFilterBlockRange > filter.fromBlock) {
                                filter.fromBlock = filter.toBlock - this._maxFilterBlockRange;
                            }
                            const runner = this.getLogs(filter).then((logs) => {
                                // Allow the next getLogs
                                event._inflight = false;
                                if (logs.length === 0) {
                                    return;
                                }
                                logs.forEach((log) => {
                                    // Only when we get an event for a given block number
                                    // can we trust the events are indexed
                                    if (log.blockNumber > event._lastBlockNumber) {
                                        event._lastBlockNumber = log.blockNumber;
                                    }
                                    // Make sure we stall requests to fetch blocks and txs
                                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                                    this.emit(filter, log);
                                });
                            }).catch((error) => {
                                this.emit("error", error);
                                // Allow another getLogs (the range was not updated)
                                event._inflight = false;
                            });
                            runners.push(runner);
                        }
                        break;
                    }
                }
            });
            this._lastBlockNumber = blockNumber;
            // Once all events for this loop have been processed, emit "didPoll"
            Promise.all(runners).then(() => {
                this.emit("didPoll", pollId);
            }).catch((error) => { this.emit("error", error); });
            return;
        });
    }
    // Deprecated; do not use this
    resetEventsBlock(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
            this.poll();
        }
    }
    get network() {
        return this._network;
    }
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    detectNetwork() {
        return __awaiter$6(this, void 0, void 0, function* () {
            return logger$g.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            });
        });
    }
    getNetwork() {
        return __awaiter$6(this, void 0, void 0, function* () {
            const network = yield this._ready();
            // Make sure we are still connected to the same network; this is
            // only an external call for backends which can have the underlying
            // network change spontaneously
            const currentNetwork = yield this.detectNetwork();
            if (network.chainId !== currentNetwork.chainId) {
                // We are allowing network changes, things can get complex fast;
                // make sure you know what you are doing if you use "any"
                if (this.anyNetwork) {
                    this._network = currentNetwork;
                    // Reset all internal block number guards and caches
                    this._lastBlockNumber = -2;
                    this._fastBlockNumber = null;
                    this._fastBlockNumberPromise = null;
                    this._fastQueryDate = 0;
                    this._emitted.block = -2;
                    this._maxInternalBlockNumber = -1024;
                    this._internalBlockNumber = null;
                    // The "network" event MUST happen before this method resolves
                    // so any events have a chance to unregister, so we stall an
                    // additional event loop before returning from /this/ call
                    this.emit("network", currentNetwork, network);
                    yield stall$1(0);
                    return this._network;
                }
                const error = logger$g.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: network,
                    detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;
            }
            return network;
        });
    }
    get blockNumber() {
        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
            this._setFastBlockNumber(blockNumber);
        }, (error) => { });
        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;
    }
    get polling() {
        return (this._poller != null);
    }
    set polling(value) {
        if (value && !this._poller) {
            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);
            if (!this._bootstrapPoll) {
                this._bootstrapPoll = setTimeout(() => {
                    this.poll();
                    // We block additional polls until the polling interval
                    // is done, to prevent overwhelming the poll function
                    this._bootstrapPoll = setTimeout(() => {
                        // If polling was disabled, something may require a poke
                        // since starting the bootstrap poll and it was disabled
                        if (!this._poller) {
                            this.poll();
                        }
                        // Clear out the bootstrap so we can do another
                        this._bootstrapPoll = null;
                    }, this.pollingInterval);
                }, 0);
            }
        }
        else if (!value && this._poller) {
            clearInterval(this._poller);
            this._poller = null;
        }
    }
    get pollingInterval() {
        return this._pollingInterval;
    }
    set pollingInterval(value) {
        if (typeof (value) !== "number" || value <= 0 || parseInt(String(value)) != value) {
            throw new Error("invalid polling interval");
        }
        this._pollingInterval = value;
        if (this._poller) {
            clearInterval(this._poller);
            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);
        }
    }
    _getFastBlockNumber() {
        const now = getTime();
        // Stale block number, request a newer value
        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {
            this._fastQueryDate = now;
            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
                    this._fastBlockNumber = blockNumber;
                }
                return this._fastBlockNumber;
            });
        }
        return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
        // Older block, maybe a stale request
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
            return;
        }
        // Update the time we updated the blocknumber
        this._fastQueryDate = getTime();
        // Newer block number, use  it
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
            this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);
        });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter$6(this, void 0, void 0, function* () {
            const receipt = yield this.getTransactionReceipt(transactionHash);
            // Receipt is already good
            if ((receipt ? receipt.confirmations : 0) >= confirmations) {
                return receipt;
            }
            // Poll until the receipt is good...
            return new Promise((resolve, reject) => {
                const cancelFuncs = [];
                let done = false;
                const alreadyDone = function () {
                    if (done) {
                        return true;
                    }
                    done = true;
                    cancelFuncs.forEach((func) => { func(); });
                    return false;
                };
                const minedHandler = (receipt) => {
                    if (receipt.confirmations < confirmations) {
                        return;
                    }
                    if (alreadyDone()) {
                        return;
                    }
                    resolve(receipt);
                };
                this.on(transactionHash, minedHandler);
                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });
                if (replaceable) {
                    let lastBlockNumber = replaceable.startBlock;
                    let scannedBlock = null;
                    const replaceHandler = (blockNumber) => __awaiter$6(this, void 0, void 0, function* () {
                        if (done) {
                            return;
                        }
                        // Wait 1 second; this is only used in the case of a fault, so
                        // we will trade off a little bit of latency for more consistent
                        // results and fewer JSON-RPC calls
                        yield stall$1(1000);
                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$6(this, void 0, void 0, function* () {
                            if (done) {
                                return;
                            }
                            if (nonce <= replaceable.nonce) {
                                lastBlockNumber = blockNumber;
                            }
                            else {
                                // First check if the transaction was mined
                                {
                                    const mined = yield this.getTransaction(transactionHash);
                                    if (mined && mined.blockNumber != null) {
                                        return;
                                    }
                                }
                                // First time scanning. We start a little earlier for some
                                // wiggle room here to handle the eventually consistent nature
                                // of blockchain (e.g. the getTransactionCount was for a
                                // different block)
                                if (scannedBlock == null) {
                                    scannedBlock = lastBlockNumber - 3;
                                    if (scannedBlock < replaceable.startBlock) {
                                        scannedBlock = replaceable.startBlock;
                                    }
                                }
                                while (scannedBlock <= blockNumber) {
                                    if (done) {
                                        return;
                                    }
                                    const block = yield this.getBlockWithTransactions(scannedBlock);
                                    for (let ti = 0; ti < block.transactions.length; ti++) {
                                        const tx = block.transactions[ti];
                                        // Successfully mined!
                                        if (tx.hash === transactionHash) {
                                            return;
                                        }
                                        // Matches our transaction from and nonce; its a replacement
                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                                            if (done) {
                                                return;
                                            }
                                            // Get the receipt of the replacement
                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);
                                            // Already resolved or rejected (prolly a timeout)
                                            if (alreadyDone()) {
                                                return;
                                            }
                                            // The reason we were replaced
                                            let reason = "replaced";
                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                                                reason = "repriced";
                                            }
                                            else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                                                reason = "cancelled";
                                            }
                                            // Explain why we were replaced
                                            reject(logger$g.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                                                cancelled: (reason === "replaced" || reason === "cancelled"),
                                                reason,
                                                replacement: this._wrapTransaction(tx),
                                                hash: transactionHash,
                                                receipt
                                            }));
                                            return;
                                        }
                                    }
                                    scannedBlock++;
                                }
                            }
                            if (done) {
                                return;
                            }
                            this.once("block", replaceHandler);
                        }), (error) => {
                            if (done) {
                                return;
                            }
                            this.once("block", replaceHandler);
                        });
                    });
                    if (done) {
                        return;
                    }
                    this.once("block", replaceHandler);
                    cancelFuncs.push(() => {
                        this.removeListener("block", replaceHandler);
                    });
                }
                if (typeof (timeout) === "number" && timeout > 0) {
                    const timer = setTimeout(() => {
                        if (alreadyDone()) {
                            return;
                        }
                        reject(logger$g.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: timeout }));
                    }, timeout);
                    if (timer.unref) {
                        timer.unref();
                    }
                    cancelFuncs.push(() => { clearTimeout(timer); });
                }
            });
        });
    }
    getBlockNumber() {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._getInternalBlockNumber(0);
        });
    }
    getGasPrice() {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const result = yield this.perform("getGasPrice", {});
            try {
                return BigNumber.from(result);
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result, error
                });
            }
        });
    }
    getBalance(addressOrName, blockTag) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield resolveProperties({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getBalance", params);
            try {
                return BigNumber.from(result);
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params, result, error
                });
            }
        });
    }
    getTransactionCount(addressOrName, blockTag) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield resolveProperties({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getTransactionCount", params);
            try {
                return BigNumber.from(result).toNumber();
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params, result, error
                });
            }
        });
    }
    getCode(addressOrName, blockTag) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield resolveProperties({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getCode", params);
            try {
                return hexlify(result);
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getCode",
                    params, result, error
                });
            }
        });
    }
    getStorageAt(addressOrName, position, blockTag) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield resolveProperties({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag),
                position: Promise.resolve(position).then((p) => hexValue(p))
            });
            const result = yield this.perform("getStorageAt", params);
            try {
                return hexlify(result);
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params, result, error
                });
            }
        });
    }
    // This should be called by any subclass wrapping a TransactionResponse
    _wrapTransaction(tx, hash, startBlock) {
        if (hash != null && hexDataLength(hash) !== 32) {
            throw new Error("invalid response - sendTransaction");
        }
        const result = tx;
        // Check the hash we expect is the same as the hash the server reported
        if (hash != null && tx.hash !== hash) {
            logger$g.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });
        }
        result.wait = (confirms, timeout) => __awaiter$6(this, void 0, void 0, function* () {
            if (confirms == null) {
                confirms = 1;
            }
            if (timeout == null) {
                timeout = 0;
            }
            // Get the details to detect replacement
            let replacement = undefined;
            if (confirms !== 0 && startBlock != null) {
                replacement = {
                    data: tx.data,
                    from: tx.from,
                    nonce: tx.nonce,
                    to: tx.to,
                    value: tx.value,
                    startBlock
                };
            }
            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
            if (receipt == null && confirms === 0) {
                return null;
            }
            // No longer pending, allow the polling loop to garbage collect this
            this._emitted["t:" + tx.hash] = receipt.blockNumber;
            if (receipt.status === 0) {
                logger$g.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
                    transactionHash: tx.hash,
                    transaction: tx,
                    receipt: receipt
                });
            }
            return receipt;
        });
        return result;
    }
    sendTransaction(signedTransaction) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));
            const tx = this.formatter.transaction(signedTransaction);
            if (tx.confirmations == null) {
                tx.confirmations = 0;
            }
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const hash = yield this.perform("sendTransaction", { signedTransaction: hexTx });
                return this._wrapTransaction(tx, hash, blockNumber);
            }
            catch (error) {
                error.transaction = tx;
                error.transactionHash = tx.hash;
                throw error;
            }
        });
    }
    _getTransactionRequest(transaction) {
        return __awaiter$6(this, void 0, void 0, function* () {
            const values = yield transaction;
            const tx = {};
            ["from", "to"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));
            });
            ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));
            });
            ["type"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));
            });
            if (values.accessList) {
                tx.accessList = this.formatter.accessList(values.accessList);
            }
            ["data"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));
            });
            return this.formatter.transactionRequest(yield resolveProperties(tx));
        });
    }
    _getFilter(filter) {
        return __awaiter$6(this, void 0, void 0, function* () {
            filter = yield filter;
            const result = {};
            if (filter.address != null) {
                result.address = this._getAddress(filter.address);
            }
            ["blockHash", "topics"].forEach((key) => {
                if (filter[key] == null) {
                    return;
                }
                result[key] = filter[key];
            });
            ["fromBlock", "toBlock"].forEach((key) => {
                if (filter[key] == null) {
                    return;
                }
                result[key] = this._getBlockTag(filter[key]);
            });
            return this.formatter.filter(yield resolveProperties(result));
        });
    }
    _call(transaction, blockTag, attempt) {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (attempt >= MAX_CCIP_REDIRECTS) {
                logger$g.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
                    redirects: attempt, transaction
                });
            }
            const txSender = transaction.to;
            const result = yield this.perform("call", { transaction, blockTag });
            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)
            if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (hexDataLength(result) % 32 === 4)) {
                try {
                    const data = hexDataSlice(result, 4);
                    // Check the sender of the OffchainLookup matches the transaction
                    const sender = hexDataSlice(data, 0, 32);
                    if (!BigNumber.from(sender).eq(txSender)) {
                        logger$g.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction, data: result
                        });
                    }
                    // Read the URLs from the response
                    const urls = [];
                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
                    const urlsData = hexDataSlice(data, urlsOffset + 32);
                    for (let u = 0; u < urlsLength; u++) {
                        const url = _parseString(urlsData, u * 32);
                        if (url == null) {
                            logger$g.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction, data: result
                            });
                        }
                        urls.push(url);
                    }
                    // Get the CCIP calldata to forward
                    const calldata = _parseBytes(data, 64);
                    // Get the callbackSelector (bytes4)
                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
                        logger$g.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction, data: result
                        });
                    }
                    const callbackSelector = hexDataSlice(data, 96, 100);
                    // Get the extra data to send back to the contract as context
                    const extraData = _parseBytes(data, 128);
                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
                    if (ccipResult == null) {
                        logger$g.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction, data: result
                        });
                    }
                    const tx = {
                        to: txSender,
                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
                    };
                    return this._call(tx, blockTag, attempt + 1);
                }
                catch (error) {
                    if (error.code === Logger.errors.SERVER_ERROR) {
                        throw error;
                    }
                }
            }
            try {
                return hexlify(result);
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "call",
                    params: { transaction, blockTag }, result, error
                });
            }
        });
    }
    call(transaction, blockTag) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const resolved = yield resolveProperties({
                transaction: this._getTransactionRequest(transaction),
                blockTag: this._getBlockTag(blockTag),
                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
            });
            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
        });
    }
    estimateGas(transaction) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield resolveProperties({
                transaction: this._getTransactionRequest(transaction)
            });
            const result = yield this.perform("estimateGas", params);
            try {
                return BigNumber.from(result);
            }
            catch (error) {
                return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params, result, error
                });
            }
        });
    }
    _getAddress(addressOrName) {
        return __awaiter$6(this, void 0, void 0, function* () {
            addressOrName = yield addressOrName;
            if (typeof (addressOrName) !== "string") {
                logger$g.throwArgumentError("invalid address or ENS name", "name", addressOrName);
            }
            const address = yield this.resolveName(addressOrName);
            if (address == null) {
                logger$g.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: `resolveName(${JSON.stringify(addressOrName)})`
                });
            }
            return address;
        });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            blockHashOrBlockTag = yield blockHashOrBlockTag;
            // If blockTag is a number (not "latest", etc), this is the block number
            let blockNumber = -128;
            const params = {
                includeTransactions: !!includeTransactions
            };
            if (isHexString(blockHashOrBlockTag, 32)) {
                params.blockHash = blockHashOrBlockTag;
            }
            else {
                try {
                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
                    if (isHexString(params.blockTag)) {
                        blockNumber = parseInt(params.blockTag.substring(2), 16);
                    }
                }
                catch (error) {
                    logger$g.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
                }
            }
            return poll(() => __awaiter$6(this, void 0, void 0, function* () {
                const block = yield this.perform("getBlock", params);
                // Block was not found
                if (block == null) {
                    // For blockhashes, if we didn't say it existed, that blockhash may
                    // not exist. If we did see it though, perhaps from a log, we know
                    // it exists, and this node is just not caught up yet.
                    if (params.blockHash != null) {
                        if (this._emitted["b:" + params.blockHash] == null) {
                            return null;
                        }
                    }
                    // For block tags, if we are asking for a future block, we return null
                    if (params.blockTag != null) {
                        if (blockNumber > this._emitted.block) {
                            return null;
                        }
                    }
                    // Retry on the next block
                    return undefined;
                }
                // Add transactions
                if (includeTransactions) {
                    let blockNumber = null;
                    for (let i = 0; i < block.transactions.length; i++) {
                        const tx = block.transactions[i];
                        if (tx.blockNumber == null) {
                            tx.confirmations = 0;
                        }
                        else if (tx.confirmations == null) {
                            if (blockNumber == null) {
                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                            }
                            // Add the confirmations using the fast block number (pessimistic)
                            let confirmations = (blockNumber - tx.blockNumber) + 1;
                            if (confirmations <= 0) {
                                confirmations = 1;
                            }
                            tx.confirmations = confirmations;
                        }
                    }
                    const blockWithTxs = this.formatter.blockWithTransactions(block);
                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
                    return blockWithTxs;
                }
                return this.formatter.block(block);
            }), { oncePoll: this });
        });
    }
    getBlock(blockHashOrBlockTag) {
        return (this._getBlock(blockHashOrBlockTag, false));
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
        return (this._getBlock(blockHashOrBlockTag, true));
    }
    getTransaction(transactionHash) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = { transactionHash: this.formatter.hash(transactionHash, true) };
            return poll(() => __awaiter$6(this, void 0, void 0, function* () {
                const result = yield this.perform("getTransaction", params);
                if (result == null) {
                    if (this._emitted["t:" + transactionHash] == null) {
                        return null;
                    }
                    return undefined;
                }
                const tx = this.formatter.transactionResponse(result);
                if (tx.blockNumber == null) {
                    tx.confirmations = 0;
                }
                else if (tx.confirmations == null) {
                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    // Add the confirmations using the fast block number (pessimistic)
                    let confirmations = (blockNumber - tx.blockNumber) + 1;
                    if (confirmations <= 0) {
                        confirmations = 1;
                    }
                    tx.confirmations = confirmations;
                }
                return this._wrapTransaction(tx);
            }), { oncePoll: this });
        });
    }
    getTransactionReceipt(transactionHash) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = { transactionHash: this.formatter.hash(transactionHash, true) };
            return poll(() => __awaiter$6(this, void 0, void 0, function* () {
                const result = yield this.perform("getTransactionReceipt", params);
                if (result == null) {
                    if (this._emitted["t:" + transactionHash] == null) {
                        return null;
                    }
                    return undefined;
                }
                // "geth-etc" returns receipts before they are ready
                if (result.blockHash == null) {
                    return undefined;
                }
                const receipt = this.formatter.receipt(result);
                if (receipt.blockNumber == null) {
                    receipt.confirmations = 0;
                }
                else if (receipt.confirmations == null) {
                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    // Add the confirmations using the fast block number (pessimistic)
                    let confirmations = (blockNumber - receipt.blockNumber) + 1;
                    if (confirmations <= 0) {
                        confirmations = 1;
                    }
                    receipt.confirmations = confirmations;
                }
                return receipt;
            }), { oncePoll: this });
        });
    }
    getLogs(filter) {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield resolveProperties({ filter: this._getFilter(filter) });
            const logs = yield this.perform("getLogs", params);
            logs.forEach((log) => {
                if (log.removed == null) {
                    log.removed = false;
                }
            });
            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
        });
    }
    getEtherPrice() {
        return __awaiter$6(this, void 0, void 0, function* () {
            yield this.getNetwork();
            return this.perform("getEtherPrice", {});
        });
    }
    _getBlockTag(blockTag) {
        return __awaiter$6(this, void 0, void 0, function* () {
            blockTag = yield blockTag;
            if (typeof (blockTag) === "number" && blockTag < 0) {
                if (blockTag % 1) {
                    logger$g.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                }
                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                blockNumber += blockTag;
                if (blockNumber < 0) {
                    blockNumber = 0;
                }
                return this.formatter.blockTag(blockNumber);
            }
            return this.formatter.blockTag(blockTag);
        });
    }
    getResolver(name) {
        return __awaiter$6(this, void 0, void 0, function* () {
            let currentName = name;
            while (true) {
                if (currentName === "" || currentName === ".") {
                    return null;
                }
                // Optimization since the eth node cannot change and does
                // not have a wildcard resolver
                if (name !== "eth" && currentName === "eth") {
                    return null;
                }
                // Check the current node for a resolver
                const addr = yield this._getResolver(currentName, "getResolver");
                // Found a resolver!
                if (addr != null) {
                    const resolver = new Resolver(this, addr, name);
                    // Legacy resolver found, using EIP-2544 so it isn't safe to use
                    if (currentName !== name && !(yield resolver.supportsWildcard())) {
                        return null;
                    }
                    return resolver;
                }
                // Get the parent node
                currentName = currentName.split(".").slice(1).join(".");
            }
        });
    }
    _getResolver(name, operation) {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (operation == null) {
                operation = "ENS";
            }
            const network = yield this.getNetwork();
            // No ENS...
            if (!network.ensAddress) {
                logger$g.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
            }
            try {
                // keccak256("resolver(bytes32)")
                const addrData = yield this.call({
                    to: network.ensAddress,
                    data: ("0x0178b8bf" + namehash(name).substring(2))
                });
                return this.formatter.callAddress(addrData);
            }
            catch (error) {
                // ENS registry cannot throw errors on resolver(bytes32)
            }
            return null;
        });
    }
    resolveName(name) {
        return __awaiter$6(this, void 0, void 0, function* () {
            name = yield name;
            // If it is already an address, nothing to resolve
            try {
                return Promise.resolve(this.formatter.address(name));
            }
            catch (error) {
                // If is is a hexstring, the address is bad (See #694)
                if (isHexString(name)) {
                    throw error;
                }
            }
            if (typeof (name) !== "string") {
                logger$g.throwArgumentError("invalid ENS name", "name", name);
            }
            // Get the addr from the resolver
            const resolver = yield this.getResolver(name);
            if (!resolver) {
                return null;
            }
            return yield resolver.getAddress();
        });
    }
    lookupAddress(address) {
        return __awaiter$6(this, void 0, void 0, function* () {
            address = yield address;
            address = this.formatter.address(address);
            const node = address.substring(2).toLowerCase() + ".addr.reverse";
            const resolverAddr = yield this._getResolver(node, "lookupAddress");
            if (resolverAddr == null) {
                return null;
            }
            // keccak("name(bytes32)")
            const name = _parseString(yield this.call({
                to: resolverAddr,
                data: ("0x691f3431" + namehash(node).substring(2))
            }), 0);
            const addr = yield this.resolveName(name);
            if (addr != address) {
                return null;
            }
            return name;
        });
    }
    getAvatar(nameOrAddress) {
        return __awaiter$6(this, void 0, void 0, function* () {
            let resolver = null;
            if (isHexString(nameOrAddress)) {
                // Address; reverse lookup
                const address = this.formatter.address(nameOrAddress);
                const node = address.substring(2).toLowerCase() + ".addr.reverse";
                const resolverAddress = yield this._getResolver(node, "getAvatar");
                if (!resolverAddress) {
                    return null;
                }
                // Try resolving the avatar against the addr.reverse resolver
                resolver = new Resolver(this, resolverAddress, node);
                try {
                    const avatar = yield resolver.getAvatar();
                    if (avatar) {
                        return avatar.url;
                    }
                }
                catch (error) {
                    if (error.code !== Logger.errors.CALL_EXCEPTION) {
                        throw error;
                    }
                }
                // Try getting the name and performing forward lookup; allowing wildcards
                try {
                    // keccak("name(bytes32)")
                    const name = _parseString(yield this.call({
                        to: resolverAddress,
                        data: ("0x691f3431" + namehash(node).substring(2))
                    }), 0);
                    resolver = yield this.getResolver(name);
                }
                catch (error) {
                    if (error.code !== Logger.errors.CALL_EXCEPTION) {
                        throw error;
                    }
                    return null;
                }
            }
            else {
                // ENS name; forward lookup with wildcard
                resolver = yield this.getResolver(nameOrAddress);
                if (!resolver) {
                    return null;
                }
            }
            const avatar = yield resolver.getAvatar();
            if (avatar == null) {
                return null;
            }
            return avatar.url;
        });
    }
    perform(method, params) {
        return logger$g.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
    }
    _startEvent(event) {
        this.polling = (this._events.filter((e) => e.pollable()).length > 0);
    }
    _stopEvent(event) {
        this.polling = (this._events.filter((e) => e.pollable()).length > 0);
    }
    _addEventListener(eventName, listener, once) {
        const event = new Event$1(getEventTag(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
    }
    on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
        let result = false;
        let stopped = [];
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event) => {
            if (event.tag !== eventTag) {
                return true;
            }
            setTimeout(() => {
                event.listener.apply(this, args);
            }, 0);
            result = true;
            if (event.once) {
                stopped.push(event);
                return false;
            }
            return true;
        });
        stopped.forEach((event) => { this._stopEvent(event); });
        return result;
    }
    listenerCount(eventName) {
        if (!eventName) {
            return this._events.length;
        }
        let eventTag = getEventTag(eventName);
        return this._events.filter((event) => {
            return (event.tag === eventTag);
        }).length;
    }
    listeners(eventName) {
        if (eventName == null) {
            return this._events.map((event) => event.listener);
        }
        let eventTag = getEventTag(eventName);
        return this._events
            .filter((event) => (event.tag === eventTag))
            .map((event) => event.listener);
    }
    off(eventName, listener) {
        if (listener == null) {
            return this.removeAllListeners(eventName);
        }
        const stopped = [];
        let found = false;
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event) => {
            if (event.tag !== eventTag || event.listener != listener) {
                return true;
            }
            if (found) {
                return true;
            }
            found = true;
            stopped.push(event);
            return false;
        });
        stopped.forEach((event) => { this._stopEvent(event); });
        return this;
    }
    removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
            stopped = this._events;
            this._events = [];
        }
        else {
            const eventTag = getEventTag(eventName);
            this._events = this._events.filter((event) => {
                if (event.tag !== eventTag) {
                    return true;
                }
                stopped.push(event);
                return false;
            });
        }
        stopped.forEach((event) => { this._stopEvent(event); });
        return this;
    }
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$f = new Logger(version$3);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
    if (value == null) {
        return null;
    }
    // These *are* the droids we're looking for.
    if (typeof (value.message) === "string" && value.message.match("reverted")) {
        const data = isHexString(value.data) ? value.data : null;
        if (!requireData || data) {
            return { message: value.message, data };
        }
    }
    // Spelunk further...
    if (typeof (value) === "object") {
        for (const key in value) {
            const result = spelunk(value[key], requireData);
            if (result) {
                return result;
            }
        }
        return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof (value) === "string") {
        try {
            return spelunk(JSON.parse(value), requireData);
        }
        catch (error) { }
    }
    return null;
}
function checkError$1(method, error, params) {
    const transaction = params.transaction || params.signedTransaction;
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call") {
        const result = spelunk(error, true);
        if (result) {
            return result.data;
        }
        // Nothing descriptive..
        logger$f.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
            data: "0x", transaction, error
        });
    }
    if (method === "estimateGas") {
        // Try to find something, with a preference on SERVER_ERROR body
        let result = spelunk(error.body, false);
        if (result == null) {
            result = spelunk(error, false);
        }
        // Found "reverted", this is a CALL_EXCEPTION
        if (result) {
            logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                reason: result.message, method, transaction, error
            });
        }
    }
    // @TODO: Should we spelunk for message too?
    let message = error.message;
    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === "string") {
        message = error.error.message;
    }
    else if (typeof (error.body) === "string") {
        message = error.body;
    }
    else if (typeof (error.responseText) === "string") {
        message = error.responseText;
    }
    message = (message || "").toLowerCase();
    // "insufficient funds for gas * price + value + cost(data)"
    if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        logger$f.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
            error, method, transaction
        });
    }
    // "nonce too low"
    if (message.match(/nonce (is )?too low/i)) {
        logger$f.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
            error, method, transaction
        });
    }
    // "replacement transaction underpriced"
    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
        logger$f.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
            error, method, transaction
        });
    }
    // "replacement transaction underpriced"
    if (message.match(/only replay-protected/i)) {
        logger$f.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
            error, method, transaction
        });
    }
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
        logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error, method, transaction
        });
    }
    throw error;
}
function timer(timeout) {
    return new Promise(function (resolve) {
        setTimeout(resolve, timeout);
    });
}
function getResult$1(payload) {
    if (payload.error) {
        // @TODO: not any
        const error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
}
function getLowerCase(value) {
    if (value) {
        return value.toLowerCase();
    }
    return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
    constructor(constructorGuard, provider, addressOrIndex) {
        super();
        if (constructorGuard !== _constructorGuard) {
            throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        defineReadOnly(this, "provider", provider);
        if (addressOrIndex == null) {
            addressOrIndex = 0;
        }
        if (typeof (addressOrIndex) === "string") {
            defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
            defineReadOnly(this, "_index", null);
        }
        else if (typeof (addressOrIndex) === "number") {
            defineReadOnly(this, "_index", addressOrIndex);
            defineReadOnly(this, "_address", null);
        }
        else {
            logger$f.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
    }
    connect(provider) {
        return logger$f.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        });
    }
    connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    }
    getAddress() {
        if (this._address) {
            return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then((accounts) => {
            if (accounts.length <= this._index) {
                logger$f.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress"
                });
            }
            return this.provider.formatter.address(accounts[this._index]);
        });
    }
    sendUncheckedTransaction(transaction) {
        transaction = shallowCopy(transaction);
        const fromAddress = this.getAddress().then((address) => {
            if (address) {
                address = address.toLowerCase();
            }
            return address;
        });
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (transaction.gasLimit == null) {
            const estimate = shallowCopy(transaction);
            estimate.from = fromAddress;
            transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter$5(this, void 0, void 0, function* () {
                if (to == null) {
                    return null;
                }
                const address = yield this.provider.resolveName(to);
                if (address == null) {
                    logger$f.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                }
                return address;
            }));
        }
        return resolveProperties({
            tx: resolveProperties(transaction),
            sender: fromAddress
        }).then(({ tx, sender }) => {
            if (tx.from != null) {
                if (tx.from.toLowerCase() !== sender) {
                    logger$f.throwArgumentError("from address mismatch", "transaction", transaction);
                }
            }
            else {
                tx.from = sender;
            }
            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
            return this.provider.send("eth_sendTransaction", [hexTx]).then((hash) => {
                return hash;
            }, (error) => {
                return checkError$1("sendTransaction", error, hexTx);
            });
        });
    }
    signTransaction(transaction) {
        return logger$f.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        });
    }
    sendTransaction(transaction) {
        return __awaiter$5(this, void 0, void 0, function* () {
            // This cannot be mined any earlier than any recent block
            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
            // Send the transaction
            const hash = yield this.sendUncheckedTransaction(transaction);
            try {
                // Unfortunately, JSON-RPC only provides and opaque transaction hash
                // for a response, and we need the actual transaction, so we poll
                // for it; it should show up very quickly
                return yield poll(() => __awaiter$5(this, void 0, void 0, function* () {
                    const tx = yield this.provider.getTransaction(hash);
                    if (tx === null) {
                        return undefined;
                    }
                    return this.provider._wrapTransaction(tx, hash, blockNumber);
                }), { oncePoll: this.provider });
            }
            catch (error) {
                error.transactionHash = hash;
                throw error;
            }
        });
    }
    signMessage(message) {
        return __awaiter$5(this, void 0, void 0, function* () {
            const data = ((typeof (message) === "string") ? toUtf8Bytes(message) : message);
            const address = yield this.getAddress();
            return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
        });
    }
    _legacySignMessage(message) {
        return __awaiter$5(this, void 0, void 0, function* () {
            const data = ((typeof (message) === "string") ? toUtf8Bytes(message) : message);
            const address = yield this.getAddress();
            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
            return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter$5(this, void 0, void 0, function* () {
            // Populate any ENS names (in-place)
            const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
                return this.provider.resolveName(name);
            });
            const address = yield this.getAddress();
            return yield this.provider.send("eth_signTypedData_v4", [
                address.toLowerCase(),
                JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
            ]);
        });
    }
    unlock(password) {
        return __awaiter$5(this, void 0, void 0, function* () {
            const provider = this.provider;
            const address = yield this.getAddress();
            return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
        });
    }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(transaction) {
        return this.sendUncheckedTransaction(transaction).then((hash) => {
            return {
                hash: hash,
                nonce: null,
                gasLimit: null,
                gasPrice: null,
                data: null,
                value: null,
                chainId: null,
                confirmations: 0,
                from: null,
                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }
            };
        });
    }
}
const allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,
    type: true, accessList: true,
    maxFeePerGas: true, maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
    constructor(url, network) {
        let networkOrReady = network;
        // The network is unknown, query the JSON-RPC for it
        if (networkOrReady == null) {
            networkOrReady = new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.detectNetwork().then((network) => {
                        resolve(network);
                    }, (error) => {
                        reject(error);
                    });
                }, 0);
            });
        }
        super(networkOrReady);
        // Default URL
        if (!url) {
            url = getStatic(this.constructor, "defaultUrl")();
        }
        if (typeof (url) === "string") {
            defineReadOnly(this, "connection", Object.freeze({
                url: url
            }));
        }
        else {
            defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
        }
        this._nextId = 42;
    }
    get _cache() {
        if (this._eventLoopCache == null) {
            this._eventLoopCache = {};
        }
        return this._eventLoopCache;
    }
    static defaultUrl() {
        return "http:/\/localhost:8545";
    }
    detectNetwork() {
        if (!this._cache["detectNetwork"]) {
            this._cache["detectNetwork"] = this._uncachedDetectNetwork();
            // Clear this cache at the beginning of the next event loop
            setTimeout(() => {
                this._cache["detectNetwork"] = null;
            }, 0);
        }
        return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
        return __awaiter$5(this, void 0, void 0, function* () {
            yield timer(0);
            let chainId = null;
            try {
                chainId = yield this.send("eth_chainId", []);
            }
            catch (error) {
                try {
                    chainId = yield this.send("net_version", []);
                }
                catch (error) { }
            }
            if (chainId != null) {
                const getNetwork = getStatic(this.constructor, "getNetwork");
                try {
                    return getNetwork(BigNumber.from(chainId).toNumber());
                }
                catch (error) {
                    return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                        chainId: chainId,
                        event: "invalidNetwork",
                        serverError: error
                    });
                }
            }
            return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                event: "noNetwork"
            });
        });
    }
    getSigner(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((accounts) => {
            return accounts.map((a) => this.formatter.address(a));
        });
    }
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: deepCopy(request),
            provider: this
        });
        // We can expand this in the future to any call, but for now these
        // are the biggest wins and do not require any serializing parameters.
        const cache = (["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0);
        if (cache && this._cache[method]) {
            return this._cache[method];
        }
        const result = fetchJson(this.connection, JSON.stringify(request), getResult$1).then((result) => {
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error) => {
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });
            throw error;
        });
        // Cache the fetch, but clear it on the next event loop
        if (cache) {
            this._cache[method] = result;
            setTimeout(() => {
                this._cache[method] = null;
            }, 0);
        }
        return result;
    }
    prepareRequest(method, params) {
        switch (method) {
            case "getBlockNumber":
                return ["eth_blockNumber", []];
            case "getGasPrice":
                return ["eth_gasPrice", []];
            case "getBalance":
                return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
            case "getTransactionCount":
                return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
            case "getCode":
                return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
            case "getStorageAt":
                return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
            case "sendTransaction":
                return ["eth_sendRawTransaction", [params.signedTransaction]];
            case "getBlock":
                if (params.blockTag) {
                    return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
                }
                else if (params.blockHash) {
                    return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
                }
                return null;
            case "getTransaction":
                return ["eth_getTransactionByHash", [params.transactionHash]];
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [params.transactionHash]];
            case "call": {
                const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
                return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
            }
            case "estimateGas": {
                const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
                return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
            }
            case "getLogs":
                if (params.filter && params.filter.address != null) {
                    params.filter.address = getLowerCase(params.filter.address);
                }
                return ["eth_getLogs", [params.filter]];
        }
        return null;
    }
    perform(method, params) {
        return __awaiter$5(this, void 0, void 0, function* () {
            // Legacy networks do not like the type field being passed along (which
            // is fair), so we delete type if it is 0 and a non-EIP-1559 network
            if (method === "call" || method === "estimateGas") {
                const tx = params.transaction;
                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
                    // If there are no EIP-1559 properties, it might be non-EIP-1559
                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                        const feeData = yield this.getFeeData();
                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                            // Network doesn't know about EIP-1559 (and hence type)
                            params = shallowCopy(params);
                            params.transaction = shallowCopy(tx);
                            delete params.transaction.type;
                        }
                    }
                }
            }
            const args = this.prepareRequest(method, params);
            if (args == null) {
                logger$f.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
            }
            try {
                return yield this.send(args[0], args[1]);
            }
            catch (error) {
                return checkError$1(method, error, params);
            }
        });
    }
    _startEvent(event) {
        if (event.tag === "pending") {
            this._startPending();
        }
        super._startEvent(event);
    }
    _startPending() {
        if (this._pendingFilter != null) {
            return;
        }
        const self = this;
        const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function (filterId) {
            function poll() {
                self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {
                    if (self._pendingFilter != pendingFilter) {
                        return null;
                    }
                    let seq = Promise.resolve();
                    hashes.forEach(function (hash) {
                        // @TODO: This should be garbage collected at some point... How? When?
                        self._emitted["t:" + hash.toLowerCase()] = "pending";
                        seq = seq.then(function () {
                            return self.getTransaction(hash).then(function (tx) {
                                self.emit("pending", tx);
                                return null;
                            });
                        });
                    });
                    return seq.then(function () {
                        return timer(1000);
                    });
                }).then(function () {
                    if (self._pendingFilter != pendingFilter) {
                        self.send("eth_uninstallFilter", [filterId]);
                        return;
                    }
                    setTimeout(function () { poll(); }, 0);
                    return null;
                }).catch((error) => { });
            }
            poll();
            return filterId;
        }).catch((error) => { });
    }
    _stopEvent(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
            this._pendingFilter = null;
        }
        super._stopEvent(event);
    }
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    static hexlifyTransaction(transaction, allowExtra) {
        // Check only allowed properties are given
        const allowed = shallowCopy(allowedTransactionKeys);
        if (allowExtra) {
            for (const key in allowExtra) {
                if (allowExtra[key]) {
                    allowed[key] = true;
                }
            }
        }
        checkProperties(transaction, allowed);
        const result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
            if (transaction[key] == null) {
                return;
            }
            const value = hexValue(BigNumber.from(transaction[key]));
            if (key === "gasLimit") {
                key = "gas";
            }
            result[key] = value;
        });
        ["from", "to", "data"].forEach(function (key) {
            if (transaction[key] == null) {
                return;
            }
            result[key] = hexlify(transaction[key]);
        });
        if (transaction.accessList) {
            result["accessList"] = accessListify(transaction.accessList);
        }
        return result;
    }
}

let WS = null;
try {
    WS = WebSocket;
    if (WS == null) {
        throw new Error("inject please");
    }
}
catch (error) {
    const logger = new Logger(version$3);
    WS = function () {
        logger.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new WebSocket()"
        });
    };
}

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$e = new Logger(version$3);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */
let NextId = 1;
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
class WebSocketProvider extends JsonRpcProvider {
    constructor(url, network) {
        // This will be added in the future; please open an issue to expedite
        if (network === "any") {
            logger$e.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "network:any"
            });
        }
        if (typeof (url) === "string") {
            super(url, network);
        }
        else {
            super("_websocket", network);
        }
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof (url) === "string") {
            defineReadOnly(this, "_websocket", new WS(this.connection.url));
        }
        else {
            defineReadOnly(this, "_websocket", url);
        }
        defineReadOnly(this, "_requests", {});
        defineReadOnly(this, "_subs", {});
        defineReadOnly(this, "_subIds", {});
        defineReadOnly(this, "_detectNetwork", super.detectNetwork());
        // Stall sending requests until the socket is open...
        this.websocket.onopen = () => {
            this._wsReady = true;
            Object.keys(this._requests).forEach((id) => {
                this.websocket.send(this._requests[id].payload);
            });
        };
        this.websocket.onmessage = (messageEvent) => {
            const data = messageEvent.data;
            const result = JSON.parse(data);
            if (result.id != null) {
                const id = String(result.id);
                const request = this._requests[id];
                delete this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: this
                    });
                }
                else {
                    let error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        defineReadOnly(error, "code", result.error.code || null);
                        defineReadOnly(error, "response", data);
                    }
                    else {
                        error = new Error("unknown error");
                    }
                    request.callback(error, undefined);
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: JSON.parse(request.payload),
                        provider: this
                    });
                }
            }
            else if (result.method === "eth_subscription") {
                // Subscription...
                const sub = this._subs[result.params.subscription];
                if (sub) {
                    //this.emit.apply(this,                  );
                    sub.processFunc(result.params.result);
                }
            }
            else {
                console.warn("this should not happen");
            }
        };
        // This Provider does not actually poll, but we want to trigger
        // poll events for things that depend on them (like stalling for
        // block and transaction lookups)
        const fauxPoll = setInterval(() => {
            this.emit("poll");
        }, 1000);
        if (fauxPoll.unref) {
            fauxPoll.unref();
        }
    }
    // Cannot narrow the type of _websocket, as that is not backwards compatible
    // so we add a getter and let the WebSocket be a public API.
    get websocket() { return this._websocket; }
    detectNetwork() {
        return this._detectNetwork;
    }
    get pollingInterval() {
        return 0;
    }
    resetEventsBlock(blockNumber) {
        logger$e.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        });
    }
    set pollingInterval(value) {
        logger$e.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
        });
    }
    poll() {
        return __awaiter$4(this, void 0, void 0, function* () {
            return null;
        });
    }
    set polling(value) {
        if (!value) {
            return;
        }
        logger$e.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
        });
    }
    send(method, params) {
        const rid = NextId++;
        return new Promise((resolve, reject) => {
            function callback(error, result) {
                if (error) {
                    return reject(error);
                }
                return resolve(result);
            }
            const payload = JSON.stringify({
                method: method,
                params: params,
                id: rid,
                jsonrpc: "2.0"
            });
            this.emit("debug", {
                action: "request",
                request: JSON.parse(payload),
                provider: this
            });
            this._requests[String(rid)] = { callback, payload };
            if (this._wsReady) {
                this.websocket.send(payload);
            }
        });
    }
    static defaultUrl() {
        return "ws:/\/localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
        return __awaiter$4(this, void 0, void 0, function* () {
            let subIdPromise = this._subIds[tag];
            if (subIdPromise == null) {
                subIdPromise = Promise.all(param).then((param) => {
                    return this.send("eth_subscribe", param);
                });
                this._subIds[tag] = subIdPromise;
            }
            const subId = yield subIdPromise;
            this._subs[subId] = { tag, processFunc };
        });
    }
    _startEvent(event) {
        switch (event.type) {
            case "block":
                this._subscribe("block", ["newHeads"], (result) => {
                    const blockNumber = BigNumber.from(result.number).toNumber();
                    this._emitted.block = blockNumber;
                    this.emit("block", blockNumber);
                });
                break;
            case "pending":
                this._subscribe("pending", ["newPendingTransactions"], (result) => {
                    this.emit("pending", result);
                });
                break;
            case "filter":
                this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
                    if (result.removed == null) {
                        result.removed = false;
                    }
                    this.emit(event.filter, this.formatter.filterLog(result));
                });
                break;
            case "tx": {
                const emitReceipt = (event) => {
                    const hash = event.hash;
                    this.getTransactionReceipt(hash).then((receipt) => {
                        if (!receipt) {
                            return;
                        }
                        this.emit(hash, receipt);
                    });
                };
                // In case it is already mined
                emitReceipt(event);
                // To keep things simple, we start up a single newHeads subscription
                // to keep an eye out for transactions we are watching for.
                // Starting a subscription for an event (i.e. "tx") that is already
                // running is (basically) a nop.
                this._subscribe("tx", ["newHeads"], (result) => {
                    this._events.filter((e) => (e.type === "tx")).forEach(emitReceipt);
                });
                break;
            }
            // Nothing is needed
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break;
            default:
                console.log("unhandled:", event);
                break;
        }
    }
    _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
            // There are remaining transaction event listeners
            if (this._events.filter((e) => (e.type === "tx")).length) {
                return;
            }
            tag = "tx";
        }
        else if (this.listenerCount(event.event)) {
            // There are remaining event listeners
            return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
            return;
        }
        delete this._subIds[tag];
        subId.then((subId) => {
            if (!this._subs[subId]) {
                return;
            }
            delete this._subs[subId];
            this.send("eth_unsubscribe", [subId]);
        });
    }
    destroy() {
        return __awaiter$4(this, void 0, void 0, function* () {
            // Wait until we have connected before trying to disconnect
            if (this.websocket.readyState === WS.CONNECTING) {
                yield (new Promise((resolve) => {
                    this.websocket.onopen = function () {
                        resolve(true);
                    };
                    this.websocket.onerror = function () {
                        resolve(false);
                    };
                }));
            }
            // Hangup
            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
            this.websocket.close(1000);
        });
    }
}

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$d = new Logger(version$3);
// A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.
class StaticJsonRpcProvider extends JsonRpcProvider {
    detectNetwork() {
        const _super = Object.create(null, {
            detectNetwork: { get: () => super.detectNetwork }
        });
        return __awaiter$3(this, void 0, void 0, function* () {
            let network = this.network;
            if (network == null) {
                network = yield _super.detectNetwork.call(this);
                if (!network) {
                    logger$d.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
                }
                // If still not set, set it
                if (this._network == null) {
                    // A static network does not support "any"
                    defineReadOnly(this, "_network", network);
                    this.emit("network", network, null);
                }
            }
            return network;
        });
    }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
    constructor(network, apiKey) {
        logger$d.checkAbstract(new.target, UrlJsonRpcProvider);
        // Normalize the Network and API Key
        network = getStatic(new.target, "getNetwork")(network);
        apiKey = getStatic(new.target, "getApiKey")(apiKey);
        const connection = getStatic(new.target, "getUrl")(network, apiKey);
        super(connection, network);
        if (typeof (apiKey) === "string") {
            defineReadOnly(this, "apiKey", apiKey);
        }
        else if (apiKey != null) {
            Object.keys(apiKey).forEach((key) => {
                defineReadOnly(this, key, apiKey[key]);
            });
        }
    }
    _startPending() {
        logger$d.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
        return false;
    }
    getSigner(address) {
        return logger$d.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
    }
    listAccounts() {
        return Promise.resolve([]);
    }
    // Return a defaultApiKey if null, otherwise validate the API key
    static getApiKey(apiKey) {
        return apiKey;
    }
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    static getUrl(network, apiKey) {
        return logger$d.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
            operation: "getUrl"
        });
    }
}

const logger$c = new Logger(version$3);
// This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io
const defaultApiKey$3 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends WebSocketProvider {
    constructor(network, apiKey) {
        const provider = new AlchemyProvider(network, apiKey);
        const url = provider.connection.url.replace(/^http/i, "ws")
            .replace(".alchemyapi.", ".ws.alchemyapi.");
        super(url, provider.network);
        defineReadOnly(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey$3);
    }
}
class AlchemyProvider extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        if (apiKey == null) {
            return defaultApiKey$3;
        }
        if (apiKey && typeof (apiKey) !== "string") {
            logger$c.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
            case "homestead":
                host = "eth-mainnet.alchemyapi.io/v2/";
                break;
            case "ropsten":
                host = "eth-ropsten.alchemyapi.io/v2/";
                break;
            case "rinkeby":
                host = "eth-rinkeby.alchemyapi.io/v2/";
                break;
            case "goerli":
                host = "eth-goerli.alchemyapi.io/v2/";
                break;
            case "kovan":
                host = "eth-kovan.alchemyapi.io/v2/";
                break;
            case "matic":
                host = "polygon-mainnet.g.alchemy.com/v2/";
                break;
            case "maticmum":
                host = "polygon-mumbai.g.alchemy.com/v2/";
                break;
            case "arbitrum":
                host = "arb-mainnet.g.alchemy.com/v2/";
                break;
            case "arbitrum-rinkeby":
                host = "arb-rinkeby.g.alchemy.com/v2/";
                break;
            case "optimism":
                host = "opt-mainnet.g.alchemy.com/v2/";
                break;
            case "optimism-kovan":
                host = "opt-kovan.g.alchemy.com/v2/";
                break;
            default:
                logger$c.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
            allowGzip: true,
            url: ("https:/" + "/" + host + apiKey),
            throttleCallback: (attempt, url) => {
                if (apiKey === defaultApiKey$3) {
                    showThrottleMessage();
                }
                return Promise.resolve(true);
            }
        };
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey$3);
    }
}

const logger$b = new Logger(version$3);
const defaultApiKey$2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
    switch (name) {
        case "homestead":
            return "rpc.ankr.com/eth/";
        case "ropsten":
            return "rpc.ankr.com/eth_ropsten/";
        case "rinkeby":
            return "rpc.ankr.com/eth_rinkeby/";
        case "goerli":
            return "rpc.ankr.com/eth_goerli/";
        case "matic":
            return "rpc.ankr.com/polygon/";
        case "arbitrum":
            return "rpc.ankr.com/arbitrum/";
    }
    return logger$b.throwArgumentError("unsupported network", "name", name);
}
class AnkrProvider extends UrlJsonRpcProvider {
    isCommunityResource() {
        return (this.apiKey === defaultApiKey$2);
    }
    static getApiKey(apiKey) {
        if (apiKey == null) {
            return defaultApiKey$2;
        }
        return apiKey;
    }
    static getUrl(network, apiKey) {
        if (apiKey == null) {
            apiKey = defaultApiKey$2;
        }
        const connection = {
            allowGzip: true,
            url: ("https:/\/" + getHost(network.name) + apiKey),
            throttleCallback: (attempt, url) => {
                if (apiKey.apiKey === defaultApiKey$2) {
                    showThrottleMessage();
                }
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$a = new Logger(version$3);
class CloudflareProvider extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
        if (apiKey != null) {
            logger$a.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
            case "homestead":
                host = "https://cloudflare-eth.com/";
                break;
            default:
                logger$a.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: { get: () => super.perform }
        });
        return __awaiter$2(this, void 0, void 0, function* () {
            // The Cloudflare provider does not support eth_blockNumber,
            // so we get the latest block and pull it from that
            if (method === "getBlockNumber") {
                const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
                return block.number;
            }
            return _super.perform.call(this, method, params);
        });
    }
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$9 = new Logger(version$3);
// The transaction has already been sanitized by the calls in Provider
function getTransactionPostData(transaction) {
    const result = {};
    for (let key in transaction) {
        if (transaction[key] == null) {
            continue;
        }
        let value = transaction[key];
        if (key === "type" && value === 0) {
            continue;
        }
        // Quantity-types require no leading zero, unless 0
        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
            value = hexValue(hexlify(value));
        }
        else if (key === "accessList") {
            value = "[" + accessListify(value).map((set) => {
                return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
            }).join(",") + "]";
        }
        else {
            value = hexlify(value);
        }
        result[key] = value;
    }
    return result;
}
function getResult(result) {
    // getLogs, getHistory have weird success responses
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        return result.result;
    }
    if (result.status != 1 || result.message != "OK") {
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
            error.throttleRetry = true;
        }
        throw error;
    }
    return result.result;
}
function getJsonResult(result) {
    // This response indicates we are being throttled
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        const error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
    }
    if (result.jsonrpc != "2.0") {
        // @TODO: not any
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
    }
    if (result.error) {
        // @TODO: not any
        const error = new Error(result.error.message || "unknown error");
        if (result.error.code) {
            error.code = result.error.code;
        }
        if (result.error.data) {
            error.data = result.error.data;
        }
        throw error;
    }
    return result.result;
}
// The blockTag was normalized as a string by the Provider pre-perform operations
function checkLogTag(blockTag) {
    if (blockTag === "pending") {
        throw new Error("pending not supported");
    }
    if (blockTag === "latest") {
        return blockTag;
    }
    return parseInt(blockTag.substring(2), 16);
}
const defaultApiKey$1 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError(method, error, transaction) {
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
        const e = error.error;
        // Etherscan keeps changing their string
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
            // Etherscan prefixes the data like "Reverted 0x1234"
            let data = e.data;
            if (data) {
                data = "0x" + data.replace(/^.*0x/i, "");
            }
            if (isHexString(data)) {
                return data;
            }
            logger$9.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
                error, data: "0x"
            });
        }
    }
    // Get the message from any nested error structure
    let message = error.message;
    if (error.code === Logger.errors.SERVER_ERROR) {
        if (error.error && typeof (error.error.message) === "string") {
            message = error.error.message;
        }
        else if (typeof (error.body) === "string") {
            message = error.body;
        }
        else if (typeof (error.responseText) === "string") {
            message = error.responseText;
        }
    }
    message = (message || "").toLowerCase();
    // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"
    if (message.match(/insufficient funds/)) {
        logger$9.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
            error, method, transaction
        });
    }
    // "Transaction with the same hash was already imported."
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
        logger$9.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
            error, method, transaction
        });
    }
    // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."
    if (message.match(/another transaction with same nonce/)) {
        logger$9.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
            error, method, transaction
        });
    }
    if (message.match(/execution failed due to an exception|execution reverted/)) {
        logger$9.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error, method, transaction
        });
    }
    throw error;
}
class EtherscanProvider extends BaseProvider {
    constructor(network, apiKey) {
        super(network);
        defineReadOnly(this, "baseUrl", this.getBaseUrl());
        defineReadOnly(this, "apiKey", apiKey || defaultApiKey$1);
    }
    getBaseUrl() {
        switch (this.network ? this.network.name : "invalid") {
            case "homestead":
                return "https:/\/api.etherscan.io";
            case "ropsten":
                return "https:/\/api-ropsten.etherscan.io";
            case "rinkeby":
                return "https:/\/api-rinkeby.etherscan.io";
            case "kovan":
                return "https:/\/api-kovan.etherscan.io";
            case "goerli":
                return "https:/\/api-goerli.etherscan.io";
            case "optimism":
                return "https:/\/api-optimistic.etherscan.io";
        }
        return logger$9.throwArgumentError("unsupported network", "network", this.network.name);
    }
    getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key) => {
            const value = params[key];
            if (value != null) {
                accum += `&${key}=${value}`;
            }
            return accum;
        }, "");
        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : "");
        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
    }
    getPostUrl() {
        return `${this.baseUrl}/api`;
    }
    getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    }
    fetch(module, params, post) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const url = (post ? this.getPostUrl() : this.getUrl(module, params));
            const payload = (post ? this.getPostData(module, params) : null);
            const procFunc = (module === "proxy") ? getJsonResult : getResult;
            this.emit("debug", {
                action: "request",
                request: url,
                provider: this
            });
            const connection = {
                url: url,
                throttleSlotInterval: 1000,
                throttleCallback: (attempt, url) => {
                    if (this.isCommunityResource()) {
                        showThrottleMessage();
                    }
                    return Promise.resolve(true);
                }
            };
            let payloadStr = null;
            if (payload) {
                connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
                payloadStr = Object.keys(payload).map((key) => {
                    return `${key}=${payload[key]}`;
                }).join("&");
            }
            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
            this.emit("debug", {
                action: "response",
                request: url,
                response: deepCopy(result),
                provider: this
            });
            return result;
        });
    }
    detectNetwork() {
        return __awaiter$1(this, void 0, void 0, function* () {
            return this.network;
        });
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: { get: () => super.perform }
        });
        return __awaiter$1(this, void 0, void 0, function* () {
            switch (method) {
                case "getBlockNumber":
                    return this.fetch("proxy", { action: "eth_blockNumber" });
                case "getGasPrice":
                    return this.fetch("proxy", { action: "eth_gasPrice" });
                case "getBalance":
                    // Returns base-10 result
                    return this.fetch("account", {
                        action: "balance",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getTransactionCount":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionCount",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getCode":
                    return this.fetch("proxy", {
                        action: "eth_getCode",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getStorageAt":
                    return this.fetch("proxy", {
                        action: "eth_getStorageAt",
                        address: params.address,
                        position: params.position,
                        tag: params.blockTag
                    });
                case "sendTransaction":
                    return this.fetch("proxy", {
                        action: "eth_sendRawTransaction",
                        hex: params.signedTransaction
                    }, true).catch((error) => {
                        return checkError("sendTransaction", error, params.signedTransaction);
                    });
                case "getBlock":
                    if (params.blockTag) {
                        return this.fetch("proxy", {
                            action: "eth_getBlockByNumber",
                            tag: params.blockTag,
                            boolean: (params.includeTransactions ? "true" : "false")
                        });
                    }
                    throw new Error("getBlock by blockHash not implemented");
                case "getTransaction":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionByHash",
                        txhash: params.transactionHash
                    });
                case "getTransactionReceipt":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionReceipt",
                        txhash: params.transactionHash
                    });
                case "call": {
                    if (params.blockTag !== "latest") {
                        throw new Error("EtherscanProvider does not support blockTag for call");
                    }
                    const postData = getTransactionPostData(params.transaction);
                    postData.module = "proxy";
                    postData.action = "eth_call";
                    try {
                        return yield this.fetch("proxy", postData, true);
                    }
                    catch (error) {
                        return checkError("call", error, params.transaction);
                    }
                }
                case "estimateGas": {
                    const postData = getTransactionPostData(params.transaction);
                    postData.module = "proxy";
                    postData.action = "eth_estimateGas";
                    try {
                        return yield this.fetch("proxy", postData, true);
                    }
                    catch (error) {
                        return checkError("estimateGas", error, params.transaction);
                    }
                }
                case "getLogs": {
                    const args = { action: "getLogs" };
                    if (params.filter.fromBlock) {
                        args.fromBlock = checkLogTag(params.filter.fromBlock);
                    }
                    if (params.filter.toBlock) {
                        args.toBlock = checkLogTag(params.filter.toBlock);
                    }
                    if (params.filter.address) {
                        args.address = params.filter.address;
                    }
                    // @TODO: We can handle slightly more complicated logs using the logs API
                    if (params.filter.topics && params.filter.topics.length > 0) {
                        if (params.filter.topics.length > 1) {
                            logger$9.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                        }
                        if (params.filter.topics.length === 1) {
                            const topic0 = params.filter.topics[0];
                            if (typeof (topic0) !== "string" || topic0.length !== 66) {
                                logger$9.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                            }
                            args.topic0 = topic0;
                        }
                    }
                    const logs = yield this.fetch("logs", args);
                    // Cache txHash => blockHash
                    let blocks = {};
                    // Add any missing blockHash to the logs
                    for (let i = 0; i < logs.length; i++) {
                        const log = logs[i];
                        if (log.blockHash != null) {
                            continue;
                        }
                        if (blocks[log.blockNumber] == null) {
                            const block = yield this.getBlock(log.blockNumber);
                            if (block) {
                                blocks[log.blockNumber] = block.hash;
                            }
                        }
                        log.blockHash = blocks[log.blockNumber];
                    }
                    return logs;
                }
                case "getEtherPrice":
                    if (this.network.name !== "homestead") {
                        return 0.0;
                    }
                    return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
            }
            return _super.perform.call(this, method, params);
        });
    }
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    getHistory(addressOrName, startBlock, endBlock) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const params = {
                action: "txlist",
                address: (yield this.resolveName(addressOrName)),
                startblock: ((startBlock == null) ? 0 : startBlock),
                endblock: ((endBlock == null) ? 99999999 : endBlock),
                sort: "asc"
            };
            const result = yield this.fetch("account", params);
            return result.map((tx) => {
                ["contractAddress", "to"].forEach(function (key) {
                    if (tx[key] == "") {
                        delete tx[key];
                    }
                });
                if (tx.creates == null && tx.contractAddress != null) {
                    tx.creates = tx.contractAddress;
                }
                const item = this.formatter.transactionResponse(tx);
                if (tx.timeStamp) {
                    item.timestamp = parseInt(tx.timeStamp);
                }
                return item;
            });
        });
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey$1);
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$8 = new Logger(version$3);
function now() { return (new Date()).getTime(); }
// Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.
function checkNetworks(networks) {
    let result = null;
    for (let i = 0; i < networks.length; i++) {
        const network = networks[i];
        // Null! We do not know our network; bail.
        if (network == null) {
            return null;
        }
        if (result) {
            // Make sure the network matches the previous networks
            if (!(result.name === network.name && result.chainId === network.chainId &&
                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {
                logger$8.throwArgumentError("provider mismatch", "networks", networks);
            }
        }
        else {
            result = network;
        }
    }
    return result;
}
function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    // Odd length; take the middle
    if (values.length % 2) {
        return values[middle];
    }
    // Even length; take the average of the two middle
    const a = values[middle - 1], b = values[middle];
    if (maxDelta != null && Math.abs(a - b) > maxDelta) {
        return null;
    }
    return (a + b) / 2;
}
function serialize(value) {
    if (value === null) {
        return "null";
    }
    else if (typeof (value) === "number" || typeof (value) === "boolean") {
        return JSON.stringify(value);
    }
    else if (typeof (value) === "string") {
        return value;
    }
    else if (BigNumber.isBigNumber(value)) {
        return value.toString();
    }
    else if (Array.isArray(value)) {
        return JSON.stringify(value.map((i) => serialize(i)));
    }
    else if (typeof (value) === "object") {
        const keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map((key) => {
            let v = value[key];
            if (typeof (v) === "function") {
                v = "[function]";
            }
            else {
                v = serialize(v);
            }
            return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof (value));
}
// Next request ID to use for emitting debug info
let nextRid = 1;
function stall(duration) {
    let cancel = null;
    let timer = null;
    let promise = (new Promise((resolve) => {
        cancel = function () {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            resolve();
        };
        timer = setTimeout(cancel, duration);
    }));
    const wait = (func) => {
        promise = promise.then(func);
        return promise;
    };
    function getPromise() {
        return promise;
    }
    return { cancel, getPromise, wait };
}
const ForwardErrors = [
    Logger.errors.CALL_EXCEPTION,
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED,
    Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction",
];
function exposeDebugConfig(config, now) {
    const result = {
        weight: config.weight
    };
    Object.defineProperty(result, "provider", { get: () => config.provider });
    if (config.start) {
        result.start = config.start;
    }
    if (now) {
        result.duration = (now - config.start);
    }
    if (config.done) {
        if (config.error) {
            result.error = config.error;
        }
        else {
            result.result = config.result || null;
        }
    }
    return result;
}
function normalizedTally(normalize, quorum) {
    return function (configs) {
        // Count the votes for each result
        const tally = {};
        configs.forEach((c) => {
            const value = normalize(c.result);
            if (!tally[value]) {
                tally[value] = { count: 0, result: c.result };
            }
            tally[value].count++;
        });
        // Check for a quorum on any given result
        const keys = Object.keys(tally);
        for (let i = 0; i < keys.length; i++) {
            const check = tally[keys[i]];
            if (check.count >= quorum) {
                return check.result;
            }
        }
        // No quroum
        return undefined;
    };
}
function getProcessFunc(provider, method, params) {
    let normalize = serialize;
    switch (method) {
        case "getBlockNumber":
            // Return the median value, unless there is (median + 1) is also
            // present, in which case that is probably true and the median
            // is going to be stale soon. In the event of a malicious node,
            // the lie will be true soon enough.
            return function (configs) {
                const values = configs.map((c) => c.result);
                // Get the median block number
                let blockNumber = median(configs.map((c) => c.result), 2);
                if (blockNumber == null) {
                    return undefined;
                }
                blockNumber = Math.ceil(blockNumber);
                // If the next block height is present, its prolly safe to use
                if (values.indexOf(blockNumber + 1) >= 0) {
                    blockNumber++;
                }
                // Don't ever roll back the blockNumber
                if (blockNumber >= provider._highestBlockNumber) {
                    provider._highestBlockNumber = blockNumber;
                }
                return provider._highestBlockNumber;
            };
        case "getGasPrice":
            // Return the middle (round index up) value, similar to median
            // but do not average even entries and choose the higher.
            // Malicious actors must compromise 50% of the nodes to lie.
            return function (configs) {
                const values = configs.map((c) => c.result);
                values.sort();
                return values[Math.floor(values.length / 2)];
            };
        case "getEtherPrice":
            // Returns the median price. Malicious actors must compromise at
            // least 50% of the nodes to lie (in a meaningful way).
            return function (configs) {
                return median(configs.map((c) => c.result));
            };
        // No additional normalizing required; serialize is enough
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getTransaction":
        case "getTransactionReceipt":
            normalize = function (tx) {
                if (tx == null) {
                    return null;
                }
                tx = shallowCopy(tx);
                tx.confirmations = -1;
                return serialize(tx);
            };
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getBlock":
            // We drop the confirmations from transactions as it is approximate
            if (params.includeTransactions) {
                normalize = function (block) {
                    if (block == null) {
                        return null;
                    }
                    block = shallowCopy(block);
                    block.transactions = block.transactions.map((tx) => {
                        tx = shallowCopy(tx);
                        tx.confirmations = -1;
                        return tx;
                    });
                    return serialize(block);
                };
            }
            else {
                normalize = function (block) {
                    if (block == null) {
                        return null;
                    }
                    return serialize(block);
                };
            }
            break;
        default:
            throw new Error("unknown method: " + method);
    }
    // Return the result if and only if the expected quorum is
    // satisfied and agreed upon for the final result.
    return normalizedTally(normalize, provider.quorum);
}
// If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.
function waitForSync(config, blockNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = (config.provider);
        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {
            return provider;
        }
        return poll(() => {
            return new Promise((resolve, reject) => {
                setTimeout(function () {
                    // We are synced
                    if (provider.blockNumber >= blockNumber) {
                        return resolve(provider);
                    }
                    // We're done; just quit
                    if (config.cancelled) {
                        return resolve(null);
                    }
                    // Try again, next block
                    return resolve(undefined);
                }, 0);
            });
        }, { oncePoll: provider });
    });
}
function getRunner(config, currentBlockNumber, method, params) {
    return __awaiter(this, void 0, void 0, function* () {
        let provider = config.provider;
        switch (method) {
            case "getBlockNumber":
            case "getGasPrice":
                return provider[method]();
            case "getEtherPrice":
                if (provider.getEtherPrice) {
                    return provider.getEtherPrice();
                }
                break;
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
                if (params.blockTag && isHexString(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider[method](params.address, params.blockTag || "latest");
            case "getStorageAt":
                if (params.blockTag && isHexString(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
            case "getBlock":
                if (params.blockTag && isHexString(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider[(params.includeTransactions ? "getBlockWithTransactions" : "getBlock")](params.blockTag || params.blockHash);
            case "call":
            case "estimateGas":
                if (params.blockTag && isHexString(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider[method](params.transaction);
            case "getTransaction":
            case "getTransactionReceipt":
                return provider[method](params.transactionHash);
            case "getLogs": {
                let filter = params.filter;
                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider.getLogs(filter);
            }
        }
        return logger$8.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
            method: method,
            params: params
        });
    });
}
class FallbackProvider extends BaseProvider {
    constructor(providers, quorum) {
        if (providers.length === 0) {
            logger$8.throwArgumentError("missing providers", "providers", providers);
        }
        const providerConfigs = providers.map((configOrProvider, index) => {
            if (Provider.isProvider(configOrProvider)) {
                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
                const priority = 1;
                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
            }
            const config = shallowCopy(configOrProvider);
            if (config.priority == null) {
                config.priority = 1;
            }
            if (config.stallTimeout == null) {
                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
            }
            if (config.weight == null) {
                config.weight = 1;
            }
            const weight = config.weight;
            if (weight % 1 || weight > 512 || weight < 1) {
                logger$8.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
            }
            return Object.freeze(config);
        });
        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);
        if (quorum == null) {
            quorum = total / 2;
        }
        else if (quorum > total) {
            logger$8.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        // Are all providers' networks are known
        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));
        // Not all networks are known; we must stall
        if (networkOrReady == null) {
            networkOrReady = new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.detectNetwork().then(resolve, reject);
                }, 0);
            });
        }
        super(networkOrReady);
        // Preserve a copy, so we do not get mutated
        defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
        defineReadOnly(this, "quorum", quorum);
        this._highestBlockNumber = -1;
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
            return checkNetworks(networks);
        });
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sending transactions is special; always broadcast it to all backends
            if (method === "sendTransaction") {
                const results = yield Promise.all(this.providerConfigs.map((c) => {
                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {
                        return result.hash;
                    }, (error) => {
                        return error;
                    });
                }));
                // Any success is good enough (other errors are likely "already seen" errors
                for (let i = 0; i < results.length; i++) {
                    const result = results[i];
                    if (typeof (result) === "string") {
                        return result;
                    }
                }
                // They were all an error; pick the first error
                throw results[0];
            }
            // We need to make sure we are in sync with our backends, so we need
            // to know this before we can make a lot of calls
            if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
                yield this.getBlockNumber();
            }
            const processFunc = getProcessFunc(this, method, params);
            // Shuffle the providers and then sort them by their priority; we
            // shallowCopy them since we will store the result in them too
            const configs = shuffled(this.providerConfigs.map(shallowCopy));
            configs.sort((a, b) => (a.priority - b.priority));
            const currentBlockNumber = this._highestBlockNumber;
            let i = 0;
            let first = true;
            while (true) {
                const t0 = now();
                // Compute the inflight weight (exclude anything past)
                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))
                    .reduce((accum, c) => (accum + c.weight), 0);
                // Start running enough to meet quorum
                while (inflightWeight < this.quorum && i < configs.length) {
                    const config = configs[i++];
                    const rid = nextRid++;
                    config.start = now();
                    config.staller = stall(config.stallTimeout);
                    config.staller.wait(() => { config.staller = null; });
                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
                        config.done = true;
                        config.result = result;
                        if (this.listenerCount("debug")) {
                            this.emit("debug", {
                                action: "request",
                                rid: rid,
                                backend: exposeDebugConfig(config, now()),
                                request: { method: method, params: deepCopy(params) },
                                provider: this
                            });
                        }
                    }, (error) => {
                        config.done = true;
                        config.error = error;
                        if (this.listenerCount("debug")) {
                            this.emit("debug", {
                                action: "request",
                                rid: rid,
                                backend: exposeDebugConfig(config, now()),
                                request: { method: method, params: deepCopy(params) },
                                provider: this
                            });
                        }
                    });
                    if (this.listenerCount("debug")) {
                        this.emit("debug", {
                            action: "request",
                            rid: rid,
                            backend: exposeDebugConfig(config, null),
                            request: { method: method, params: deepCopy(params) },
                            provider: this
                        });
                    }
                    inflightWeight += config.weight;
                }
                // Wait for anything meaningful to finish or stall out
                const waiting = [];
                configs.forEach((c) => {
                    if (c.done || !c.runner) {
                        return;
                    }
                    waiting.push(c.runner);
                    if (c.staller) {
                        waiting.push(c.staller.getPromise());
                    }
                });
                if (waiting.length) {
                    yield Promise.race(waiting);
                }
                // Check the quorum and process the results; the process function
                // may additionally decide the quorum is not met
                const results = configs.filter((c) => (c.done && c.error == null));
                if (results.length >= this.quorum) {
                    const result = processFunc(results);
                    if (result !== undefined) {
                        // Shut down any stallers
                        configs.forEach(c => {
                            if (c.staller) {
                                c.staller.cancel();
                            }
                            c.cancelled = true;
                        });
                        return result;
                    }
                    if (!first) {
                        yield stall(100).getPromise();
                    }
                    first = false;
                }
                // No result, check for errors that should be forwarded
                const errors = configs.reduce((accum, c) => {
                    if (!c.done || c.error == null) {
                        return accum;
                    }
                    const code = (c.error).code;
                    if (ForwardErrors.indexOf(code) >= 0) {
                        if (!accum[code]) {
                            accum[code] = { error: c.error, weight: 0 };
                        }
                        accum[code].weight += c.weight;
                    }
                    return accum;
                }, ({}));
                Object.keys(errors).forEach((errorCode) => {
                    const tally = errors[errorCode];
                    if (tally.weight < this.quorum) {
                        return;
                    }
                    // Shut down any stallers
                    configs.forEach(c => {
                        if (c.staller) {
                            c.staller.cancel();
                        }
                        c.cancelled = true;
                    });
                    const e = (tally.error);
                    const props = {};
                    ForwardProperties.forEach((name) => {
                        if (e[name] == null) {
                            return;
                        }
                        props[name] = e[name];
                    });
                    logger$8.throwError(e.reason || e.message, errorCode, props);
                });
                // All configs have run to completion; we will never get more data
                if (configs.filter((c) => !c.done).length === 0) {
                    break;
                }
            }
            // Shut down any stallers; shouldn't be any
            configs.forEach(c => {
                if (c.staller) {
                    c.staller.cancel();
                }
                c.cancelled = true;
            });
            return logger$8.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
                method: method,
                params: params,
                //results: configs.map((c) => c.result),
                //errors: configs.map((c) => c.error),
                results: configs.map((c) => exposeDebugConfig(c)),
                provider: this
            });
        });
    }
}

const IpcProvider = null;

const logger$7 = new Logger(version$3);
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends WebSocketProvider {
    constructor(network, apiKey) {
        const provider = new InfuraProvider(network, apiKey);
        const connection = provider.connection;
        if (connection.password) {
            logger$7.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "InfuraProvider.getWebSocketProvider()"
            });
        }
        const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, network);
        defineReadOnly(this, "apiKey", provider.projectId);
        defineReadOnly(this, "projectId", provider.projectId);
        defineReadOnly(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
        return (this.projectId === defaultProjectId);
    }
}
class InfuraProvider extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        const apiKeyObj = {
            apiKey: defaultProjectId,
            projectId: defaultProjectId,
            projectSecret: null
        };
        if (apiKey == null) {
            return apiKeyObj;
        }
        if (typeof (apiKey) === "string") {
            apiKeyObj.projectId = apiKey;
        }
        else if (apiKey.projectSecret != null) {
            logger$7.assertArgument((typeof (apiKey.projectId) === "string"), "projectSecret requires a projectId", "projectId", apiKey.projectId);
            logger$7.assertArgument((typeof (apiKey.projectSecret) === "string"), "invalid projectSecret", "projectSecret", "[REDACTED]");
            apiKeyObj.projectId = apiKey.projectId;
            apiKeyObj.projectSecret = apiKey.projectSecret;
        }
        else if (apiKey.projectId) {
            apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
            case "homestead":
                host = "mainnet.infura.io";
                break;
            case "ropsten":
                host = "ropsten.infura.io";
                break;
            case "rinkeby":
                host = "rinkeby.infura.io";
                break;
            case "kovan":
                host = "kovan.infura.io";
                break;
            case "goerli":
                host = "goerli.infura.io";
                break;
            case "matic":
                host = "polygon-mainnet.infura.io";
                break;
            case "maticmum":
                host = "polygon-mumbai.infura.io";
                break;
            case "optimism":
                host = "optimism-mainnet.infura.io";
                break;
            case "optimism-kovan":
                host = "optimism-kovan.infura.io";
                break;
            case "arbitrum":
                host = "arbitrum-mainnet.infura.io";
                break;
            case "arbitrum-rinkeby":
                host = "arbitrum-rinkeby.infura.io";
                break;
            default:
                logger$7.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        const connection = {
            allowGzip: true,
            url: ("https:/" + "/" + host + "/v3/" + apiKey.projectId),
            throttleCallback: (attempt, url) => {
                if (apiKey.projectId === defaultProjectId) {
                    showThrottleMessage();
                }
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
    isCommunityResource() {
        return (this.projectId === defaultProjectId);
    }
}

// Experimental
class JsonRpcBatchProvider extends JsonRpcProvider {
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
            this._pendingBatch = [];
        }
        const inflightRequest = { request, resolve: null, reject: null };
        const promise = new Promise((resolve, reject) => {
            inflightRequest.resolve = resolve;
            inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
            // Schedule batch for next event loop + short duration
            this._pendingBatchAggregator = setTimeout(() => {
                // Get teh current batch and clear it, so new requests
                // go into the next batch
                const batch = this._pendingBatch;
                this._pendingBatch = null;
                this._pendingBatchAggregator = null;
                // Get the request as an array of requests
                const request = batch.map((inflight) => inflight.request);
                this.emit("debug", {
                    action: "requestBatch",
                    request: deepCopy(request),
                    provider: this
                });
                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {
                    this.emit("debug", {
                        action: "response",
                        request: request,
                        response: result,
                        provider: this
                    });
                    // For each result, feed it to the correct Promise, depending
                    // on whether it was a success or error
                    batch.forEach((inflightRequest, index) => {
                        const payload = result[index];
                        if (payload.error) {
                            const error = new Error(payload.error.message);
                            error.code = payload.error.code;
                            error.data = payload.error.data;
                            inflightRequest.reject(error);
                        }
                        else {
                            inflightRequest.resolve(payload.result);
                        }
                    });
                }, (error) => {
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: request,
                        provider: this
                    });
                    batch.forEach((inflightRequest) => {
                        inflightRequest.reject(error);
                    });
                });
            }, 10);
        }
        return promise;
    }
}

/* istanbul ignore file */
const logger$6 = new Logger(version$3);
// Special API key provided by Nodesmith for ethers.js
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
        if (apiKey && typeof (apiKey) !== "string") {
            logger$6.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey;
    }
    static getUrl(network, apiKey) {
        logger$6.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let host = null;
        switch (network.name) {
            case "homestead":
                host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
                break;
            case "ropsten":
                host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
                break;
            case "rinkeby":
                host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
                break;
            case "goerli":
                host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
                break;
            case "kovan":
                host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
                break;
            default:
                logger$6.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return (host + "?apiKey=" + apiKey);
    }
}

const logger$5 = new Logger(version$3);
// These are load-balancer-based application IDs
const defaultApplicationIds = {
    homestead: "6004bcd10040261633ade990",
    ropsten: "6004bd4d0040261633ade991",
    rinkeby: "6004bda20040261633ade994",
    goerli: "6004bd860040261633ade992",
};
class PocketProvider extends UrlJsonRpcProvider {
    constructor(network, apiKey) {
        // We need a bit of creativity in the constructor because
        // Pocket uses different default API keys based on the network
        if (apiKey == null) {
            const n = getStatic(new.target, "getNetwork")(network);
            if (n) {
                const applicationId = defaultApplicationIds[n.name];
                if (applicationId) {
                    apiKey = {
                        applicationId: applicationId,
                        loadBalancer: true
                    };
                }
            }
            // If there was any issue above, we don't know this network
            if (apiKey == null) {
                logger$5.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
            }
        }
        super(network, apiKey);
    }
    static getApiKey(apiKey) {
        // Most API Providers allow null to get the default configuration, but
        // Pocket requires the network to decide the default provider, so we
        // rely on hijacking the constructor to add a sensible default for us
        if (apiKey == null) {
            logger$5.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
        }
        const apiKeyObj = {
            applicationId: null,
            loadBalancer: false,
            applicationSecretKey: null
        };
        // Parse applicationId and applicationSecretKey
        if (typeof (apiKey) === "string") {
            apiKeyObj.applicationId = apiKey;
        }
        else if (apiKey.applicationSecretKey != null) {
            logger$5.assertArgument((typeof (apiKey.applicationId) === "string"), "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
            logger$5.assertArgument((typeof (apiKey.applicationSecretKey) === "string"), "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
        }
        else if (apiKey.applicationId) {
            logger$5.assertArgument((typeof (apiKey.applicationId) === "string"), "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
        }
        else {
            logger$5.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
            case "homestead":
                host = "eth-mainnet.gateway.pokt.network";
                break;
            case "ropsten":
                host = "eth-ropsten.gateway.pokt.network";
                break;
            case "rinkeby":
                host = "eth-rinkeby.gateway.pokt.network";
                break;
            case "goerli":
                host = "eth-goerli.gateway.pokt.network";
                break;
            default:
                logger$5.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        let url = null;
        if (apiKey.loadBalancer) {
            url = `https:/\/${host}/v1/lb/${apiKey.applicationId}`;
        }
        else {
            url = `https:/\/${host}/v1/${apiKey.applicationId}`;
        }
        const connection = { url };
        // Initialize empty headers
        connection.headers = {};
        // Apply application secret key
        if (apiKey.applicationSecretKey != null) {
            connection.user = "";
            connection.password = apiKey.applicationSecretKey;
        }
        return connection;
    }
    isCommunityResource() {
        return (this.applicationId === defaultApplicationIds[this.network.name]);
    }
}

const logger$4 = new Logger(version$3);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function (method, params) {
        const request = {
            method: method,
            params: params,
            id: (_nextId++),
            jsonrpc: "2.0"
        };
        return new Promise((resolve, reject) => {
            this.emit("debug", {
                action: "request",
                fetcher,
                request: deepCopy(request),
                provider: this
            });
            sendFunc(request, (error, response) => {
                if (error) {
                    this.emit("debug", {
                        action: "response",
                        fetcher,
                        error,
                        request,
                        provider: this
                    });
                    return reject(error);
                }
                this.emit("debug", {
                    action: "response",
                    fetcher,
                    request,
                    response,
                    provider: this
                });
                if (response.error) {
                    const error = new Error(response.error.message);
                    error.code = response.error.code;
                    error.data = response.error.data;
                    return reject(error);
                }
                resolve(response.result);
            });
        });
    };
}
function buildEip1193Fetcher(provider) {
    return function (method, params) {
        if (params == null) {
            params = [];
        }
        const request = { method, params };
        this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: deepCopy(request),
            provider: this
        });
        return provider.request(request).then((response) => {
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                response,
                provider: this
            });
            return response;
        }, (error) => {
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                error,
                provider: this
            });
            throw error;
        });
    };
}
class Web3Provider extends JsonRpcProvider {
    constructor(provider, network) {
        if (provider == null) {
            logger$4.throwArgumentError("missing provider", "provider", provider);
        }
        let path = null;
        let jsonRpcFetchFunc = null;
        let subprovider = null;
        if (typeof (provider) === "function") {
            path = "unknown:";
            jsonRpcFetchFunc = provider;
        }
        else {
            path = provider.host || provider.path || "";
            if (!path && provider.isMetaMask) {
                path = "metamask";
            }
            subprovider = provider;
            if (provider.request) {
                if (path === "") {
                    path = "eip-1193:";
                }
                jsonRpcFetchFunc = buildEip1193Fetcher(provider);
            }
            else if (provider.sendAsync) {
                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
            }
            else if (provider.send) {
                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
            }
            else {
                logger$4.throwArgumentError("unsupported provider", "provider", provider);
            }
            if (!path) {
                path = "unknown:";
            }
        }
        super(path, network);
        defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        defineReadOnly(this, "provider", subprovider);
    }
    send(method, params) {
        return this.jsonRpcFetchFunc(method, params);
    }
}

const logger$3 = new Logger(version$3);
////////////////////////
// Helper Functions
function getDefaultProvider(network, options) {
    if (network == null) {
        network = "homestead";
    }
    // If passed a URL, figure out the right type of provider based on the scheme
    if (typeof (network) === "string") {
        // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
        // Handle http and ws (and their secure variants)
        const match = network.match(/^(ws|http)s?:/i);
        if (match) {
            switch (match[1].toLowerCase()) {
                case "http":
                case "https":
                    return new JsonRpcProvider(network);
                case "ws":
                case "wss":
                    return new WebSocketProvider(network);
                default:
                    logger$3.throwArgumentError("unsupported URL scheme", "network", network);
            }
        }
    }
    const n = getNetwork(network);
    if (!n || !n._defaultProvider) {
        logger$3.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
            operation: "getDefaultProvider",
            network: network
        });
    }
    return n._defaultProvider({
        FallbackProvider,
        AlchemyProvider,
        AnkrProvider,
        CloudflareProvider,
        EtherscanProvider,
        InfuraProvider,
        JsonRpcProvider,
        NodesmithProvider,
        PocketProvider,
        Web3Provider,
        IpcProvider,
    }, options);
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Provider: Provider,
    BaseProvider: BaseProvider,
    Resolver: Resolver,
    UrlJsonRpcProvider: UrlJsonRpcProvider,
    FallbackProvider: FallbackProvider,
    AlchemyProvider: AlchemyProvider,
    AlchemyWebSocketProvider: AlchemyWebSocketProvider,
    AnkrProvider: AnkrProvider,
    CloudflareProvider: CloudflareProvider,
    EtherscanProvider: EtherscanProvider,
    InfuraProvider: InfuraProvider,
    InfuraWebSocketProvider: InfuraWebSocketProvider,
    JsonRpcProvider: JsonRpcProvider,
    JsonRpcBatchProvider: JsonRpcBatchProvider,
    NodesmithProvider: NodesmithProvider,
    PocketProvider: PocketProvider,
    StaticJsonRpcProvider: StaticJsonRpcProvider,
    Web3Provider: Web3Provider,
    WebSocketProvider: WebSocketProvider,
    IpcProvider: IpcProvider,
    JsonRpcSigner: JsonRpcSigner,
    getDefaultProvider: getDefaultProvider,
    getNetwork: getNetwork,
    isCommunityResource: isCommunityResource,
    isCommunityResourcable: isCommunityResourcable,
    showThrottleMessage: showThrottleMessage,
    Formatter: Formatter
});

const version$2 = "solidity/5.6.1";

const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$2 = new Logger(version$2);
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return zeroPad(value, 32);
            }
            return arrayify(value);
        case "string":
            return toUtf8Bytes(value);
        case "bytes":
            return arrayify(value);
        case "bool":
            value = (value ? "0x01" : "0x00");
            if (isArray) {
                return zeroPad(value, 32);
            }
            return arrayify(value);
    }
    let match = type.match(regexNumber);
    if (match) {
        //let signed = (match[1] === "int")
        let size = parseInt(match[2] || "256");
        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {
            logger$2.throwArgumentError("invalid number type", "type", type);
        }
        if (isArray) {
            size = 256;
        }
        value = BigNumber.from(value).toTwos(size);
        return zeroPad(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
        const size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) {
            logger$2.throwArgumentError("invalid bytes type", "type", type);
        }
        if (arrayify(value).byteLength !== size) {
            logger$2.throwArgumentError(`invalid value for ${type}`, "value", value);
        }
        if (isArray) {
            return arrayify((value + Zeros).substring(0, 66));
        }
        return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
        const baseType = match[1];
        const count = parseInt(match[2] || String(value.length));
        if (count != value.length) {
            logger$2.throwArgumentError(`invalid array length for ${type}`, "value", value);
        }
        const result = [];
        value.forEach(function (value) {
            result.push(_pack(baseType, value, true));
        });
        return concat(result);
    }
    return logger$2.throwArgumentError("invalid type", "type", type);
}
// @TODO: Array Enum
function pack(types, values) {
    if (types.length != values.length) {
        logger$2.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    }
    const tight = [];
    types.forEach(function (type, index) {
        tight.push(_pack(type, values[index]));
    });
    return hexlify(concat(tight));
}
function keccak256(types, values) {
    return keccak256$1(pack(types, values));
}
function sha256(types, values) {
    return sha256$1(pack(types, values));
}

const version$1 = "units/5.6.1";

const logger$1 = new Logger(version$1);
const names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether",
];
// Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.
function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === "." || value === "-.") {
        logger$1.throwArgumentError("invalid value", "value", value);
    }
    // Make sure we have at least one whole digit (0 if none)
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
    }
    // Make sure we have at least 1 whole digit with no leading zeros
    while (whole.substring(0, 1) === "0") {
        whole = whole.substring(1);
    }
    if (whole === "") {
        whole = "0";
    }
    let suffix = "";
    if (comps.length === 2) {
        suffix = "." + (comps[1] || "0");
    }
    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
        suffix = suffix.substring(0, suffix.length - 1);
    }
    const formatted = [];
    while (whole.length) {
        if (whole.length <= 3) {
            formatted.unshift(whole);
            break;
        }
        else {
            const index = whole.length - 3;
            formatted.unshift(whole.substring(index));
            whole = whole.substring(0, index);
        }
    }
    return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
    if (typeof (unitName) === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) {
            unitName = 3 * index;
        }
    }
    return formatFixed(value, (unitName != null) ? unitName : 18);
}
function parseUnits(value, unitName) {
    if (typeof (value) !== "string") {
        logger$1.throwArgumentError("value must be a string", "value", value);
    }
    if (typeof (unitName) === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) {
            unitName = 3 * index;
        }
    }
    return parseFixed(value, (unitName != null) ? unitName : 18);
}
function formatEther(wei) {
    return formatUnits(wei, 18);
}
function parseEther(ether) {
    return parseUnits(ether, 18);
}

var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbiCoder: AbiCoder,
    defaultAbiCoder: defaultAbiCoder,
    Fragment: Fragment,
    ConstructorFragment: ConstructorFragment,
    ErrorFragment: ErrorFragment,
    EventFragment: EventFragment,
    FunctionFragment: FunctionFragment,
    ParamType: ParamType,
    FormatTypes: FormatTypes,
    checkResultErrors: checkResultErrors,
    Logger: Logger,
    RLP: index$3,
    _fetchData: _fetchData,
    fetchJson: fetchJson,
    poll: poll,
    checkProperties: checkProperties,
    deepCopy: deepCopy,
    defineReadOnly: defineReadOnly,
    getStatic: getStatic,
    resolveProperties: resolveProperties,
    shallowCopy: shallowCopy,
    arrayify: arrayify,
    concat: concat,
    stripZeros: stripZeros,
    zeroPad: zeroPad,
    isBytes: isBytes,
    isBytesLike: isBytesLike,
    defaultPath: defaultPath,
    HDNode: HDNode,
    SigningKey: SigningKey,
    Interface: Interface,
    LogDescription: LogDescription,
    TransactionDescription: TransactionDescription,
    base58: Base58,
    base64: index$1,
    hexlify: hexlify,
    isHexString: isHexString,
    hexConcat: hexConcat,
    hexStripZeros: hexStripZeros,
    hexValue: hexValue,
    hexZeroPad: hexZeroPad,
    hexDataLength: hexDataLength,
    hexDataSlice: hexDataSlice,
    nameprep: nameprep,
    _toEscapedUtf8String: _toEscapedUtf8String,
    toUtf8Bytes: toUtf8Bytes,
    toUtf8CodePoints: toUtf8CodePoints,
    toUtf8String: toUtf8String,
    Utf8ErrorFuncs: Utf8ErrorFuncs,
    formatBytes32String: formatBytes32String,
    parseBytes32String: parseBytes32String,
    dnsEncode: dnsEncode,
    hashMessage: hashMessage,
    namehash: namehash,
    isValidName: isValidName,
    id: id,
    _TypedDataEncoder: TypedDataEncoder,
    getAddress: getAddress,
    getIcapAddress: getIcapAddress,
    getContractAddress: getContractAddress,
    getCreate2Address: getCreate2Address,
    isAddress: isAddress,
    formatEther: formatEther,
    parseEther: parseEther,
    formatUnits: formatUnits,
    parseUnits: parseUnits,
    commify: commify,
    computeHmac: computeHmac,
    keccak256: keccak256$1,
    ripemd160: ripemd160,
    sha256: sha256$1,
    sha512: sha512,
    randomBytes: randomBytes,
    shuffled: shuffled,
    solidityPack: pack,
    solidityKeccak256: keccak256,
    soliditySha256: sha256,
    splitSignature: splitSignature,
    joinSignature: joinSignature,
    accessListify: accessListify,
    parseTransaction: parse,
    serializeTransaction: serialize$1,
    get TransactionTypes () { return TransactionTypes; },
    getJsonWalletAddress: getJsonWalletAddress,
    computeAddress: computeAddress,
    recoverAddress: recoverAddress,
    computePublicKey: computePublicKey,
    recoverPublicKey: recoverPublicKey,
    verifyMessage: verifyMessage,
    verifyTypedData: verifyTypedData,
    getAccountPath: getAccountPath,
    mnemonicToEntropy: mnemonicToEntropy,
    entropyToMnemonic: entropyToMnemonic,
    isValidMnemonic: isValidMnemonic,
    mnemonicToSeed: mnemonicToSeed,
    get SupportedAlgorithm () { return SupportedAlgorithm; },
    get UnicodeNormalizationForm () { return UnicodeNormalizationForm; },
    get Utf8ErrorReason () { return Utf8ErrorReason; },
    Indexed: Indexed
});

const version = "ethers/5.6.8";

const logger = new Logger(version);

var ethers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Signer: Signer,
    Wallet: Wallet,
    VoidSigner: VoidSigner,
    getDefaultProvider: getDefaultProvider,
    providers: index,
    BaseContract: BaseContract,
    Contract: Contract,
    ContractFactory: ContractFactory,
    BigNumber: BigNumber,
    FixedNumber: FixedNumber,
    constants: index$2,
    get errors () { return ErrorCode; },
    logger: logger,
    utils: utils,
    wordlists: wordlists,
    version: version,
    Wordlist: Wordlist
});

try {
    const anyGlobal = window;
    if (anyGlobal._ethers == null) {
        anyGlobal._ethers = ethers;
    }
}
catch (error) { }

var beginApplication = function (_a) {
    var jwt = _a.jwt, account = _a.account, _b = _a.network, network = _b === void 0 ? 'goerli' : _b, signature = _a.signature, backendUrl = _a.backendUrl;
    return __awaiter$g(void 0, void 0, void 0, function () {
        var url, response;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    url = "".concat(backendUrl, "/application/begin");
                    return [4 /*yield*/, fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                Authorization: "Bearer ".concat(jwt),
                            },
                            body: JSON.stringify({
                                walletAddress: account,
                                walletSig: signature,
                                network: network,
                            }),
                        })];
                case 1:
                    response = _c.sent();
                    return [2 /*return*/, response.json()];
            }
        });
    });
};

var Loader = function (_a) {
    var children = _a.children;
    return children ? jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, { children: children }) : jsxRuntime.exports.jsx("span", __assign({ className: "kyc-loading" }, { children: "Loading..." }));
};

var PageSignWallet = function (_a) {
    var jwt = _a.jwt, account = _a.account, onSign = _a.onSign, signature = _a.signature, backendUrl = _a.backendUrl, children = _a.children;
    var debug = useSettings().debug;
    var dispatch = useAppDispatch();
    var _b = React.useState(false), loading = _b[0], setLoading = _b[1];
    var customerId = useAuth().customerId;
    var navigate = useNavigation().navigate;
    var handleOnSign = function () {
        var hashedMessage = arrayify(keccak256$1(account));
        onSign(hashedMessage);
    };
    useEffect(function () {
        var handleKYCResponse = function (_a) {
            var veriffSession = _a.veriffSession, contractParameters = _a.contractParameters, error = _a.error;
            if (error) {
                debug && console.error('KYC Response Error: ', error);
                navigate(PageError.KYC_ERROR);
            }
            else if (veriffSession) {
                dispatch(updateVeriffSession({
                    id: veriffSession.id,
                    url: veriffSession.url,
                    vendorData: veriffSession.vendorData,
                    host: veriffSession.host,
                    status: veriffSession.status,
                    sessionToken: veriffSession.sessionToken,
                }));
                navigate(Page$1.VERIFF);
            }
            else if (contractParameters) {
                dispatch(setEthereumContract({
                    governanceAddress: contractParameters.governanceAddress,
                    contractAddress: contractParameters.address,
                    country: contractParameters.country,
                    aml: contractParameters.aml,
                    did: contractParameters.did,
                    signature: contractParameters.signature,
                    issuedAt: contractParameters.issuedAt,
                    tokenId: contractParameters.tokenId,
                    isBusiness: contractParameters.isBusiness,
                }));
                navigate(Page$1.MINT_NFT);
            }
        };
        if (signature && !customerId) {
            setLoading(true);
            beginApplication({
                jwt: jwt,
                account: account,
                signature: signature,
                backendUrl: backendUrl,
            })
                .then(function (KYCResponse) {
                dispatch(setCustomerId(KYCResponse.customerId));
                handleKYCResponse(KYCResponse);
                setLoading(false);
            })
                .catch(function (error) {
                debug && console.error('Begin application endpoint error: ', error);
            });
        }
        return function () {
            setLoading(false);
        };
    }, [account, signature, backendUrl, dispatch, jwt, customerId, navigate]);
    return (jsxRuntime.exports.jsx(PageLayout, { children: loading ? (jsxRuntime.exports.jsx(Loader, { children: children })) : (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx("h1", { children: "Verify your wallet." }), jsxRuntime.exports.jsx("section", { children: "Prove ownership of your wallet address by signing a message in your wallet." }), jsxRuntime.exports.jsx("section", __assign({ className: "kyc-buttons kyc-buttons-single" }, { children: jsxRuntime.exports.jsx("button", __assign({ onClick: handleOnSign, className: "kyc-button kyc-button-primary" }, { children: "Sign Message" })) }))] })) }));
};

/**
 * tua-body-scroll-lock v1.0.0
 * (c) 2019 Evinma, BuptStEve
 * @license MIT
 */

var isServer = function isServer() {
  return typeof window === 'undefined';
};
var $ = function $(selector) {
  return document.querySelector(selector);
};
var detectOS = function detectOS(ua) {
  ua = ua || navigator.userAgent;
  var ipad = /(iPad).*OS\s([\d_]+)/.test(ua);
  var iphone = !ipad && /(iPhone\sOS)\s([\d_]+)/.test(ua);
  var android = /(Android);?[\s/]+([\d.]+)?/.test(ua);
  var ios = iphone || ipad;
  return {
    ios: ios,
    android: android
  };
};
function getEventListenerOptions(options) {
  /* istanbul ignore if */
  if (isServer()) return false;

  if (!options) {
    throw new Error('options must be provided');
  }

  var isSupportOptions = false;
  var listenerOptions = {
    get passive() {
      isSupportOptions = true;
      return;
    }

  };
  /* istanbul ignore next */

  var noop = function noop() {};

  var testEvent = '__TUA_BSL_TEST_PASSIVE__';
  window.addEventListener(testEvent, noop, listenerOptions);
  window.removeEventListener(testEvent, noop, listenerOptions);
  var capture = options.capture;
  /* istanbul ignore next */

  return isSupportOptions ? options : typeof capture !== 'undefined' ? capture : false;
}

var lockedNum = 0;
var initialClientY = 0;
var initialClientX = 0;
var unLockCallback = null;
var documentListenerAdded = false;
var lockedElements = [];
var eventListenerOptions = getEventListenerOptions({
  passive: false
});

var setOverflowHiddenPc = function setOverflowHiddenPc() {
  var $body = $('body');
  var bodyStyle = Object.assign({}, $body.style);
  var scrollBarWidth = window.innerWidth - document.body.clientWidth;
  $body.style.overflow = 'hidden';
  $body.style.boxSizing = 'border-box';
  $body.style.paddingRight = "".concat(scrollBarWidth, "px");
  return function () {
    ['overflow', 'boxSizing', 'paddingRight'].forEach(function (x) {
      $body.style[x] = bodyStyle[x] || '';
    });
  };
};

var setOverflowHiddenMobile = function setOverflowHiddenMobile() {
  var $html = $('html');
  var $body = $('body');
  var scrollTop = $html.scrollTop || $body.scrollTop;
  var htmlStyle = Object.assign({}, $html.style);
  var bodyStyle = Object.assign({}, $body.style);
  $html.style.height = '100%';
  $html.style.overflow = 'hidden';
  $body.style.top = "-".concat(scrollTop, "px");
  $body.style.width = '100%';
  $body.style.height = 'auto';
  $body.style.position = 'fixed';
  $body.style.overflow = 'hidden';
  return function () {
    $html.style.height = htmlStyle.height || '';
    $html.style.overflow = htmlStyle.overflow || '';
    ['top', 'width', 'height', 'overflow', 'position'].forEach(function (x) {
      $body.style[x] = bodyStyle[x] || '';
    });
    window.scrollTo(0, scrollTop);
  };
};

var preventDefault = function preventDefault(event) {
  if (!event.cancelable) return;
  event.preventDefault();
};

var handleScroll = function handleScroll(event, targetElement) {
  if (targetElement) {
    var scrollTop = targetElement.scrollTop,
        scrollLeft = targetElement.scrollLeft,
        scrollWidth = targetElement.scrollWidth,
        scrollHeight = targetElement.scrollHeight,
        clientWidth = targetElement.clientWidth,
        clientHeight = targetElement.clientHeight;
    var clientX = event.targetTouches[0].clientX - initialClientX;
    var clientY = event.targetTouches[0].clientY - initialClientY;
    var isVertical = Math.abs(clientY) > Math.abs(clientX);
    var isOnTop = clientY > 0 && scrollTop === 0;
    var isOnLeft = clientX > 0 && scrollLeft === 0;
    var isOnRight = clientX < 0 && scrollLeft + clientWidth + 1 >= scrollWidth;
    var isOnBottom = clientY < 0 && scrollTop + clientHeight + 1 >= scrollHeight;

    if (isVertical && (isOnTop || isOnBottom) || !isVertical && (isOnLeft || isOnRight)) {
      return preventDefault(event);
    }
  }

  event.stopPropagation();
  return true;
};

var checkTargetElement = function checkTargetElement(targetElement) {
  if (targetElement) return;
  if (targetElement === null) return;
  if (process.env.NODE_ENV === 'production') return;
  console.warn("If scrolling is also required in the floating layer, " + "the target element must be provided.");
};

var lock = function lock(targetElement) {
  if (isServer()) return;
  checkTargetElement(targetElement);

  if (detectOS().ios) {
    // iOS
    if (targetElement && lockedElements.indexOf(targetElement) === -1) {
      targetElement.ontouchstart = function (event) {
        initialClientY = event.targetTouches[0].clientY;
        initialClientX = event.targetTouches[0].clientX;
      };

      targetElement.ontouchmove = function (event) {
        if (event.targetTouches.length !== 1) return;
        handleScroll(event, targetElement);
      };

      lockedElements.push(targetElement);
    }

    if (!documentListenerAdded) {
      document.addEventListener('touchmove', preventDefault, eventListenerOptions);
      documentListenerAdded = true;
    }
  } else if (lockedNum <= 0) {
    unLockCallback = detectOS().android ? setOverflowHiddenMobile() : setOverflowHiddenPc();
  }

  lockedNum += 1;
};

var unlock = function unlock(targetElement) {
  if (isServer()) return;
  checkTargetElement(targetElement);
  lockedNum -= 1;
  if (lockedNum > 0) return;

  if (!detectOS().ios && typeof unLockCallback === 'function') {
    unLockCallback();
    return;
  } // iOS


  if (targetElement) {
    var index = lockedElements.indexOf(targetElement);

    if (index !== -1) {
      targetElement.ontouchmove = null;
      targetElement.ontouchstart = null;
      lockedElements.splice(index, 1);
    }
  }

  if (documentListenerAdded) {
    document.removeEventListener('touchmove', preventDefault, eventListenerOptions);
    documentListenerAdded = false;
  }
};

var toArray = function toArray(a) {
  var ret = Array(a.length);
  for (var i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};

var arrayFind = function arrayFind(array, search) {
  return array.filter(function (a) {
    return a === search;
  })[0];
};

var asArray = function asArray(a) {
  return Array.isArray(a) ? a : [a];
};

var tabSort = function tabSort(a, b) {
  var tabDiff = a.tabIndex - b.tabIndex;
  var indexDiff = a.index - b.index;

  if (tabDiff) {
    if (!a.tabIndex) return 1;
    if (!b.tabIndex) return -1;
  }

  return tabDiff || indexDiff;
};

var orderByTabIndex = function orderByTabIndex(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function (node, index) {
    return {
      node: node,
      index: index,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function (data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};

var tabbables = ['button:enabled:not([readonly])', 'select:enabled:not([readonly])', 'textarea:enabled:not([readonly])', 'input:enabled:not([readonly])', 'a[href]', 'area[href]', 'iframe', 'object', 'embed', '[tabindex]', '[contenteditable]', '[autofocus]'];

var FOCUS_GROUP = 'data-focus-lock';
var FOCUS_DISABLED = 'data-focus-lock-disabled';
var FOCUS_ALLOW = 'data-no-focus-lock';
var FOCUS_AUTO = 'data-autofocus-inside';

var queryTabbables = tabbables.join(',');
var queryGuardTabbables = queryTabbables + ', [data-focus-guard]';

var getFocusables = function getFocusables(parents, withGuards) {
  return parents.reduce(function (acc, parent) {
    return acc.concat(
    // add all tabbables inside
    toArray(parent.querySelectorAll(withGuards ? queryGuardTabbables : queryTabbables)),
    // add if node is tabble itself
    parent.parentNode ? toArray(parent.parentNode.querySelectorAll(tabbables.join(','))).filter(function (node) {
      return node === parent;
    }) : []);
  }, []);
};

var getParentAutofocusables = function getParentAutofocusables(parent) {
  var parentFocus = parent.querySelectorAll('[' + FOCUS_AUTO + ']');
  return toArray(parentFocus).map(function (node) {
    return getFocusables([node]);
  }).reduce(function (acc, nodes) {
    return acc.concat(nodes);
  }, []);
};

var isElementHidden = function isElementHidden(computedStyle) {
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden';
};

var isVisible = function isVisible(node) {
  return !node || node === document || node.nodeType === Node.DOCUMENT_NODE || !isElementHidden(window.getComputedStyle(node, null)) && isVisible(node.parentNode);
};

var notHiddenInput = function notHiddenInput(node) {
  return !((node.tagName === 'INPUT' || node.tagName === 'BUTTON') && (node.type === 'hidden' || node.disabled));
};

var getParents = function getParents(node) {
  var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode, parents);
  }
  return parents;
};

var getCommonParent = function getCommonParent(nodea, nodeb) {
  var parentsA = getParents(nodea);
  var parentsB = getParents(nodeb);

  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};

var filterFocusable = function filterFocusable(nodes) {
  return toArray(nodes).filter(function (node) {
    return isVisible(node);
  }).filter(function (node) {
    return notHiddenInput(node);
  });
};

var getTabbableNodes = function getTabbableNodes(topNodes, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards)), true, withGuards);
};

var getAllTabbableNodes = function getAllTabbableNodes(topNodes) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes)), false);
};

var parentAutofocusables = function parentAutofocusables(topNode) {
  return filterFocusable(getParentAutofocusables(topNode));
};

var isRadio = function isRadio(node) {
  return node.tagName === 'INPUT' && node.type === 'radio';
};

var findSelectedRadio = function findSelectedRadio(node, nodes) {
  return nodes.filter(isRadio).filter(function (el) {
    return el.name === node.name;
  }).filter(function (el) {
    return el.checked;
  })[0] || node;
};

var pickFirstFocus = function pickFirstFocus(nodes) {
  if (nodes[0] && nodes.length > 1) {
    if (isRadio(nodes[0]) && nodes[0].name) {
      return findSelectedRadio(nodes[0], nodes);
    }
  }
  return nodes[0];
};

var pickFocusable = function pickFocusable(nodes, index) {
  if (nodes.length > 1) {
    if (isRadio(nodes[index]) && nodes[index].name) {
      return nodes.indexOf(findSelectedRadio(nodes[index], nodes));
    }
  }
  return index;
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var filterNested = function filterNested(nodes) {
  var l = nodes.length;
  for (var i = 0; i < l; i += 1) {
    var _loop = function _loop(j) {
      if (i !== j) {
        if (nodes[i].contains(nodes[j])) {
          return {
            v: filterNested(nodes.filter(function (x) {
              return x !== nodes[j];
            }))
          };
        }
      }
    };

    for (var j = 0; j < l; j += 1) {
      var _ret = _loop(j);

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  }
  return nodes;
};

var getTopParent = function getTopParent(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
};

var getAllAffectedNodes = function getAllAffectedNodes(node) {
  var nodes = asArray(node);
  return nodes.filter(Boolean).reduce(function (acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll('[' + FOCUS_GROUP + '="' + group + '"]:not([' + FOCUS_DISABLED + '="disabled"])'))) : [currentNode]);
    return acc;
  }, []);
};

var findAutoFocused = function findAutoFocused(autoFocusables) {
  return function (node) {
    return !!node.autofocus || node.dataset && !!node.dataset.autofocus || autoFocusables.indexOf(node) >= 0;
  };
};

var isGuard = function isGuard(node) {
  return node && node.dataset && node.dataset.focusGuard;
};
var notAGuard = function notAGuard(node) {
  return !isGuard(node);
};

var newFocus = function newFocus(innerNodes, outerNodes, activeElement, lastNode, autoFocused) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);

  // focus is inside
  if (innerNodes.indexOf(activeElement) >= 0) {
    return undefined;
  }

  var activeIndex = outerNodes.indexOf(activeElement);
  var lastIndex = outerNodes.indexOf(lastNode || activeIndex);
  var lastNodeInside = innerNodes.indexOf(lastNode);
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);

  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);

  // new focus
  if (activeIndex === -1 || lastNodeInside === -1) {
    return innerNodes.indexOf(autoFocused && autoFocused.length ? pickFirstFocus(autoFocused) : pickFirstFocus(innerNodes));
  }
  // old focus
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  // first element
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  // last element
  if (activeIndex >= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  // jump out, but not on the guard
  if (indexDiff && Math.abs(indexDiff) > 1) {
    return lastNodeInside;
  }
  // focus above lock
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  // focus below lock
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  // index is inside tab order, but outside Lock
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  // do nothing
  return undefined;
};

var getTopCommonParent = function getTopCommonParent(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = null;
  leftEntries.filter(Boolean).forEach(function (entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function (subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || common.contains(topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};

var allParentAutofocusables = function allParentAutofocusables(entries) {
  return entries.reduce(function (acc, node) {
    return acc.concat(parentAutofocusables(node));
  }, []);
};

var reorderNodes = function reorderNodes(srcNodes, dstNodes) {
  var remap = new Map();
  // no Set(dstNodes) for IE11 :(
  dstNodes.forEach(function (entity) {
    return remap.set(entity.node, entity);
  });
  // remap to dstNodes
  return srcNodes.map(function (node) {
    return remap.get(node);
  }).filter(Boolean);
};

var getFocusMerge = function getFocusMerge(topNode, lastNode) {
  var activeElement = document && document.activeElement;
  var entries = getAllAffectedNodes(topNode).filter(notAGuard);

  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);

  var innerElements = getTabbableNodes(entries).filter(function (_ref4) {
    var node = _ref4.node;
    return notAGuard(node);
  });

  if (!innerElements[0]) {
    innerElements = getAllTabbableNodes(entries).filter(function (_ref5) {
      var node = _ref5.node;
      return notAGuard(node);
    });
    if (!innerElements[0]) {
      return undefined;
    }
  }

  var outerNodes = getTabbableNodes([commonParent]).map(function (_ref6) {
    var node = _ref6.node;
    return node;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function (_ref7) {
    var node = _ref7.node;
    return node;
  });

  var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode, innerNodes.filter(findAutoFocused(allParentAutofocusables(entries))));

  if (newId === undefined) {
    return newId;
  }
  return orderedInnerElements[newId];
};

var focusInFrame = function focusInFrame(frame) {
  return frame === document.activeElement;
};

var focusInsideIframe = function focusInsideIframe(topNode) {
  return !!arrayFind(toArray(topNode.querySelectorAll('iframe')), focusInFrame);
};

var focusInside = function focusInside(topNode) {
  var activeElement = document && document.activeElement;

  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).reduce(function (result, node) {
    return result || node.contains(activeElement) || focusInsideIframe(node);
  }, false);
};

var focusIsHidden = function focusIsHidden() {
  return document && toArray(document.querySelectorAll('[' + FOCUS_ALLOW + ']')).some(function (node) {
    return node.contains(document.activeElement);
  });
};

var focusOn = function focusOn(target) {
  target.focus();
  if (target.contentWindow) {
    target.contentWindow.focus();
  }
};

var guardCount = 0;
var lockDisabled = false;

var setFocus = (function (topNode, lastNode) {
  var focusable = getFocusMerge(topNode, lastNode);

  if (lockDisabled) {
    return;
  }

  if (focusable) {
    if (guardCount > 2) {
      // eslint-disable-next-line no-console
      console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' + 'See https://github.com/theKashey/focus-lock/#focus-fighting');
      lockDisabled = true;
      setTimeout(function () {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node);
    guardCount--;
  }
});

var lastActiveTrap = 0;
var lastActiveFocus = null;

var focusOnBody = function focusOnBody() {
  return document && document.activeElement === document.body;
};

var isFreeFocus = function isFreeFocus() {
  return focusOnBody() || focusIsHidden();
};

var activateTrap = function activateTrap() {
  var result = false;

  if (lastActiveTrap) {
    var observed = lastActiveTrap;

    if (!isFreeFocus()) {
      if (observed && !focusInside(observed)) {
        result = setFocus(observed, lastActiveFocus);
      }

      lastActiveFocus = document.activeElement;
    }
  }

  return result;
};

var reducePropsToState = function reducePropsToState(propsList) {
  return propsList.filter(function (node) {
    return node;
  }).slice(-1)[0];
};

var handleStateChangeOnClient = function handleStateChangeOnClient(trap) {
  lastActiveTrap = trap;

  if (trap) {
    activateTrap();
  }
};

var instances = [];

var emitChange = function emitChange(event) {
  if (handleStateChangeOnClient(reducePropsToState(instances))) {
    event && event.preventDefault();
    return true;
  }

  return false;
};

var attachHandler = function attachHandler() {
  document.addEventListener('focusin', emitChange);
};

var detachHandler = function detachHandler() {
  document.removeEventListener('focusin', emitChange);
};

var focusLock = {
  on: function on(domNode) {
    if (instances.length === 0) {
      attachHandler();
    }

    if (instances.indexOf(domNode) < 0) {
      instances.push(domNode);
      emitChange();
    }
  },
  off: function off(domNode) {
    instances = instances.filter(function (node) {
      return node !== domNode;
    });
    emitChange();

    if (instances.length === 0) {
      detachHandler();
    }
  }
};

var IFRAME_MESSAGES;

(function (IFRAME_MESSAGES) {
  IFRAME_MESSAGES["VERIFF_HANDSHAKE"] = "VERIFF_HANDSHAKE";
  IFRAME_MESSAGES["VERIFF_RENDER"] = "VERIFF_RENDER";
  IFRAME_MESSAGES["VERIFF_STARTED"] = "VERIFF_STARTED";
  IFRAME_MESSAGES["VERIFF_FINISHED"] = "VERIFF_FINISHED";
  IFRAME_MESSAGES["VERIFF_CANCELED"] = "VERIFF_CANCELED";
  IFRAME_MESSAGES["VERIFF_FORCE_RELOAD"] = "VERIFF_FORCE_RELOAD";
  IFRAME_MESSAGES["VERIFF_RELOAD_REQUEST"] = "VERIFF_RELOAD_REQUEST";
})(IFRAME_MESSAGES || (IFRAME_MESSAGES = {}));

var MESSAGES;

(function (MESSAGES) {
  MESSAGES["STARTED"] = "STARTED";
  MESSAGES["FINISHED"] = "FINISHED";
  MESSAGES["CANCELED"] = "CANCELED";
  MESSAGES["RELOAD_REQUEST"] = "RELOAD";
})(MESSAGES || (MESSAGES = {}));

var wrapperStyles = "\n  position: fixed !important;\n  top: 0 !important;\n  right: 0 !important;\n  bottom: 0 !important;\n  left: 0 !important;\n  z-index: 9999999;\n  display: block !important;\n  width: 100vw;\n  height: 100%;\n  margin: 0 !important;\n  padding: 0 !important;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  background: rgba(0, 0, 0, 0.6);\n";
var iframeStyles = "\n  position: absolute !important;\n  top: 0 !important;\n  right: 0 !important;\n  bottom: 0 !important;\n  left: 0 !important;\n  width: 100vw;\n  height: 100%;\n  margin: 0 !important;\n  padding: 0 !important;\n  background: none;\n  border: none\n";

var IFRAME_ID = 'veriffFrame';

function appendParamToUrl(url, name, value) {
  if (value) {
    var newUrl = new URL(url);
    var params = newUrl.searchParams;
    params.set(name, value);
    newUrl.search = params.toString();
    return newUrl.toString();
  }

  return url;
}

function createIframe(url) {
  var frame = document.createElement('iframe');
  frame.src = url;
  frame.allow = 'autoplay; camera; microphone; fullscreen; accelerometer; magnetometer; gyroscope; picture-in-picture;';
  frame.id = IFRAME_ID;
  frame.style.cssText = iframeStyles;
  var wrapper = document.createElement('div');
  wrapper.style.cssText = wrapperStyles;
  wrapper.appendChild(frame);
  document.body.appendChild(wrapper);
  focusLock.on(frame);
  lock(frame);
  return frame;
}

function createVeriffFrame(_ref) {
  var url = _ref.url,
      lang = _ref.lang,
      _ref$onEvent = _ref.onEvent,
      onEvent = _ref$onEvent === void 0 ? function () {
    return;
  } : _ref$onEvent,
      onReload = _ref.onReload;

  if (!url) {
    throw new Error('URL is not provided. Please provide a valid Veriff session url.');
  }

  function closeIframe() {
    var frame = document.getElementById(IFRAME_ID);

    if (frame && frame.parentNode) {
      focusLock.off(frame);
      unlock(frame);
      var wrapper = frame.parentNode.parentNode;

      if (wrapper) {
        wrapper.removeChild(frame.parentNode);
      }
    } else {
      unlock();
    }

    window.removeEventListener('message', handleMessage);
  }

  function handleMessage(event) {
    var frame = document.getElementById(IFRAME_ID);

    if (event.data === IFRAME_MESSAGES.VERIFF_HANDSHAKE) {
      var _frame$contentWindow;

      (_frame$contentWindow = frame.contentWindow) === null || _frame$contentWindow === void 0 ? void 0 : _frame$contentWindow.postMessage({
        name: IFRAME_MESSAGES.VERIFF_RENDER,
        payload: {
          isFullScreenSupported: true,
          isReloadHandled: typeof onReload === 'function',
          version: '1.3.1'
        }
      }, '*');
    }

    if (event.data === IFRAME_MESSAGES.VERIFF_STARTED) {
      onEvent(MESSAGES.STARTED);
    }

    if (event.data === IFRAME_MESSAGES.VERIFF_CANCELED) {
      closeIframe();
      onEvent(MESSAGES.CANCELED);
    }

    if (event.data === IFRAME_MESSAGES.VERIFF_FINISHED) {
      closeIframe();
      onEvent(MESSAGES.FINISHED);
    }

    if (event.data === IFRAME_MESSAGES.VERIFF_FORCE_RELOAD) {
      window.location.reload();
    }

    if (event.data === IFRAME_MESSAGES.VERIFF_RELOAD_REQUEST) {
      if (typeof onReload === 'function') {
        onReload();
      }

      onEvent(MESSAGES.RELOAD_REQUEST);
    }
  }

  if (lang && lang.length > 0) {
    createIframe(appendParamToUrl(url, 'lang', lang));
  } else {
    createIframe(url);
  }

  window.addEventListener('message', handleMessage);
  return {
    close: closeIframe
  };
}

var PageVeriff = function (_a) {
    var children = _a.children;
    // TODO: check isDevelopment functionality to see if it's required by SL.
    var veriffURL = useAppSelector(function (state) { return state.veriffSession.url; });
    var dispatch = useAppDispatch();
    var navigate = useNavigation().navigate;
    var debug = useSettings().debug;
    var startVeriff = function (_a) {
        var url = _a.url;
        // display Veriff
        if (!url) {
            debug && console.error('No Veriff URL');
            return;
        }
        dispatch(updateVeriffStatus(VeriffStatus.PENDING));
        var veriffFrame = createVeriffFrame({
            url: url,
            onEvent: function (msg) {
                return __awaiter$g(this, void 0, void 0, function () {
                    var message;
                    return __generator(this, function (_a) {
                        message = VeriffStatus[msg];
                        if (message === VeriffStatus.FINISHED) {
                            navigate(Page$1.VERIFF_STATUS);
                            veriffFrame.close();
                        }
                        else if (message === VeriffStatus.CANCELED) {
                            debug && console.error('Veriff Error', message, msg);
                            navigate(PageError.VERIFF_ERROR);
                            veriffFrame.close();
                        }
                        dispatch(updateVeriffStatus(message));
                        return [2 /*return*/];
                    });
                });
            },
        });
        dispatch(setVeriffFrame(veriffFrame));
    };
    useEffect(function () {
        startVeriff({ url: veriffURL });
    }, []);
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("div", { "data-id": "page-veriff" }), children] }));
};

var createVeriffSession = function (backendUrl) { return __awaiter$g(void 0, void 0, void 0, function () {
    var url, response, remoteResponse;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                url = "".concat(backendUrl, "/veriff");
                return [4 /*yield*/, fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            Authorization: "Bearer ".concat(store.getState().auth.jwt),
                        },
                        body: JSON.stringify({
                            customerId: store.getState().auth.customerId,
                        }),
                    })];
            case 1:
                response = _a.sent();
                if (response.status >= 400) {
                    throw Error('error creating veriff session');
                }
                return [4 /*yield*/, response.json()];
            case 2:
                remoteResponse = _a.sent();
                store.dispatch(updateVeriffSession(remoteResponse));
                return [2 /*return*/];
        }
    });
}); };

var PageVeriffError = function (_a) {
    var backendUrl = _a.backendUrl;
    var navigate = useNavigation().navigate;
    var onClickTryAgain = function () {
        createVeriffSession(backendUrl).then(function () {
            navigate(Page$1.VERIFF);
        });
    };
    return (jsxRuntime.exports.jsxs(PageLayout, __assign({ "data-id": "page-veriff-error" }, { children: [jsxRuntime.exports.jsx("h1", { children: "We could not verify your identity." }), jsxRuntime.exports.jsx("section", { children: "Please try again or report your issue using the links below." }), jsxRuntime.exports.jsx("section", __assign({ className: "kyc-buttons kyc-buttons-single" }, { children: jsxRuntime.exports.jsx("button", __assign({ className: "kyc-button kyc-button-primary", onClick: onClickTryAgain }, { children: "Try again" })) })), jsxRuntime.exports.jsx(ContactLinks, {})] })));
};

var useInterval = function (callback, delay) {
    var savedCallback = useRef(function () { });
    // Remember the latest callback
    useEffect(function () {
        savedCallback.current = callback;
    }, [callback]);
    // Set up the interval
    useEffect(function () {
        var tick = function () {
            savedCallback.current();
        };
        if (delay !== null) {
            var id_1 = setInterval(tick, delay);
            return function () {
                clearInterval(id_1);
            };
        }
        return function () { };
    }, [callback, delay]);
};

var FieldName$1;
(function (FieldName) {
    FieldName["FirstName"] = "firstName";
    FieldName["LastName"] = "lastName";
    FieldName["Country"] = "country";
    FieldName["City"] = "city";
    FieldName["PostalCode"] = "zip";
    FieldName["Zone"] = "province";
    FieldName["Address1"] = "address1";
    FieldName["Address2"] = "address2";
    FieldName["Phone"] = "phone";
    FieldName["Company"] = "company";
})(FieldName$1 || (FieldName$1 = {}));
var GRAPHQL_ENDPOINT = 'https://atlas.shopifycloud.com/graphql';
var GraphqlOperationName$1;
(function (GraphqlOperationName) {
    GraphqlOperationName["Countries"] = "countries";
    GraphqlOperationName["Country"] = "country";
})(GraphqlOperationName$1 || (GraphqlOperationName$1 = {}));
var HEADERS = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
};

var query = "\nquery countries($locale: SupportedLocale!) {\n  countries(locale: $locale) {\n    name\n    code\n    continent\n    phoneNumberPrefix\n    autocompletionField\n    provinceKey\n    labels {\n      address1\n      address2\n      city\n      company\n      country\n      firstName\n      lastName\n      phone\n      postalCode\n      zone\n    }\n    optionalLabels {\n      address2\n    }\n    formatting {\n      edit\n      show\n    }\n    zones {\n      name\n      code\n    }\n  }\n}\n\nquery country($countryCode: SupportedCountry!, $locale: SupportedLocale!) {\n  country(countryCode: $countryCode, locale: $locale) {\n    name\n    code\n    continent\n    phoneNumberPrefix\n    autocompletionField\n    provinceKey\n    labels {\n      address1\n      address2\n      city\n      company\n      country\n      firstName\n      lastName\n      phone\n      postalCode\n      zone\n    }\n    optionalLabels {\n      address2\n    }\n    formatting {\n      edit\n      show\n    }\n    zones {\n      name\n      code\n    }\n  }\n}\n";

function memoizeAsync(asyncFunction) {
    var _this = this;
    var cache = {};
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var stringifiedArgs = JSON.stringify(args);
        if (!cache[stringifiedArgs]) {
            cache[stringifiedArgs] = asyncFunction.apply(_this, args);
        }
        return cache[stringifiedArgs];
    };
}
var CountryLoaderError = /** @class */ (function (_super) {
    __extends$1(CountryLoaderError, _super);
    function CountryLoaderError(errors) {
        var errorMessage = errors.errors.map(function (error) { return error.message; }).join('; ');
        return _super.call(this, errorMessage) || this;
    }
    return CountryLoaderError;
}(Error));
var loadCountries = memoizeAsync(function (locale) { return __awaiter$g(void 0, void 0, void 0, function () {
    var response, countries;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fetch(GRAPHQL_ENDPOINT, {
                    method: 'POST',
                    headers: HEADERS,
                    body: JSON.stringify({
                        query: query,
                        operationName: GraphqlOperationName$1.Countries,
                        variables: {
                            locale: locale.replace(/-/, '_').toUpperCase(),
                        },
                    }),
                })];
            case 1:
                response = _a.sent();
                return [4 /*yield*/, response.json()];
            case 2:
                countries = _a.sent();
                if (!('data' in countries) && 'errors' in countries) {
                    throw new CountryLoaderError(countries);
                }
                return [2 /*return*/, countries.data.countries];
        }
    });
}); });
var loadCountry = memoizeAsync(function (locale, countryCode) { return __awaiter$g(void 0, void 0, void 0, function () {
    var response, country;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fetch(GRAPHQL_ENDPOINT, {
                    method: 'POST',
                    headers: HEADERS,
                    body: JSON.stringify({
                        query: query,
                        operationName: GraphqlOperationName$1.Country,
                        variables: {
                            countryCode: countryCode,
                            locale: locale.replace(/-/, '_').toUpperCase(),
                        },
                    }),
                })];
            case 1:
                response = _a.sent();
                return [4 /*yield*/, response.json()];
            case 2:
                country = _a.sent();
                if (!('data' in country) && 'errors' in country) {
                    throw new CountryLoaderError(country);
                }
                return [2 /*return*/, country.data.country];
        }
    });
}); });

var FIELD_REGEXP$1 = /({\w+})/g;
var FIELDS_MAPPING = {
    '{firstName}': FieldName$1.FirstName,
    '{lastName}': FieldName$1.LastName,
    '{country}': FieldName$1.Country,
    '{city}': FieldName$1.City,
    '{zip}': FieldName$1.PostalCode,
    '{province}': FieldName$1.Zone,
    '{address1}': FieldName$1.Address1,
    '{address2}': FieldName$1.Address2,
    '{phone}': FieldName$1.Phone,
    '{company}': FieldName$1.Company,
};
function getZone(zones, zoneCode) {
    return (zones.find(function (zone) { return zone.code === zoneCode; }) || {
        name: '',
        code: '',
    });
}
/*
 * Returns empty string if all replacement fields are empty.
 */
function renderLineTemplate(country, template, address) {
    var result = template.match(FIELD_REGEXP$1);
    var line = template;
    if (!result) {
        return '';
    }
    var lineIsEmpty = true;
    result.forEach(function (key) {
        var addressKey = key.replace('{', '').replace('}', '');
        if (address[addressKey]) {
            lineIsEmpty = false;
        }
        switch (addressKey) {
            case FieldName$1.Country:
                line = line.replace("{".concat(FieldName$1.Country, "}"), country.name);
                break;
            case FieldName$1.Zone:
                line = line.replace("{".concat(FieldName$1.Zone, "}"), address.province ? getZone(country.zones, address.province).name : '');
                break;
            default:
                line = line.replace(key, address[addressKey] || '');
                break;
        }
    });
    if (lineIsEmpty) {
        return '';
    }
    return line.trim().replace('  ', ' ');
}

var FIELD_REGEXP = /({\w+})/g;
var LINE_DELIMITER = '_';
var DEFAULT_FORM_LAYOUT = '{firstName}{lastName}_{company}_{address1}_{address2}_{city}_{country}{province}{zip}_{phone}';
var DEFAULT_SHOW_LAYOUT = '{lastName} {firstName}_{company}_{address1} {address2}_{city} {province} {zip}_{country}_{phone}';
var ORDERED_COUNTRIES_CACHE = {};
var AddressFormatter = /** @class */ (function () {
    function AddressFormatter(locale) {
        this.locale = locale;
        this.locale = locale;
    }
    AddressFormatter.prototype.updateLocale = function (locale) {
        this.locale = locale;
    };
    AddressFormatter.prototype.getCountry = function (countryCode) {
        return __awaiter$g(this, void 0, void 0, function () {
            var country;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        country = this.loadCountryFromCache(countryCode);
                        if (country) {
                            return [2 /*return*/, country];
                        }
                        return [4 /*yield*/, loadCountry(this.locale, countryCode)];
                    case 1:
                        country = _a.sent();
                        return [2 /*return*/, country];
                }
            });
        });
    };
    AddressFormatter.prototype.getCountries = function () {
        return __awaiter$g(this, void 0, void 0, function () {
            var countries;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, loadCountries(this.locale)];
                    case 1:
                        countries = _a.sent();
                        ORDERED_COUNTRIES_CACHE[this.locale] = countries;
                        return [2 /*return*/, countries];
                }
            });
        });
    };
    /* Returns the address ordered in an array based based on the country code
     * Eg.:
     *   [
     *     'Shopify',
     *     'First Name Last Name',
     *     'Address 1',
     *     'address2',
     *     'Montréal',
     *     'Canada Quebec H2J 4B7',
     *     '514 444 3333'
     *   ]
     */
    AddressFormatter.prototype.format = function (address) {
        return __awaiter$g(this, void 0, void 0, function () {
            var country, layout;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCountry(address.country)];
                    case 1:
                        country = _a.sent();
                        layout = country.formatting.show || DEFAULT_SHOW_LAYOUT;
                        return [2 /*return*/, layout.split(LINE_DELIMITER).map(function (fields) { return renderLineTemplate(country, fields, address).trim(); })];
                }
            });
        });
    };
    /* Returns an array that shows how to order fields based on the country code
     * Eg.:
     *   [
     *     ['company'],
     *     ['firstName', 'lastName'],
     *     ['address1'],
     *     ['address2'],
     *     ['city'],
     *     ['country', 'province', 'zip'],
     *     ['phone']
     *   ]
     */
    AddressFormatter.prototype.getOrderedFields = function (countryCode) {
        return __awaiter$g(this, void 0, void 0, function () {
            var country, format;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCountry(countryCode)];
                    case 1:
                        country = _a.sent();
                        format = country ? country.formatting.edit : DEFAULT_FORM_LAYOUT;
                        return [2 /*return*/, format.split(LINE_DELIMITER).map(function (fields) {
                                var result = fields.match(FIELD_REGEXP);
                                if (!result) {
                                    return [];
                                }
                                return result.map(function (field) {
                                    return FIELDS_MAPPING[field];
                                });
                            })];
                }
            });
        });
    };
    AddressFormatter.prototype.loadCountryFromCache = function (countryCode) {
        if (ORDERED_COUNTRIES_CACHE[this.locale]) {
            return ORDERED_COUNTRIES_CACHE[this.locale].find(function (country) {
                return country.code === countryCode;
            });
        }
        return null;
    };
    return AddressFormatter;
}());

var I8NAddressFormatter = new AddressFormatter('EN');
var getCountryByCode = function (code) {
    var countries = store.getState().localization.allCountries;
    var target = {};
    countries.forEach(function (country) {
        if (country.code === code) {
            target = country;
        }
    });
    return target;
};

var PageVeriffStatus = function (_a) {
    var backendUrl = _a.backendUrl, children = _a.children;
    var dispatch = useAppDispatch();
    var customerId = useAppSelector(function (state) { return state.auth.customerId; });
    var _b = useNavigation(), navigate = _b.navigate, navigateByStatus = _b.navigateByStatus;
    var debug = useSettings().debug;
    var _c = useState(false), idVerificationStatusDecided = _c[0], setIdVerificationStatusDecided = _c[1];
    var pollStatus = function () { return __awaiter$g(void 0, void 0, void 0, function () {
        var _a, error, addressCountry, contractParameters, _b, idVerificationStatus, decided, country;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!customerId) return [3 /*break*/, 2];
                    return [4 /*yield*/, getKycStatus(customerId, backendUrl)];
                case 1:
                    _a = _c.sent(), error = _a.error, addressCountry = _a.addressCountry, contractParameters = _a.contractParameters, _b = _a.idVerificationStatus, idVerificationStatus = _b === void 0 ? IDVerificationStatus.PENDING : _b;
                    debug &&
                        console.log('Polling KYC status: ', {
                            error: error,
                            addressCountry: addressCountry,
                            contractParameters: contractParameters,
                            idVerificationStatus: idVerificationStatus,
                        });
                    decided = idVerificationStatus === IDVerificationStatus.PASS ||
                        idVerificationStatus === IDVerificationStatus.FAIL;
                    setIdVerificationStatusDecided(decided);
                    dispatch(updateIdVerificationStatus(idVerificationStatus));
                    if (decided && addressCountry) {
                        country = getCountryByCode(addressCountry);
                        dispatch(updateCurrentCountry(country));
                    }
                    if (contractParameters) {
                        navigateByStatus({
                            error: error,
                            contractParameters: contractParameters,
                        });
                    }
                    _c.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    }); };
    useInterval(function () {
        if (!idVerificationStatusDecided) {
            pollStatus();
        }
    }, 2000);
    useEffect(function () {
        if (idVerificationStatusDecided) {
            var _a = store.getState(), status_1 = _a.pollingStatus.idVerificationStatus, did = _a.ethereumContract.did;
            if (!did && status_1 === IDVerificationStatus.PASS) {
                // if we are bypassing, this flow happens after the KYC form
                // so we just skip to the blockchain and AML status checking
                // immediately
                navigate(Page$1.KYC_FORM);
            }
            else if (!did && status_1 === IDVerificationStatus.FAIL) {
                dispatch(clearIdPollingStatus());
                navigate(PageError.VERIFF_ERROR);
            }
        }
    }, [dispatch, navigate, idVerificationStatusDecided]);
    return (jsxRuntime.exports.jsxs(PageLayout, __assign({ "data-id": "page-veriff-status" }, { children: [jsxRuntime.exports.jsx("h1", { children: "Please wait while we verify your ID." }), jsxRuntime.exports.jsxs("section", { children: [jsxRuntime.exports.jsx("b", { children: "Don't refresh your browser!" }), " This will only take a few minutes."] }), jsxRuntime.exports.jsx(Loader, { children: children })] })));
};

var truncateAccount = function (account) {
    return account === null
        ? '-'
        : account
            ? "".concat(account.substring(0, 4), "...").concat(account.substring(account.length - 4))
            : '';
};
var generateLedgerCompatibleSignature = function (signature) {
    if (signature === void 0) { signature = ''; }
    var lastTwo = signature.slice(-2);
    if (lastTwo === '00') {
        return "".concat(signature.substring(0, signature.length - 2), "1B");
    }
    if (lastTwo === '01') {
        return "".concat(signature.substring(0, signature.length - 2), "1C");
    }
    return signature;
};

var PageMintNFT = function (_a) {
    var account = _a.account, onMintClick = _a.onMintClick, mintPrice = _a.mintPrice, signature = _a.signature, transactionHash = _a.transactionHash, backendUrl = _a.backendUrl;
    var _b = useState(false), agreed = _b[0], setAgreed = _b[1];
    var _c = useState(false), readMore = _c[0], setReadMore = _c[1];
    var _d = useState(false), showTermsOfService = _d[0], setShowTermsOfService = _d[1];
    var debug = useSettings().debug;
    var dispatch = useDispatch();
    var _e = useAppSelector(function (state) { return state.ethereumContract; }), aml = _e.aml, did = _e.did, tokenId = _e.tokenId, country = _e.country, issuedAt = _e.issuedAt, issuerSignature = _e.signature, isBusiness = _e.isBusiness;
    var navigate = useNavigation().navigate;
    useEffect(function () {
        if (transactionHash) {
            dispatch(setTxHash(transactionHash));
            console.log('Transaction hash found: ', transactionHash);
            navigate(Page$1.MINT_NFT_STATUS);
        }
    }, [dispatch, navigate, transactionHash]);
    var handleAgreedClick = function (event) {
        var checked = event.target.checked;
        setAgreed(checked);
    };
    var handleMintClick = function () {
        var params = {
            account: account,
            tokenId: tokenId,
            quadDID: did,
            aml: aml,
            country: country,
            isBusiness: id(isBusiness ? 'TRUE' : 'FALSE'),
            issuedAt: issuedAt,
        };
        debug && console.log({ params: params, issuerSignature: issuerSignature, signature: signature });
        onMintClick(params, issuerSignature, generateLedgerCompatibleSignature(signature));
    };
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("h1", { children: "Your Identity Passport is ready to be claimed." }), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx("p", { children: "Your Web3 Identity Passport is ready to be claimed and will be stored in the Ethereum blockchain." }) }), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx("button", __assign({ className: "kyc-button kyc-button-toggle", onClick: function () { return setReadMore(!readMore); } }, { children: jsxRuntime.exports.jsx("span", { children: readMore ? '- Read less' : '+ What is minting?' }) })) }), readMore && (jsxRuntime.exports.jsx("section", __assign({ className: "kyc-read-more" }, { children: jsxRuntime.exports.jsx("p", { children: "Claiming the Web3 Identity Passport is a process that validates the information you have provided, creates a new block, and records the information on the blockchain." }) }))), jsxRuntime.exports.jsx("div", __assign({ className: "kyc-passport" }, { children: jsxRuntime.exports.jsx(Passport, {}) })), jsxRuntime.exports.jsx("section", __assign({ className: "kyc-prompt" }, { children: jsxRuntime.exports.jsxs("small", { children: ["The cost of minting the Web3 Identity Passport is ", mintPrice, " ETH plus any associated gas fees."] }) })), jsxRuntime.exports.jsxs("section", { children: [jsxRuntime.exports.jsx("input", { id: "kycMintPassportAgreeCheckbox", name: "agreed", type: "checkbox", checked: agreed, onChange: handleAgreedClick }), jsxRuntime.exports.jsxs("label", __assign({ htmlFor: "kycMintPassportAgreeCheckbox" }, { children: ["By checking this box I understand I am minting the passport for my own benefit and assume all risk related to posting. I further understand and agree to have the NFT automatically updated if there is a change in my KYC/AML status as set forth in the", jsxRuntime.exports.jsx("a", __assign({ onClick: function () { return setShowTermsOfService(!showTermsOfService); } }, { children: " Terms of Service" })), "."] }))] }), showTermsOfService && (jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx(TosPdf, { backendUrl: backendUrl }) })), jsxRuntime.exports.jsx("section", __assign({ className: "kyc-buttons kyc-buttons-single" }, { children: jsxRuntime.exports.jsx("button", __assign({ onClick: function () {
                        if (!issuedAt) {
                            throw new Error('no issued at');
                        }
                        else {
                            handleMintClick();
                        }
                    }, disabled: !agreed, className: "kyc-button kyc-button-primary" }, { children: "Claim Passport" })) }))] }));
};

var PageMintNFTStatus = function (_a) {
    var mintComplete = _a.mintComplete, etherscanUrl = _a.etherscanUrl, transactionHash = _a.transactionHash, children = _a.children;
    var navigate = useNavigation().navigate;
    var etherscanTxUrl = "".concat(etherscanUrl, "/tx/").concat(transactionHash);
    useEffect(function () {
        if (mintComplete) {
            navigate(Page$1.MINT_NFT_COMPLETE);
        }
    }, [navigate, mintComplete]);
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("h1", { children: "Please wait while we mint your Web3 Identity Passport." }), jsxRuntime.exports.jsxs("section", { children: ["This may take a few minutes. You can see the transaction in", ' ', jsxRuntime.exports.jsx("a", __assign({ href: etherscanTxUrl, target: "_blank", rel: "noopener noreferrer" }, { children: "Etherscan" })), "."] }), children] }));
};

var PageMintNFTComplete = function (_a) {
    var account = _a.account, etherscanUrl = _a.etherscanUrl, transactionHash = _a.transactionHash, _b = _a.showSocialButtons, showSocialButtons = _b === void 0 ? true : _b;
    var etherscanTxUrl = "".concat(etherscanUrl, "/tx/").concat(transactionHash);
    var openseaUrl = "https://opensea.io/".concat(account);
    var dom;
    if (transactionHash) {
        dom = (jsxRuntime.exports.jsxs("p", { children: ["View your completed transaction in", ' ', jsxRuntime.exports.jsx("a", __assign({ href: etherscanTxUrl, target: "_blank", rel: "noopener noreferrer" }, { children: "Etherscan" })), ' ', "and you can view your Web3 Identity Passport in", ' ', jsxRuntime.exports.jsx("a", __assign({ href: openseaUrl, target: "_blank", rel: "noopener noreferrer" }, { children: "Opensea" })), "."] }));
    }
    else {
        dom = (jsxRuntime.exports.jsxs("p", { children: ["View your completed transaction in Etherscan and you can view your Web3 Identity Passport in", ' ', jsxRuntime.exports.jsx("a", __assign({ href: openseaUrl, target: "_blank", rel: "noopener noreferrer" }, { children: "Opensea" })), "."] }));
    }
    return (jsxRuntime.exports.jsxs(PageLayout, __assign({ "data-id": "page-mint-nft" }, { children: [jsxRuntime.exports.jsx("h1", { children: "You have successfully claimed your Web3 Identity Passport" }), jsxRuntime.exports.jsxs("section", { children: [jsxRuntime.exports.jsx("p", { children: "You are ready to go!" }), dom] }), jsxRuntime.exports.jsx(Passport, {}), showSocialButtons && (jsxRuntime.exports.jsx("section", __assign({ className: "kyc-buttons kyc-buttons-single" }, { children: jsxRuntime.exports.jsx("a", __assign({ rel: "noreferrer noopener", href: "https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fquadrata.com%2F&ref_src=twsrc%5Etfw%7Ctwcamp%5Ebuttonembed%7Ctwterm%5Eshare%7Ctwgr%5E&related=QuadrataNetwork&text=I%20just%20claimed%20my%20Quadrata%20NFT%20Passport&url=https%3A%2F%2Fquadrata.com&via=QuadrataNetwork", target: "_blank", className: "kyc-button kyc-button-primary kyc-button-twitter" }, { children: "Share On Twitter" })) }))), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx("p", { children: "Any questions? Contact us using the links below" }) }), jsxRuntime.exports.jsx(ContactLinks, {})] })));
};

var ErrorMessage$1 = function (_a) {
    var error = _a.error;
    return (jsxRuntime.exports.jsx("div", __assign({ className: "kyc-input-error-message-container" }, { children: !!error && jsxRuntime.exports.jsx("span", __assign({ className: "kyc-input-error-message" }, { children: error })) })));
};
var KYCTextField = function (_a) {
    var type = _a.type, country = _a.country;
    var dispatch = useAppDispatch();
    var value = useAppSelector(function (state) { return state.kycForm.formValues[type]; });
    var error = useAppSelector(function (state) { return state.kycForm.formErrors[type]; });
    var label = country.labels[type];
    if (type === KYCFieldType.ZIP) {
        label = country.labels.postalCode;
    }
    var onChange = function (event) {
        dispatch(updateKYCFormValue({ value: event.target.value, type: type }));
    };
    // Do not show validation error text for names but still highlight box
    return (jsxRuntime.exports.jsxs("div", __assign({ className: "kyc-input-container" }, { children: [jsxRuntime.exports.jsx("label", __assign({ className: "kyc-input-label" }, { children: label })), jsxRuntime.exports.jsx("input", { type: "text", "data-id": "input-textfield-kyc-".concat(label), value: value, className: "KYCField", onChange: onChange }), jsxRuntime.exports.jsx(ErrorMessage$1, { error: error })] })));
};
var KYCCountrySelector = function () {
    var dispatch = useAppDispatch();
    var currentCountry = useAppSelector(function (state) { return state.localization.currentCountry; });
    var allCountries = useAppSelector(function (state) { return state.localization.allCountries; });
    var onChange = function (event) {
        var newCountry = getCountryByCode(event.target.value);
        dispatch(updateCurrentCountry(newCountry));
        dispatch(clearCountry());
    };
    var menuItemDoms = [];
    allCountries.forEach(function (country) {
        menuItemDoms.push(jsxRuntime.exports.jsx("option", __assign({ value: country.code }, { children: country.name }), country.code));
    });
    return (jsxRuntime.exports.jsxs("div", __assign({ className: "kyc-input-container" }, { children: [jsxRuntime.exports.jsx("label", __assign({ className: "kyc-input-label" }, { children: currentCountry.labels.country })), jsxRuntime.exports.jsx("select", __assign({ name: "country", "data-id": "input-select-kyc-country", value: currentCountry.code, onChange: onChange }, { children: menuItemDoms })), jsxRuntime.exports.jsx(ErrorMessage$1, {})] })));
};
var KYCProvinceSelector = function () {
    var dispatch = useAppDispatch();
    var currentProvince = useAppSelector(function (state) { return state.kycForm.formValues.province; });
    var currentCountry = useAppSelector(function (state) { return state.localization.currentCountry; });
    var error = useAppSelector(function (state) { return state.kycForm.formErrors.province; });
    var onChange = function (event) {
        var provinceCode = event.target.value;
        dispatch(updateKYCFormValue({ value: provinceCode, type: KYCFieldType.PROVINCE }));
    };
    var menuItemDoms = [];
    currentCountry.zones.forEach(function (zone) {
        menuItemDoms.push(jsxRuntime.exports.jsx("option", __assign({ value: zone.code }, { children: zone.name }), zone.code));
    });
    return (jsxRuntime.exports.jsxs("div", __assign({ className: "kyc-input-container" }, { children: [jsxRuntime.exports.jsx("label", __assign({ className: "kyc-input-label" }, { children: currentCountry.labels.zone })), jsxRuntime.exports.jsx("select", __assign({ "data-id": "input-select-kyc-province", value: currentProvince, onChange: onChange }, { children: menuItemDoms })), jsxRuntime.exports.jsx(ErrorMessage$1, { error: error })] })));
};
var KYCField = (function (_a) {
    var type = _a.type;
    // wait for the loading screen if still waiting for the country to load
    var country = useAppSelector(function (state) { return state.localization.currentCountry; });
    if (country.code === undefined) {
        return jsxRuntime.exports.jsx("div", {});
    }
    var dom = null;
    switch (type) {
        case KYCFieldType.ADDRESS_LINE_1:
        case KYCFieldType.ADDRESS_LINE_2:
        case KYCFieldType.FIRST_NAME:
        case KYCFieldType.LAST_NAME:
        case KYCFieldType.ZIP:
        case KYCFieldType.CITY:
            dom = jsxRuntime.exports.jsx(KYCTextField, { type: type, country: country });
            break;
        case KYCFieldType.PROVINCE:
            dom = jsxRuntime.exports.jsx(KYCProvinceSelector, {});
            break;
        case KYCFieldType.COUNTRY:
            dom = jsxRuntime.exports.jsx(KYCCountrySelector, {});
            break;
    }
    if (!dom) {
        throw Error('Invalid Field Type');
    }
    return dom;
});

var generateFields = function () {
    var Fields = {};
    Object.values(KYCFieldType).forEach(function (typeString) {
        var type = typeString;
        var ref = createRef();
        var dom = jsxRuntime.exports.jsx(KYCField, { type: type }, type);
        Fields[type] = { dom: dom, ref: ref, type: type };
    });
    return Fields;
};

// setTimeout to promise
var countryRemoveSpecialChars = function (country) {
    return country.replaceAll('-', ' ').replaceAll('ô', 'o').replaceAll("'", '');
};

var getFormValues = function () {
    var state = store.getState();
    var values = {
        customerId: state.auth.customerId,
        addressLine1: state.kycForm.formValues.address1,
        addressLine2: state.kycForm.formValues.address2,
        addressCity: state.kycForm.formValues.city,
        addressZip: state.kycForm.formValues.zip,
        addressState: state.kycForm.formValues.province,
        addressCountry: countryRemoveSpecialChars(state.localization.currentCountry.code),
        firstName: state.kycForm.formValues.firstName,
        lastName: state.kycForm.formValues.lastName,
    };
    Object.keys(values).forEach(function (k) { return !values[k] && delete values[k]; });
    return values;
};
var nameError = 'Enter your first and last name as they are written in your ID';
/**
 * Sends the KYC form to the backend. If Development Bypass is enabled,
 * the desired configurations for ID and AM verification will be sent
 * to the bypass endpoint instead. The form data is read from the redux store
 */
var submitKYCForm = function (backendUrl, jwt) { return __awaiter$g(void 0, void 0, void 0, function () {
    var request, url, response, errorJson;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                request = getFormValues();
                url = "".concat(backendUrl, "/application");
                return [4 /*yield*/, fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            Authorization: "Bearer ".concat(jwt),
                        },
                        body: JSON.stringify(request),
                    })];
            case 1:
                response = _a.sent();
                if (!(response.status >= 400)) return [3 /*break*/, 3];
                return [4 /*yield*/, response.json()];
            case 2:
                errorJson = _a.sent();
                switch (errorJson.error) {
                    case 'First name failed verification':
                    case 'Last name failed verification': {
                        // Names are validated together so error for both
                        store.dispatch(setKYCFormError({
                            type: KYCFieldType.FIRST_NAME,
                            value: nameError,
                        }));
                        store.dispatch(setKYCFormError({
                            type: KYCFieldType.LAST_NAME,
                            value: nameError,
                        }));
                        break;
                    }
                    case 'Must supply a state':
                        store.dispatch(setKYCFormError({
                            type: KYCFieldType.PROVINCE,
                            value: 'Must supply a state',
                        }));
                        break;
                }
                throw new Error('Form is invalid');
            case 3: return [2 /*return*/, response.json()];
        }
    });
}); };

var validateKycFields = function () {
    var state = store.getState();
    var valid = true;
    if (state.kycForm.formFieldTypes.includes(KYCFieldType.ADDRESS_LINE_1) &&
        state.kycForm.formValues.address1.length < 2) {
        store.dispatch(setKYCFormError({
            type: KYCFieldType.ADDRESS_LINE_1,
            value: 'Please enter a valid address',
        }));
        valid = false;
    }
    if (state.kycForm.formFieldTypes.includes(KYCFieldType.FIRST_NAME) &&
        state.kycForm.formFieldTypes.includes(KYCFieldType.LAST_NAME) &&
        (state.kycForm.formValues.firstName.length < 1 || state.kycForm.formValues.lastName.length < 1)) {
        // Names are validated together
        store.dispatch(setKYCFormError({
            type: KYCFieldType.FIRST_NAME,
            value: 'Please enter a valid first name',
        }));
        store.dispatch(setKYCFormError({
            type: KYCFieldType.LAST_NAME,
            value: 'Please enter a valid last name',
        }));
        valid = false;
    }
    if (state.kycForm.formFieldTypes.includes(KYCFieldType.CITY) && state.kycForm.formValues.city.length < 2) {
        store.dispatch(setKYCFormError({
            type: KYCFieldType.CITY,
            value: 'Please enter a valid city',
        }));
        valid = false;
    }
    if (state.kycForm.formFieldTypes.includes(KYCFieldType.ZIP) && state.kycForm.formValues.zip.length < 2) {
        store.dispatch(setKYCFormError({
            type: KYCFieldType.ZIP,
            value: 'Please enter a valid zip/postal code',
        }));
        valid = false;
    }
    if (state.localization.currentCountry.code === 'US' && !state.kycForm.formValues.province) {
        store.dispatch(setKYCFormError({
            type: KYCFieldType.PROVINCE,
            value: 'Please enter a valid state',
        }));
        valid = false;
    }
    return valid;
};

var FieldName;
(function (FieldName) {
    FieldName["FirstName"] = "firstName";
    FieldName["LastName"] = "lastName";
    FieldName["Country"] = "country";
    FieldName["City"] = "city";
    FieldName["PostalCode"] = "zip";
    FieldName["Zone"] = "province";
    FieldName["Address1"] = "address1";
    FieldName["Address2"] = "address2";
    FieldName["Phone"] = "phone";
    FieldName["Company"] = "company";
})(FieldName || (FieldName = {}));
var GraphqlOperationName;
(function (GraphqlOperationName) {
    GraphqlOperationName["Countries"] = "countries";
    GraphqlOperationName["Country"] = "country";
})(GraphqlOperationName || (GraphqlOperationName = {}));
var DEFAULT_COUNTRY_CODE = 'US';
var DEFAULT_PROVINCE = 'AL';

var getFieldOrder = function (orderedFields, mobile) {
    if (mobile === void 0) { mobile = false; }
    var enums = Object.values(KYCFieldType);
    var newOrder = [];
    orderedFields.forEach(function (fieldList) {
        if (mobile) {
            fieldList.forEach(function (field) {
                if (enums.includes(field)) {
                    newOrder.push([field]);
                }
            });
        }
        else {
            var row_1 = [];
            fieldList.forEach(function (field) {
                if (enums.includes(field)) {
                    if (row_1.length >= 2) {
                        newOrder.push(row_1);
                        row_1 = [field];
                    }
                    else {
                        row_1.push(field);
                    }
                }
            });
            newOrder.push(row_1);
        }
    });
    return newOrder;
};
var DEFAULT_ORDER = [
    [KYCFieldType.FIRST_NAME, KYCFieldType.LAST_NAME],
    [KYCFieldType.ADDRESS_LINE_1],
    [KYCFieldType.ADDRESS_LINE_2],
    [KYCFieldType.CITY],
    [KYCFieldType.COUNTRY, KYCFieldType.PROVINCE, KYCFieldType.ZIP],
];
var KycFormView = function (_a) {
    var backendUrl = _a.backendUrl, jwt = _a.jwt;
    var currentCountry = useAppSelector(function (state) { return state.localization.currentCountry; });
    var submittingForm = useAppSelector(function (state) { return state.kycForm.submitting; });
    var _b = React.useState(DEFAULT_ORDER), fieldOrder = _b[0], setFieldOrder = _b[1];
    var dispatch = useAppDispatch();
    var fieldMap = generateFields();
    var navigateByStatus = useNavigation().navigateByStatus;
    var debug = useSettings().debug;
    // Fetch all the countries on mount and set default locale values
    useEffect(function () {
        I8NAddressFormatter.getCountries().then(function (countries) {
            dispatch(fetchAllCountries(countries));
            dispatch(updateCurrentCountry(getCountryByCode(DEFAULT_COUNTRY_CODE)));
            dispatch(updateKYCFormValue({ type: KYCFieldType.PROVINCE, value: DEFAULT_PROVINCE }));
        });
    }, []);
    // Every time currentCountry is modified, re-order the fields
    useEffect(function () {
        if (currentCountry && currentCountry.code) {
            I8NAddressFormatter.getOrderedFields(currentCountry.code).then(function (orderedFields) {
                var newFieldOrder = getFieldOrder(orderedFields);
                setFieldOrder(newFieldOrder);
                // Flatten used KyxFieldType fields, order doesn't matter here
                var formFieldTypes = newFieldOrder.reduce(function (accumulator, value) { return accumulator.concat(value); }, []);
                dispatch(updateKYCFormFieldTypes(formFieldTypes));
            });
        }
    }, [currentCountry]);
    // Split the doms into halves. So the form has two columns.
    // TODO: REFACTOR
    var doms = [];
    fieldOrder.forEach(function (fieldTypes, i) {
        var rowDoms = [];
        fieldTypes.forEach(function (fieldType, j) {
            var fieldDom = jsxRuntime.exports.jsx(Fragment$1, { children: fieldMap[fieldType].dom }, "FieldContainer-".concat(i, "-").concat(j));
            rowDoms.push(fieldDom);
        });
        var key = "FormRow-".concat(i);
        doms.push(jsxRuntime.exports.jsx("div", __assign({ className: "FormRow" }, { children: rowDoms }), key));
        if (fieldTypes.includes(KYCFieldType.LAST_NAME)) {
            doms.push();
        }
    });
    return (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx("section", { children: doms }), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx("small", { children: "* By clicking Confirm, you consent to allow ky0x to store and process your information in order to provide the requested verification service(s)." }) }), jsxRuntime.exports.jsx("section", __assign({ className: "kyc-buttons kyc-buttons-single" }, { children: jsxRuntime.exports.jsx("button", __assign({ className: "kyc-button kyc-button-primary", onClick: function () { return __awaiter$g(void 0, void 0, void 0, function () {
                        var response, e_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dispatch(submitting());
                                    if (!validateKycFields()) return [3 /*break*/, 6];
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 4, , 5]);
                                    return [4 /*yield*/, submitKYCForm(backendUrl, jwt)];
                                case 2:
                                    response = _a.sent();
                                    return [4 /*yield*/, dispatch(submittedSuccessfully())];
                                case 3:
                                    _a.sent();
                                    navigateByStatus({
                                        contractParameters: response.contractParameters,
                                        error: response.error,
                                    });
                                    return [3 /*break*/, 5];
                                case 4:
                                    e_1 = _a.sent();
                                    debug && console.log('KYC form view error: ', e_1);
                                    dispatch(submittingFailed());
                                    dispatch({
                                        type: 'FORM_ERROR',
                                        payload: 'Invalid form: please try again',
                                    });
                                    return [3 /*break*/, 5];
                                case 5: return [3 /*break*/, 7];
                                case 6:
                                    dispatch(submittingFailed());
                                    _a.label = 7;
                                case 7: return [2 /*return*/];
                            }
                        });
                    }); }, disabled: submittingForm, "data-id": "button-submit-kyc" }, { children: submittingForm ? 'Submitting...' : 'Submit information' })) }))] }));
};

var PageKYCForm = function (_a) {
    var jwt = _a.jwt, backendUrl = _a.backendUrl;
    return (jsxRuntime.exports.jsxs(PageLayout, { children: [jsxRuntime.exports.jsx("h1", { children: "Fill the form with your information." }), jsxRuntime.exports.jsxs("section", { children: ["Financial regulators require us to verify your identity.", ' ', jsxRuntime.exports.jsx("div", __assign({ className: "kyc-input-name-note" }, { children: "Please enter your first and last name as they are written in your ID" }))] }), jsxRuntime.exports.jsx("section", { children: jsxRuntime.exports.jsx(KycFormView, { jwt: jwt, backendUrl: backendUrl }) })] }));
};

var PageKYCError = function () {
    return (jsxRuntime.exports.jsxs(PageLayout, __assign({ "data-id": "page-kyc-form-warning" }, { children: [jsxRuntime.exports.jsx("h1", { children: "We detected a potential risk related to your information." }), jsxRuntime.exports.jsx("section", { children: "Your identity was verified but we found potential risk related to it. This designation will be reviewed by the issuer and resolved within 3 business days. Please try again after 3 business days. If you are still receiving this message after waiting, please contact the issuer." }), jsxRuntime.exports.jsx(ContactLinks, {})] })));
};

var useResetStore = function () {
    var dispatch = useAppDispatch();
    var resetAuth = useAuth().resetAuth;
    var resetNavigation = useNavigation().resetNavigation;
    var resetStore = useCallback(function () {
        resetAuth();
        resetNavigation();
        dispatch(reset());
        dispatch(reset$7());
        dispatch(reset$4());
        dispatch(reset$1());
        dispatch(reset$2());
        dispatch(reset$3());
    }, [
        dispatch,
        resetAuth,
        resetNavigation,
        reset,
        reset$7,
        reset$4,
        reset$1,
        reset$2,
        reset$3,
    ]);
    return useMemo(function () {
        return {
            resetStore: resetStore,
        };
    }, [resetStore]);
};

var ErrorType;
(function (ErrorType) {
    ErrorType["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorType["OTHER"] = "OTHER";
})(ErrorType || (ErrorType = {}));
var ErrorMessage = function (_a) {
    var errorType = _a.errorType;
    var generateErrorMessage = function (errorType) {
        switch (errorType) {
            case ErrorType.INSUFFICIENT_FUNDS:
                return 'Insufficient ETH balance';
            case ErrorType.OTHER:
            default:
                return 'Something went wrong';
        }
    };
    return jsxRuntime.exports.jsx("div", __assign({ className: "kyc-error-message" }, { children: errorType && generateErrorMessage(errorType) }));
};

var PDF_C_MAP_URL = "//cdn.jsdelivr.net/npm/pdfjs-dist@".concat(pdf.exports.version, "/cmaps/");
var PDF_WORKER_SRC = "//cdnjs.cloudflare.com/ajax/libs/pdf.js/".concat(pdf.exports.version, "/pdf.worker.min.js");
pdf.exports.GlobalWorkerOptions.workerSrc = PDF_WORKER_SRC;
var App = function (_a) {
    var error = _a.error, _debug = _a._debug, apiKey = _a.apiKey, onSign = _a.onSign, account = _a.account, children = _a.children, signature = _a.signature, mintPrice = _a.mintPrice, className = _a.className, backendUrl = _a.backendUrl, onMintClick = _a.onMintClick, mintComplete = _a.mintComplete, onPageChange = _a.onPageChange, etherscanUrl = _a.etherscanUrl, transactionHash = _a.transactionHash, _unsafeForcePage = _a._unsafeForcePage, showSocialButtons = _a.showSocialButtons;
    var setDebugMode = useSettings().setDebugMode;
    var _b = useNavigation(), page = _b.page, navigate = _b.navigate;
    var _c = useAuth(), jwt = _c.jwt, setAuth = _c.setAuth;
    var resetStore = useResetStore().resetStore;
    var _d = useState(true), loading = _d[0], setLoading = _d[1];
    // Login on initial render and credentials change.
    useEffect(function () {
        resetStore();
        setLoading(true);
        if (account) {
            if (!apiKey) {
                // No API key, redirecting.
                navigate(PageError.AUTH_ERROR);
                setLoading(false);
            }
            else {
                // Fetching JWT
                login({ apiKey: apiKey, account: account, backendUrl: backendUrl })
                    .then(function (jwt) {
                    setAuth(jwt);
                    setLoading(false);
                })
                    .catch(function (error) {
                    // Authentication error, redirecting.
                    console.error('Login error: ', error);
                    navigate(PageError.AUTH_ERROR);
                    setLoading(false);
                });
            }
        }
    }, [resetStore, apiKey, account, backendUrl]);
    // unsafe dev mode flag
    useEffect(function () {
        // Calling onPageChange if defined
        onPageChange && onPageChange(page);
        // Force navigating if _unsafeForcePage is defined
        if (_unsafeForcePage && _unsafeForcePage !== page) {
            console.warn('Warning, _unsafeForcePage prop should only be used during development, force navigating to page: ', _unsafeForcePage);
            navigate(_unsafeForcePage);
        }
    }, [page, _unsafeForcePage, _debug]);
    useEffect(function () {
        // Debug mode
        if (_debug) {
            console.warn('Warning, _debug prop should only be used during development, make sure to remove it in production, setting debug mode to true.');
            setDebugMode(_debug);
        }
    }, [_debug]);
    return (jsxRuntime.exports.jsx("div", __assign({ className: className }, { children: loading || !account || !mintPrice ? (jsxRuntime.exports.jsx(Loader, { children: children })) : (jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, { children: [jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.INTRO }, { children: jsxRuntime.exports.jsx(PageIntro, {}) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.TOS }, { children: jsxRuntime.exports.jsx(PageTOS, { backendUrl: backendUrl }) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.SIGN_WALLET }, { children: jsxRuntime.exports.jsx(PageSignWallet, __assign({ jwt: jwt, onSign: onSign, account: account, signature: signature, backendUrl: backendUrl }, { children: children })) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.VERIFF }, { children: jsxRuntime.exports.jsx(PageVeriff, { children: children }) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.VERIFF_STATUS }, { children: jsxRuntime.exports.jsx(PageVeriffStatus, __assign({ backendUrl: backendUrl }, { children: children })) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.KYC_FORM }, { children: jsxRuntime.exports.jsx(PageKYCForm, { jwt: jwt, backendUrl: backendUrl }) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.MINT_NFT }, { children: jsxRuntime.exports.jsx(PageMintNFT, { account: account, signature: signature, mintPrice: mintPrice, backendUrl: backendUrl, onMintClick: onMintClick, transactionHash: transactionHash }) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.MINT_NFT_STATUS }, { children: jsxRuntime.exports.jsx(PageMintNFTStatus, __assign({ mintComplete: mintComplete, etherscanUrl: etherscanUrl, transactionHash: transactionHash }, { children: children })) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: Page$1.MINT_NFT_COMPLETE }, { children: jsxRuntime.exports.jsx(PageMintNFTComplete, { account: account, etherscanUrl: etherscanUrl, transactionHash: transactionHash, showSocialButtons: showSocialButtons }) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: PageError.AUTH_ERROR }, { children: jsxRuntime.exports.jsx(PageAuthError, {}) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: PageError.VERIFF_ERROR }, { children: jsxRuntime.exports.jsx(PageVeriffError, { backendUrl: backendUrl }) })), jsxRuntime.exports.jsx(Navigator, __assign({ page: PageError.KYC_ERROR }, { children: jsxRuntime.exports.jsx(PageKYCError, {}) })), jsxRuntime.exports.jsx(ErrorMessage, { errorType: error }), jsxRuntime.exports.jsxs("small", __assign({ className: "kyc-connected-account" }, { children: ["connected: ", truncateAccount(account)] }))] })) })));
};

var Governance_abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "previousAdmin",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "newAdmin",
				type: "address"
			}
		],
		name: "AdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_tokenAddr",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_isAllowed",
				type: "bool"
			}
		],
		name: "AllowTokenPayment",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldPrice",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_price",
				type: "uint256"
			}
		],
		name: "AttributeMintPriceUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldPrice",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_price",
				type: "uint256"
			}
		],
		name: "AttributePriceUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "beacon",
				type: "address"
			}
		],
		name: "BeaconUpgraded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldPrice",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_price",
				type: "uint256"
			}
		],
		name: "BusinessAttributePriceUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_eligibleStatus",
				type: "bool"
			}
		],
		name: "EligibleAttributeByDIDUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_eligibleStatus",
				type: "bool"
			}
		],
		name: "EligibleAttributeUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_tokenId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "_eligibleStatus",
				type: "bool"
			}
		],
		name: "EligibleTokenUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_issuer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_newTreasury",
				type: "address"
			}
		],
		name: "IssuerAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_issuer",
				type: "address"
			}
		],
		name: "IssuerDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "issuer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "enum QuadGovernanceStore.IssuerStatus",
				name: "oldStatus",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "enum QuadGovernanceStore.IssuerStatus",
				name: "newStatus",
				type: "uint8"
			}
		],
		name: "IssuerStatusChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "OracleUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "PassportAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldMintPrice",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_mintPrice",
				type: "uint256"
			}
		],
		name: "PassportMintPriceUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldVersion",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_version",
				type: "uint256"
			}
		],
		name: "PassportVersionUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldSplit",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_split",
				type: "uint256"
			}
		],
		name: "RevenueSplitIssuerUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "previousAdminRole",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "newAdminRole",
				type: "bytes32"
			}
		],
		name: "RoleAdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleGranted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleRevoked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "TreasuryUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		inputs: [
		],
		name: "DEFAULT_ADMIN_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "GOVERNANCE_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "ISSUER_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "PAUSER_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "READER_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddr",
				type: "address"
			},
			{
				internalType: "bool",
				name: "_isAllowed",
				type: "bool"
			}
		],
		name: "allowTokenPayment",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "config",
		outputs: [
			{
				internalType: "uint256",
				name: "revSplitIssuer",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "passportVersion",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "mintPrice",
				type: "uint256"
			},
			{
				internalType: "contract IQuadPassport",
				name: "passport",
				type: "address"
			},
			{
				internalType: "address",
				name: "oracle",
				type: "address"
			},
			{
				internalType: "address",
				name: "treasury",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_issuer",
				type: "address"
			}
		],
		name: "deleteIssuer",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "eligibleAttributes",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "eligibleAttributesArray",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "eligibleAttributesByDID",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "eligibleTokenId",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "eligibleTokenPayments",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getEligibleAttributesLength",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_issuer",
				type: "address"
			}
		],
		name: "getIssuerStatus",
		outputs: [
			{
				internalType: "enum QuadGovernanceStore.IssuerStatus",
				name: "",
				type: "uint8"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getIssuers",
		outputs: [
			{
				components: [
					{
						internalType: "address",
						name: "issuer",
						type: "address"
					},
					{
						internalType: "enum QuadGovernanceStore.IssuerStatus",
						name: "status",
						type: "uint8"
					}
				],
				internalType: "struct QuadGovernanceStore.Issuer[]",
				name: "",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getIssuersLength",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddr",
				type: "address"
			}
		],
		name: "getPrice",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getPriceETH",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleAdmin",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "grantRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "hasRole",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_admin",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "issuers",
		outputs: [
			{
				internalType: "address",
				name: "issuer",
				type: "address"
			},
			{
				internalType: "enum QuadGovernanceStore.IssuerStatus",
				name: "status",
				type: "uint8"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "issuersTreasury",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "mintPrice",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "mintPricePerAttribute",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "oracle",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "passport",
		outputs: [
			{
				internalType: "contract IQuadPassport",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "passportVersion",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "pricePerAttribute",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "pricePerBusinessAttribute",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "renounceRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "revSplitIssuer",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "revokeRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_price",
				type: "uint256"
			}
		],
		name: "setAttributeMintPrice",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_price",
				type: "uint256"
			}
		],
		name: "setAttributePrice",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_price",
				type: "uint256"
			}
		],
		name: "setBusinessAttributePrice",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "bool",
				name: "_eligibleStatus",
				type: "bool"
			}
		],
		name: "setEligibleAttribute",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "bool",
				name: "_eligibleStatus",
				type: "bool"
			}
		],
		name: "setEligibleAttributeByDID",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_tokenId",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "_eligibleStatus",
				type: "bool"
			}
		],
		name: "setEligibleTokenId",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_issuer",
				type: "address"
			},
			{
				internalType: "address",
				name: "_treasury",
				type: "address"
			}
		],
		name: "setIssuer",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_issuer",
				type: "address"
			},
			{
				internalType: "enum QuadGovernanceStore.IssuerStatus",
				name: "_status",
				type: "uint8"
			}
		],
		name: "setIssuerStatus",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_mintPrice",
				type: "uint256"
			}
		],
		name: "setMintPrice",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_oracleAddr",
				type: "address"
			}
		],
		name: "setOracle",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_passportAddr",
				type: "address"
			}
		],
		name: "setPassportContractAddress",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_version",
				type: "uint256"
			}
		],
		name: "setPassportVersion",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_split",
				type: "uint256"
			}
		],
		name: "setRevSplitIssuer",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_treasury",
				type: "address"
			}
		],
		name: "setTreasury",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "treasury",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_newGovernance",
				type: "address"
			}
		],
		name: "updateGovernanceInPassport",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newImplementation",
				type: "address"
			}
		],
		name: "upgradeTo",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newImplementation",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "upgradeToAndCall",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	}
];

var Passport_abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "previousAdmin",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "newAdmin",
				type: "address"
			}
		],
		name: "AdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "ApprovalForAll",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "beacon",
				type: "address"
			}
		],
		name: "BeaconUpgraded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "_oldGovernance",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_governance",
				type: "address"
			}
		],
		name: "GovernanceUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256[]",
				name: "ids",
				type: "uint256[]"
			},
			{
				indexed: false,
				internalType: "uint256[]",
				name: "values",
				type: "uint256[]"
			}
		],
		name: "TransferBatch",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "id",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "TransferSingle",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "string",
				name: "value",
				type: "string"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "id",
				type: "uint256"
			}
		],
		name: "URI",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		stateMutability: "payable",
		type: "fallback"
	},
	{
		inputs: [
		],
		name: "GOVERNANCE_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "ISSUER_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "READER_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_issuer",
				type: "address"
			}
		],
		name: "attributes",
		outputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "value",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "epoch",
						type: "uint256"
					}
				],
				internalType: "struct QuadPassportStore.Attribute",
				name: "",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "_dID",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_issuer",
				type: "address"
			}
		],
		name: "attributesByDID",
		outputs: [
			{
				components: [
					{
						internalType: "bytes32",
						name: "value",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "epoch",
						type: "uint256"
					}
				],
				internalType: "struct QuadPassportStore.Attribute",
				name: "",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "id",
				type: "uint256"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "accounts",
				type: "address[]"
			},
			{
				internalType: "uint256[]",
				name: "ids",
				type: "uint256[]"
			}
		],
		name: "balanceOfBatch",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_tokenId",
				type: "uint256"
			}
		],
		name: "burnPassport",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_tokenId",
				type: "uint256"
			}
		],
		name: "burnPassportIssuer",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "governance",
		outputs: [
			{
				internalType: "contract IQuadGovernance",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_token",
				type: "address"
			},
			{
				internalType: "address",
				name: "_account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "increaseAccountBalance",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "increaseAccountBalanceETH",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_governanceContract",
				type: "address"
			},
			{
				internalType: "string",
				name: "_uri",
				type: "string"
			}
		],
		name: "initialize",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "address",
				name: "operator",
				type: "address"
			}
		],
		name: "isApprovedForAll",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "address",
						name: "account",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "tokenId",
						type: "uint256"
					},
					{
						internalType: "bytes32",
						name: "quadDID",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "aml",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "country",
						type: "bytes32"
					},
					{
						internalType: "bytes32",
						name: "isBusiness",
						type: "bytes32"
					},
					{
						internalType: "uint256",
						name: "issuedAt",
						type: "uint256"
					}
				],
				internalType: "struct QuadPassportStore.MintConfig",
				name: "_config",
				type: "tuple"
			},
			{
				internalType: "bytes",
				name: "_sigIssuer",
				type: "bytes"
			},
			{
				internalType: "bytes",
				name: "_sigAccount",
				type: "bytes"
			}
		],
		name: "mintPassport",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "ids",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "safeBatchTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "id",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "safeTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "setApprovalForAll",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_tokenId",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_value",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_issuedAt",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "_sig",
				type: "bytes"
			}
		],
		name: "setAttribute",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_tokenId",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "_attribute",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_value",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_issuedAt",
				type: "uint256"
			}
		],
		name: "setAttributeIssuer",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_governanceContract",
				type: "address"
			}
		],
		name: "setGovernance",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newImplementation",
				type: "address"
			}
		],
		name: "upgradeTo",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newImplementation",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "upgradeToAndCall",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "uri",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address payable",
				name: "_to",
				type: "address"
			}
		],
		name: "withdrawETH",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address payable",
				name: "_to",
				type: "address"
			},
			{
				internalType: "address",
				name: "_token",
				type: "address"
			}
		],
		name: "withdrawToken",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var KycForm = function (props) {
    return (jsxRuntime.exports.jsx(Provider$1, __assign({ store: store }, { children: jsxRuntime.exports.jsx(App, __assign({}, props)) })));
};

export { ErrorType, KycForm, Page$1 as Page, PageError, Governance_abi as QUADRATA_GOVERNANCE_ABI, Passport_abi as QUADRATA_PASSPORT_ABI };
